/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { AfterContentInit, ElementRef, NgZone, OnDestroy } from '@angular/core';
import Draggable from '@telerik/kendo-draggable';
import { DragClueService } from './drag-clue/drag-clue.service';
import { DropHintService } from './drop-hint/drop-hint.service';
import { DragClueTemplateDirective } from './drag-clue/drag-clue-template.directive';
import { DropHintTemplateDirective } from './drop-hint/drop-hint-template.directive';
import { TreeViewComponent } from '../treeview.component';
/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances.
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
import * as ɵngcc0 from '@angular/core';
export declare class DragAndDropDirective implements AfterContentInit, OnDestroy {
    private element;
    private zone;
    private treeview;
    private dragClueService;
    private dropHintService;
    /**
     * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
     * If enabled, the `removeItem` event will not be fired on the source TreeView
     * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
     *
     * @default false
     */
    allowCopy: boolean;
    /**
     * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
     * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
     */
    dropZoneTreeViews: TreeViewComponent[];
    /**
     * @hidden
     */
    dragClueTemplate: DragClueTemplateDirective;
    /**
     * @hidden
     */
    dropHintTemplate: DropHintTemplateDirective;
    /**
     * @hidden
     */
    userSelectStyle: string;
    protected draggable: Draggable;
    protected draggedItem: HTMLElement;
    /**
     * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
     * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
     */
    private containerOffset;
    constructor(element: ElementRef<HTMLElement>, zone: NgZone, treeview: TreeViewComponent, dragClueService: DragClueService, dropHintService: DropHintService);
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    handlePress({ originalEvent }: any): void;
    /**
     * @hidden
     */
    handleDrag({ originalEvent, clientX, clientY }: any): void;
    /**
     * @hidden
     */
    handleRelease({ originalEvent, clientY }: any): void;
    private updateDropHintState;
    private updateDragClueState;
    private initalizeDraggable;
    private notifyDragStart;
    private notifyDrag;
    private notifyDrop;
    private notifyDragEnd;
    private getTargetTreeView;
    private disableAnimationsForNextTick;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DragAndDropDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DragAndDropDirective, "[kendoTreeViewDragAndDrop]", never, {
    "allowCopy": "allowCopy";
    "dropZoneTreeViews": "dropZoneTreeViews";
}, {}, ["dragClueTemplate", "dropHintTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1hbmQtZHJvcC5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiZHJhZy1hbmQtZHJvcC5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIEVsZW1lbnRSZWYsIE5nWm9uZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWRyYWdnYWJsZSc7XG5pbXBvcnQgeyBEcmFnQ2x1ZVNlcnZpY2UgfSBmcm9tICcuL2RyYWctY2x1ZS9kcmFnLWNsdWUuc2VydmljZSc7XG5pbXBvcnQgeyBEcm9wSGludFNlcnZpY2UgfSBmcm9tICcuL2Ryb3AtaGludC9kcm9wLWhpbnQuc2VydmljZSc7XG5pbXBvcnQgeyBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9kcmFnLWNsdWUvZHJhZy1jbHVlLXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9kcm9wLWhpbnQvZHJvcC1oaW50LXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUcmVlVmlld0NvbXBvbmVudCB9IGZyb20gJy4uL3RyZWV2aWV3LmNvbXBvbmVudCc7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuYWJsZXMgdGhlIGRyYWdnaW5nIGFuZCBkcm9wcGluZyBpdGVtcyBpbnNpZGUgdGhlIGN1cnJlbnQgVHJlZVZpZXcgb3IgYmV0d2VlbiBtdWx0aXBsZSBsaW5rZWQgVHJlZVZpZXcgY29tcG9uZW50IGluc3RhbmNlcy5cbiAqIFRyaWdnZXJzIHRoZSBbYG5vZGVEcmFnU3RhcnRgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWdzdGFydCksXG4gKiBbYG5vZGVEcmFnYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcmFnKSxcbiAqIFtgbm9kZURyb3BgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyb3ApLFxuICogW2Bub2RlRHJhZ0VuZGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJhZ2VuZCksXG4gKiBbYGFkZEl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtYWRkaXRlbSkgYW5kXG4gKiBbYHJlbW92ZUl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtcmVtb3ZlaXRlbSlcbiAqIGV2ZW50cyB3aGVuIHRoZSBjb3JyZXNwb25kaW5nIGFjdGlvbnMgb2NjdXIgb24gdGhlIHJlc3BlY3RpdmUgVHJlZVZpZXcgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERyYWdBbmREcm9wRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIGVsZW1lbnQ7XG4gICAgcHJpdmF0ZSB6b25lO1xuICAgIHByaXZhdGUgdHJlZXZpZXc7XG4gICAgcHJpdmF0ZSBkcmFnQ2x1ZVNlcnZpY2U7XG4gICAgcHJpdmF0ZSBkcm9wSGludFNlcnZpY2U7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGByZW1vdmVJdGVtYCBldmVudCB3aWxsIGJlIGZpcmVkIGFmdGVyIGFuIGl0ZW0gaXMgZHJvcHBlZCB3aGVuIHRoZSBgY3RybGAga2V5IGlzIHByZXNzZWQuXG4gICAgICogSWYgZW5hYmxlZCwgdGhlIGByZW1vdmVJdGVtYCBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBvbiB0aGUgc291cmNlIFRyZWVWaWV3XG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtbXVsdGlwbGUtdHJlZXZpZXdzKSkuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGFsbG93Q29weTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZlcyB0aGUgVHJlZVZpZXdDb21wb25lbnQgaW5zdGFuY2VzIGludG8gd2hpY2ggZHJhZ2dlZCBpdGVtcyBmcm9tIHRoZSBjdXJyZW50IFRyZWVWaWV3Q29tcG9uZW50IGNhbiBiZSBkcm9wcGVkXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtbXVsdGlwbGUtdHJlZXZpZXdzKSkuXG4gICAgICovXG4gICAgZHJvcFpvbmVUcmVlVmlld3M6IFRyZWVWaWV3Q29tcG9uZW50W107XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyYWdDbHVlVGVtcGxhdGU6IERyYWdDbHVlVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyb3BIaW50VGVtcGxhdGU6IERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHVzZXJTZWxlY3RTdHlsZTogc3RyaW5nO1xuICAgIHByb3RlY3RlZCBkcmFnZ2FibGU6IERyYWdnYWJsZTtcbiAgICBwcm90ZWN0ZWQgZHJhZ2dlZEl0ZW06IEhUTUxFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpZiB0aGUgbGF0dGVyIGhhcyB0aGUgYHRyYW5zZm9ybWAgQ1NTIHByb3AgYXBwbGllZC5cbiAgICAgKiBUcmFuc2Zvcm1lZCBwYXJlbnRzIGNyZWF0ZSBuZXcgc3RhY2tpbmcgY29udGV4dCBhbmQgdGhlIGZpeGVkIGNoaWxkcmVuIG11c3QgYmUgcG9zaXRpb24gYmFzZWQgb24gdGhlIHRyYW5zZm9ybWVkIHBhcmVudC5cbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICAgICAqL1xuICAgIHByaXZhdGUgY29udGFpbmVyT2Zmc2V0O1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LCB6b25lOiBOZ1pvbmUsIHRyZWV2aWV3OiBUcmVlVmlld0NvbXBvbmVudCwgZHJhZ0NsdWVTZXJ2aWNlOiBEcmFnQ2x1ZVNlcnZpY2UsIGRyb3BIaW50U2VydmljZTogRHJvcEhpbnRTZXJ2aWNlKTtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQcmVzcyh7IG9yaWdpbmFsRXZlbnQgfTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlRHJhZyh7IG9yaWdpbmFsRXZlbnQsIGNsaWVudFgsIGNsaWVudFkgfTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlUmVsZWFzZSh7IG9yaWdpbmFsRXZlbnQsIGNsaWVudFkgfTogYW55KTogdm9pZDtcbiAgICBwcml2YXRlIHVwZGF0ZURyb3BIaW50U3RhdGU7XG4gICAgcHJpdmF0ZSB1cGRhdGVEcmFnQ2x1ZVN0YXRlO1xuICAgIHByaXZhdGUgaW5pdGFsaXplRHJhZ2dhYmxlO1xuICAgIHByaXZhdGUgbm90aWZ5RHJhZ1N0YXJ0O1xuICAgIHByaXZhdGUgbm90aWZ5RHJhZztcbiAgICBwcml2YXRlIG5vdGlmeURyb3A7XG4gICAgcHJpdmF0ZSBub3RpZnlEcmFnRW5kO1xuICAgIHByaXZhdGUgZ2V0VGFyZ2V0VHJlZVZpZXc7XG4gICAgcHJpdmF0ZSBkaXNhYmxlQW5pbWF0aW9uc0Zvck5leHRUaWNrO1xufVxuIl19