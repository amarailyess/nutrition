/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { getter, setter } from '@progress/kendo-common';
import { DropPosition } from '../models';
import { expandDropTarget, collapseEmptyParent } from '../drag-and-drop-utils';
import { take } from 'rxjs/operators';
/**
 * @hidden
 */
export class FlatEditingService {
    constructor(flatBinding) {
        this.flatBinding = flatBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, sourceTree, destinationTree }) {
        const destinationDataItem = destinationItem.item.dataItem;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const sourceDataItem = Object.assign({}, sourceItem.item.dataItem);
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationItemId = getter(this.flatBinding.idField)(destinationDataItem);
            setter(this.flatBinding.parentIdField)(sourceDataItem, destinationItemId);
            this.flatBinding.originalData.push(sourceDataItem);
        }
        else {
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = this.flatBinding.originalData.indexOf(destinationDataItem) + shiftIndex;
            this.flatBinding.originalData.splice(targetIndex, 0, sourceDataItem);
            const destinationItemParentId = getter(this.flatBinding.parentIdField)(destinationDataItem);
            setter(this.flatBinding.parentIdField)(sourceDataItem, destinationItemParentId);
        }
        if (sourceTree !== destinationTree) {
            this.addChildNodes(sourceDataItem, sourceTree);
        }
        this.flatBinding.nodes = this.flatBinding.originalData;
    }
    remove({ sourceItem, sourceTree, destinationTree }) {
        const sourceDataItem = sourceItem.item.dataItem;
        const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
        this.flatBinding.originalData.splice(sourceItemIndex, 1);
        if (sourceTree !== destinationTree) {
            this.removeChildNodes(sourceDataItem, sourceTree);
        }
        this.flatBinding.nodes = this.flatBinding.originalData;
        // emit collapse for the parent node if its last child node was spliced
        const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
        collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
    }
    addChildNodes(dataItem, source) {
        const itemChildren = this.fetchAllDescendantNodes(dataItem, source);
        this.flatBinding.originalData.push(...itemChildren);
    }
    removeChildNodes(dataItem, source) {
        const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
        sourceChildren.forEach(item => {
            const index = this.flatBinding.originalData.indexOf(item);
            this.flatBinding.originalData.splice(index, 1);
        });
    }
    fetchAllDescendantNodes(node, sourceTreeView) {
        if (!node) {
            return [];
        }
        let nodes = [];
        sourceTreeView
            .children(node)
            .pipe(take(1))
            .subscribe(children => {
            nodes = nodes.concat(children || []);
            children.forEach(child => nodes = nodes.concat(this.fetchAllDescendantNodes(child, sourceTreeView) || []));
        });
        return nodes;
    }
}
