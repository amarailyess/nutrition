/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { getter, setter } from '@progress/kendo-common';
import { DropPosition } from '../models';
import { collapseEmptyParent, expandDropTarget } from '../drag-and-drop-utils';
/**
 * @hidden
 */
export class HierarchyEditingService {
    constructor(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, destinationTree }) {
        const destinationDataItem = destinationItem.item.dataItem;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const sourceDataItem = Object.assign({}, sourceItem.item.dataItem);
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationChildren = getter(this.hierarchyBinding.childrenField)(destinationDataItem) || [];
            destinationChildren.push(sourceDataItem);
            setter(this.hierarchyBinding.childrenField)(destinationDataItem, destinationChildren);
        }
        else {
            const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = destinationParentNodes.indexOf(destinationDataItem) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, sourceDataItem);
        }
    }
    remove({ sourceItem, sourceTree }) {
        const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        const sourceItemIndex = sourceParentNodes.indexOf(sourceItem.item.dataItem);
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
    }
    getParentNodes(node, treeView) {
        return node.parent ?
            getter(this.hierarchyBinding.childrenField)(node.parent.item.dataItem) :
            treeView.nodes;
    }
}
