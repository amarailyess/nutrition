/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, ViewContainerRef } from '@angular/core';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { BehaviorSubject, Observable } from 'rxjs';
import { CheckedState } from './checkbox/checked-state';
import { DataChangeNotificationService } from './data-change-notification.service';
import { ExpandStateService } from './expand-state.service';
import { NavigationService } from './navigation/navigation.service';
import { NodeChildrenService } from './node-children.service';
import { NodeClickEvent } from './node-click-event.interface';
import { NodeTemplateDirective } from './node-template.directive';
import { SelectionService } from './selection/selection.service';
import { TreeItemLookup } from './treeitem-lookup.interface';
import { TreeItem } from './treeitem.interface';
import { TreeViewLookupService } from './treeview-lookup.service';
import { TreeItemDropEvent, TreeItemAddRemoveArgs, EditService, TreeItemDragEvent, TreeItemDragStartEvent } from './drag-and-drop/models';
/**
 * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).
 *
 * @example
 * {% meta height:350 %}
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 *  _@Component({
 *      selector: 'my-app',
 *      template: `
 *      <kendo-treeview
 *          [nodes]="data"
 *          textField="text"
 *          kendoTreeViewCheckable
 *          kendoTreeViewExpandable
 *          kendoTreeViewSelectable
 *
 *          kendoTreeViewHierarchyBinding
 *          childrenField="items">
 *      </kendo-treeview>
 *  `
 *  })
 *  export class AppComponent {
 *      public data: any[] = [
 *          {
 *              text: "Furniture", items: [
 *                  { text: "Tables & Chairs" },
 *                  { text: "Sofas" },
 *                  { text: "Occasional Furniture" }
 *              ]
 *          },
 *          {
 *              text: "Decor", items: [
 *                  { text: "Bed Linen" },
 *                  { text: "Curtains & Blinds" },
 *                  { text: "Carpets" }
 *              ]
 *          }
 *      ];
 *  }
 * ```
 * {% endmeta %}
 */
import * as ɵngcc0 from '@angular/core';
export declare class TreeViewComponent implements OnChanges, OnInit, OnDestroy {
    element: ElementRef<HTMLElement>;
    protected expandService: ExpandStateService;
    protected navigationService: NavigationService;
    protected nodeChildrenService: NodeChildrenService;
    protected selectionService: SelectionService;
    protected treeViewLookupService: TreeViewLookupService;
    private ngZone;
    private renderer;
    private dataChangeNotification;
    private localization;
    classNames: boolean;
    role: string;
    /** @hidden */
    readonly direction: string;
    /**
     * @hidden
     */
    assetsContainer: ViewContainerRef;
    /**
     * Determines whether the content animation is enabled.
     */
    animate: boolean;
    /** @hidden */
    fetchNodes: () => BehaviorSubject<any[]>;
    /**
     * Fires when the children of the expanded node are loaded.
     */
    childrenLoaded: EventEmitter<{
        children: TreeItem[];
        item: TreeItem;
    }>;
    /**
     * Fires when the user blurs the component.
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires when the user focuses the component.
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires when the user expands a TreeView node.
     */
    expand: EventEmitter<TreeItem>;
    /**
     * Fires when the user collapses a TreeView node.
     */
    collapse: EventEmitter<TreeItem>;
    /**
     * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.
     * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.
     */
    nodeDragStart: EventEmitter<TreeItemDragStartEvent>;
    /**
     * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).
     */
    nodeDrag: EventEmitter<TreeItemDragEvent>;
    /**
     * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
     * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),
     * the `addItem` and `removeItem` events will not be triggered.
     *
     * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was
     * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.
     * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.
     */
    nodeDrop: EventEmitter<TreeItemDropEvent>;
    /**
     * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
     */
    nodeDragEnd: EventEmitter<TreeItemDragEvent>;
    /**
     * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
     * Called on the TreeView where the item is dropped.
     */
    addItem: EventEmitter<TreeItemAddRemoveArgs>;
    /**
     * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
     * Called on the TreeView from where the item is dragged.
     */
    removeItem: EventEmitter<TreeItemAddRemoveArgs>;
    /**
     * Fires when the user selects a TreeView node checkbox
     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
     */
    checkedChange: EventEmitter<TreeItemLookup>;
    /**
     * Fires when the user selects a TreeView node
     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
     */
    selectionChange: EventEmitter<TreeItem>;
    /**
     * Fires when the user clicks a TreeView node.
     */
    nodeClick: EventEmitter<NodeClickEvent>;
    /**
     * Fires when the user double clicks a TreeView node.
     */
    nodeDblClick: EventEmitter<NodeClickEvent>;
    /**
     * @hidden
     */
    nodeTemplate: NodeTemplateDirective;
    /**
     * The nodes which will be displayed by the TreeView
     * ([see example]({% slug databinding_treeview %})).
     */
    nodes: any[];
    /**
     * The fields of the data item that provide the text content of the nodes
     * ([see example]({% slug databinding_treeview %})). If the `textField` input is set
     * to an array, each hierarchical level uses the field that corresponds to the same
     * index in the array, or the last item in the array.
     */
    textField: string | string[];
    /**
     * A function which determines if a specific node has child nodes
     * ([see example]({% slug databinding_treeview %})).
     */
    hasChildren: (item: object) => boolean;
    /**
     * A function which determines if a specific node is selected
     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
     */
    isChecked: (item: object, index: string) => CheckedState;
    /**
     * A function which determines if a specific node is disabled.
     */
    isDisabled: (item: object, index: string) => boolean;
    /**
     * A function which determines if a specific node is expanded.
     */
    isExpanded: (item: object, index: string) => boolean;
    /**
     * A function which determines if a specific node is selected
     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
     */
    isSelected: (item: object, index: string) => boolean;
    /**
     * Determines whether the TreeView keyboard navigable is enabled.
     */
    navigable: boolean;
    /**
     * A function which provides the child nodes for a given parent node
     * ([see example]({% slug databinding_treeview %})).
     */
    children: (item: object) => Observable<object[]>;
    /**
     * @hidden
     */
    editService: EditService;
    checkboxes: boolean;
    expandIcons: boolean;
    touchActions: boolean;
    isActive: boolean;
    data: BehaviorSubject<any[]>;
    private _animate;
    private _isChecked;
    private _isExpanded;
    private _isSelected;
    private _hasChildren;
    private subscriptions;
    private domSubscriptions;
    constructor(element: ElementRef<HTMLElement>, expandService: ExpandStateService, navigationService: NavigationService, nodeChildrenService: NodeChildrenService, selectionService: SelectionService, treeViewLookupService: TreeViewLookupService, ngZone: NgZone, renderer: Renderer2, dataChangeNotification: DataChangeNotificationService, localization: LocalizationService);
    ngOnChanges(_: any): void;
    ngOnDestroy(): void;
    ngOnInit(): void;
    /**
     * Blurs the focused TreeView item.
     */
    blur(): void;
    /**
     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.
     *
     * @example
     * ```ts
     * import { Component } from '@angular/core';
     *
     *  @Component({
     *      selector: 'my-app',
     *      template: `
     *      <button (click)="treeview.focus('1')">Focuses the second node</button>
     *      <kendo-treeview
     *          #treeview
     *          [nodes]="data"
     *          textField="text"
     *      >
     *      </kendo-treeview>
     *  `
     *  })
     *  export class AppComponent {
     *      public data: any[] = [
     *          { text: "Furniture" },
     *          { text: "Decor" }
     *      ];
     *  }
     * ```
     */
    focus(index?: string): void;
    /**
     * Based on the specified index, returns the TreeItemLookup node.
     *
     * @param index - The index of the node.
     * @returns {TreeItemLookup} - The item that was searched (looked up).
     */
    itemLookup(index: string): TreeItemLookup;
    /**
     * @hidden
     */
    isDisabledNode(node: any): boolean;
    /**
     * Triggers the `expand` event for the provided node and displays it's loading indicator.
     */
    expandNode(item: any, index: string): void;
    /**
     * Triggers the `collapse` event for the provided node.
     */
    collapseNode(item: any, index: string): void;
    private attachDomHandlers;
    private focusHandler;
    private blurHandler;
    private clickHandler;
    private keydownHandler;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<TreeViewComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<TreeViewComponent, "kendo-treeview", ["kendoTreeView"], {
    "isDisabled": "isDisabled";
    "navigable": "navigable";
    "children": "children";
    "animate": "animate";
    "nodes": "nodes";
    "hasChildren": "hasChildren";
    "isChecked": "isChecked";
    "isExpanded": "isExpanded";
    "isSelected": "isSelected";
    "textField": "textField";
}, {
    "childrenLoaded": "childrenLoaded";
    "onBlur": "blur";
    "onFocus": "focus";
    "expand": "expand";
    "collapse": "collapse";
    "nodeDragStart": "nodeDragStart";
    "nodeDrag": "nodeDrag";
    "nodeDrop": "nodeDrop";
    "nodeDragEnd": "nodeDragEnd";
    "addItem": "addItem";
    "removeItem": "removeItem";
    "checkedChange": "checkedChange";
    "selectionChange": "selectionChange";
    "nodeClick": "nodeClick";
    "nodeDblClick": "nodeDblClick";
}, ["nodeTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZXZpZXcuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInRyZWV2aWV3LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItbDEwbic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENoZWNrZWRTdGF0ZSB9IGZyb20gJy4vY2hlY2tib3gvY2hlY2tlZC1zdGF0ZSc7XG5pbXBvcnQgeyBEYXRhQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4vZGF0YS1jaGFuZ2Utbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRXhwYW5kU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi9leHBhbmQtc3RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTm9kZUNoaWxkcmVuU2VydmljZSB9IGZyb20gJy4vbm9kZS1jaGlsZHJlbi5zZXJ2aWNlJztcbmltcG9ydCB7IE5vZGVDbGlja0V2ZW50IH0gZnJvbSAnLi9ub2RlLWNsaWNrLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBOb2RlVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL25vZGUtdGVtcGxhdGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3NlbGVjdGlvbi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBUcmVlSXRlbUxvb2t1cCB9IGZyb20gJy4vdHJlZWl0ZW0tbG9va3VwLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlSXRlbSB9IGZyb20gJy4vdHJlZWl0ZW0uaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyZWVWaWV3TG9va3VwU2VydmljZSB9IGZyb20gJy4vdHJlZXZpZXctbG9va3VwLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZUl0ZW1Ecm9wRXZlbnQsIFRyZWVJdGVtQWRkUmVtb3ZlQXJncywgRWRpdFNlcnZpY2UsIFRyZWVJdGVtRHJhZ0V2ZW50LCBUcmVlSXRlbURyYWdTdGFydEV2ZW50IH0gZnJvbSAnLi9kcmFnLWFuZC1kcm9wL21vZGVscyc7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtLZW5kbyBVSSBUcmVlVmlldyBjb21wb25lbnQgZm9yIEFuZ3VsYXJdKHslIHNsdWcgb3ZlcnZpZXdfdHJlZXZpZXcgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiB7JSBtZXRhIGhlaWdodDozNTAgJX1cbiAqIGBgYHRzLXByZXZpZXdcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqICBfQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGtlbmRvLXRyZWV2aWV3XG4gKiAgICAgICAgICBbbm9kZXNdPVwiZGF0YVwiXG4gKiAgICAgICAgICB0ZXh0RmllbGQ9XCJ0ZXh0XCJcbiAqICAgICAgICAgIGtlbmRvVHJlZVZpZXdDaGVja2FibGVcbiAqICAgICAgICAgIGtlbmRvVHJlZVZpZXdFeHBhbmRhYmxlXG4gKiAgICAgICAgICBrZW5kb1RyZWVWaWV3U2VsZWN0YWJsZVxuICpcbiAqICAgICAgICAgIGtlbmRvVHJlZVZpZXdIaWVyYXJjaHlCaW5kaW5nXG4gKiAgICAgICAgICBjaGlsZHJlbkZpZWxkPVwiaXRlbXNcIj5cbiAqICAgICAgPC9rZW5kby10cmVldmlldz5cbiAqICBgXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICAgcHVibGljIGRhdGE6IGFueVtdID0gW1xuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIHRleHQ6IFwiRnVybml0dXJlXCIsIGl0ZW1zOiBbXG4gKiAgICAgICAgICAgICAgICAgIHsgdGV4dDogXCJUYWJsZXMgJiBDaGFpcnNcIiB9LFxuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiU29mYXNcIiB9LFxuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiT2NjYXNpb25hbCBGdXJuaXR1cmVcIiB9XG4gKiAgICAgICAgICAgICAgXVxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICB0ZXh0OiBcIkRlY29yXCIsIGl0ZW1zOiBbXG4gKiAgICAgICAgICAgICAgICAgIHsgdGV4dDogXCJCZWQgTGluZW5cIiB9LFxuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiQ3VydGFpbnMgJiBCbGluZHNcIiB9LFxuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiQ2FycGV0c1wiIH1cbiAqICAgICAgICAgICAgICBdXG4gKiAgICAgICAgICB9XG4gKiAgICAgIF07XG4gKiAgfVxuICogYGBgXG4gKiB7JSBlbmRtZXRhICV9XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFRyZWVWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gICAgcHJvdGVjdGVkIGV4cGFuZFNlcnZpY2U6IEV4cGFuZFN0YXRlU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgbmF2aWdhdGlvblNlcnZpY2U6IE5hdmlnYXRpb25TZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBub2RlQ2hpbGRyZW5TZXJ2aWNlOiBOb2RlQ2hpbGRyZW5TZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBzZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlO1xuICAgIHByb3RlY3RlZCB0cmVlVmlld0xvb2t1cFNlcnZpY2U6IFRyZWVWaWV3TG9va3VwU2VydmljZTtcbiAgICBwcml2YXRlIG5nWm9uZTtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgZGF0YUNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICBwcml2YXRlIGxvY2FsaXphdGlvbjtcbiAgICBjbGFzc05hbWVzOiBib29sZWFuO1xuICAgIHJvbGU6IHN0cmluZztcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHJlYWRvbmx5IGRpcmVjdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBhc3NldHNDb250YWluZXI6IFZpZXdDb250YWluZXJSZWY7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb250ZW50IGFuaW1hdGlvbiBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGFuaW1hdGU6IGJvb2xlYW47XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmZXRjaE5vZGVzOiAoKSA9PiBCZWhhdmlvclN1YmplY3Q8YW55W10+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIGNoaWxkcmVuIG9mIHRoZSBleHBhbmRlZCBub2RlIGFyZSBsb2FkZWQuXG4gICAgICovXG4gICAgY2hpbGRyZW5Mb2FkZWQ6IEV2ZW50RW1pdHRlcjx7XG4gICAgICAgIGNoaWxkcmVuOiBUcmVlSXRlbVtdO1xuICAgICAgICBpdGVtOiBUcmVlSXRlbTtcbiAgICB9PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGJsdXJzIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgb25CbHVyOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvbkZvY3VzOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGV4cGFuZHMgYSBUcmVlVmlldyBub2RlLlxuICAgICAqL1xuICAgIGV4cGFuZDogRXZlbnRFbWl0dGVyPFRyZWVJdGVtPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNvbGxhcHNlcyBhIFRyZWVWaWV3IG5vZGUuXG4gICAgICovXG4gICAgY29sbGFwc2U6IEV2ZW50RW1pdHRlcjxUcmVlSXRlbT47XG4gICAgLyoqXG4gICAgICogRmlyZXMganVzdCBiZWZvcmUgdGhlIGRyYWdnaW5nIG9mIHRoZSBub2RlIHN0YXJ0cyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLlxuICAgICAqIElmIHlvdSBwcmV2ZW50IHRoZSBldmVudCBkZWZhdWx0LCBubyBkcmFnIGhpbnQgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgc3Vic2VxdWVudCBkcmFnLXJlbGF0ZWQgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAqL1xuICAgIG5vZGVEcmFnU3RhcnQ6IEV2ZW50RW1pdHRlcjxUcmVlSXRlbURyYWdTdGFydEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGFuIGl0ZW0gaXMgYmVpbmcgZHJhZ2dlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLlxuICAgICAqL1xuICAgIG5vZGVEcmFnOiBFdmVudEVtaXR0ZXI8VHJlZUl0ZW1EcmFnRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIG9uIHRoZSB0YXJnZXQgVHJlZVZpZXcgd2hlbiBhIGRyYWdnZWQgaXRlbSBpcyBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICogVGhpcyBldmVudCBpcyBwcmV2ZW50YWJsZS4gSWYgeW91IHByZXZlbnQgdGhlIGV2ZW50IGRlZmF1bHQgKGBldmVudC5wcmV2ZW50RGVmdWFsdCgpYCkgb3IgaW52YWxpZGF0ZSBpdHMgc3RhdGUgKGBldmVudC5zZXRWYWxpZChmYWxzZSlgKSxcbiAgICAgKiB0aGUgYGFkZEl0ZW1gIGFuZCBgcmVtb3ZlSXRlbWAgZXZlbnRzIHdpbGwgbm90IGJlIHRyaWdnZXJlZC5cbiAgICAgKlxuICAgICAqIEJvdGggb3BlcmF0aW9ucyBjYW5jZWwgdGhlIGRlZmF1bHQgZHJvcCBvcGVyYXRpb24sIGJ1dCB0aGUgaW5kaWNhdGlvbiB0byB0aGUgdXNlciBpcyBkaWZmZXJlbnQuIGBldmVudC5zZXRWYWxpZChmYWxzZSlgIGluZGljYXRlcyB0aGF0IHRoZSBvcGVyYXRpb24gd2FzXG4gICAgICogdW5zdWNjZXNzZnVsIGJ5IGFuaW1hdGluZyB0aGUgZHJhZyBjbHVlIHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbi4gYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIHNpbXBseSByZW1vdmVzIHRoZSBjbHVlLCBhcyBpZiBpdCBoYXMgYmVlbiBkcm9wcGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKiBBcyBhIGdlbmVyYWwgcnVsZSwgdXNlIGBwcmV2ZW50RGVmYXVsdGAgdG8gbWFudWFsbHkgaGFuZGxlIHRoZSBhZGQgYW5kIHJlbW92ZSBvcGVyYXRpb25zLCBhbmQgYHNldFZhbGlkKGZhbHNlKWAgdG8gaW5kaWNhdGUgdGhlIG9wZXJhdGlvbiB3YXMgdW5zdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIG5vZGVEcm9wOiBFdmVudEVtaXR0ZXI8VHJlZUl0ZW1Ecm9wRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIG9uIHRoZSBzb3VyY2UgVHJlZVZpZXcgYWZ0ZXIgdGhlIGRyYWdnZWQgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICovXG4gICAgbm9kZURyYWdFbmQ6IEV2ZW50RW1pdHRlcjxUcmVlSXRlbURyYWdFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgYWZ0ZXIgYSBkcmFnZ2VkIGl0ZW0gaXMgZHJvcHBlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLlxuICAgICAqIENhbGxlZCBvbiB0aGUgVHJlZVZpZXcgd2hlcmUgdGhlIGl0ZW0gaXMgZHJvcHBlZC5cbiAgICAgKi9cbiAgICBhZGRJdGVtOiBFdmVudEVtaXR0ZXI8VHJlZUl0ZW1BZGRSZW1vdmVBcmdzPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBhZnRlciBhIGRyYWdnZWQgaXRlbSBpcyBkcm9wcGVkIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuXG4gICAgICogQ2FsbGVkIG9uIHRoZSBUcmVlVmlldyBmcm9tIHdoZXJlIHRoZSBpdGVtIGlzIGRyYWdnZWQuXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbTogRXZlbnRFbWl0dGVyPFRyZWVJdGVtQWRkUmVtb3ZlQXJncz47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgVHJlZVZpZXcgbm9kZSBjaGVja2JveFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hlY2tib3hlc190cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1jaGVja2VkLXN0YXRlKSkuXG4gICAgICovXG4gICAgY2hlY2tlZENoYW5nZTogRXZlbnRFbWl0dGVyPFRyZWVJdGVtTG9va3VwPjtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBUcmVlVmlldyBub2RlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fdHJlZXZpZXcgJX0jdG9jLW1vZGlmeWluZy10aGUtc2VsZWN0aW9uKSkuXG4gICAgICovXG4gICAgc2VsZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8VHJlZUl0ZW0+O1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgKi9cbiAgICBub2RlQ2xpY2s6IEV2ZW50RW1pdHRlcjxOb2RlQ2xpY2tFdmVudD47XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgKi9cbiAgICBub2RlRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxOb2RlQ2xpY2tFdmVudD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5vZGVUZW1wbGF0ZTogTm9kZVRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIFRoZSBub2RlcyB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBieSB0aGUgVHJlZVZpZXdcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX3RyZWV2aWV3ICV9KSkuXG4gICAgICovXG4gICAgbm9kZXM6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZHMgb2YgdGhlIGRhdGEgaXRlbSB0aGF0IHByb3ZpZGUgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZXNcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX3RyZWV2aWV3ICV9KSkuIElmIHRoZSBgdGV4dEZpZWxkYCBpbnB1dCBpcyBzZXRcbiAgICAgKiB0byBhbiBhcnJheSwgZWFjaCBoaWVyYXJjaGljYWwgbGV2ZWwgdXNlcyB0aGUgZmllbGQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc2FtZVxuICAgICAqIGluZGV4IGluIHRoZSBhcnJheSwgb3IgdGhlIGxhc3QgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgdGV4dEZpZWxkOiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYSBzcGVjaWZpYyBub2RlIGhhcyBjaGlsZCBub2Rlc1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZXZpZXcgJX0pKS5cbiAgICAgKi9cbiAgICBoYXNDaGlsZHJlbjogKGl0ZW06IG9iamVjdCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYSBzcGVjaWZpYyBub2RlIGlzIHNlbGVjdGVkXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjaGVja2JveGVzX3RyZWV2aWV3ICV9I3RvYy1tb2RpZnlpbmctdGhlLWNoZWNrZWQtc3RhdGUpKS5cbiAgICAgKi9cbiAgICBpc0NoZWNrZWQ6IChpdGVtOiBvYmplY3QsIGluZGV4OiBzdHJpbmcpID0+IENoZWNrZWRTdGF0ZTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYSBzcGVjaWZpYyBub2RlIGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGlzRGlzYWJsZWQ6IChpdGVtOiBvYmplY3QsIGluZGV4OiBzdHJpbmcpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBleHBhbmRlZC5cbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkOiAoaXRlbTogb2JqZWN0LCBpbmRleDogc3RyaW5nKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhIHNwZWNpZmljIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNlbGVjdGlvbl90cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1zZWxlY3Rpb24pKS5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiAoaXRlbTogb2JqZWN0LCBpbmRleDogc3RyaW5nKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgVHJlZVZpZXcga2V5Ym9hcmQgbmF2aWdhYmxlIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgbmF2aWdhYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gd2hpY2ggcHJvdmlkZXMgdGhlIGNoaWxkIG5vZGVzIGZvciBhIGdpdmVuIHBhcmVudCBub2RlXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVldmlldyAlfSkpLlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiAoaXRlbTogb2JqZWN0KSA9PiBPYnNlcnZhYmxlPG9iamVjdFtdPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZWRpdFNlcnZpY2U6IEVkaXRTZXJ2aWNlO1xuICAgIGNoZWNrYm94ZXM6IGJvb2xlYW47XG4gICAgZXhwYW5kSWNvbnM6IGJvb2xlYW47XG4gICAgdG91Y2hBY3Rpb25zOiBib29sZWFuO1xuICAgIGlzQWN0aXZlOiBib29sZWFuO1xuICAgIGRhdGE6IEJlaGF2aW9yU3ViamVjdDxhbnlbXT47XG4gICAgcHJpdmF0ZSBfYW5pbWF0ZTtcbiAgICBwcml2YXRlIF9pc0NoZWNrZWQ7XG4gICAgcHJpdmF0ZSBfaXNFeHBhbmRlZDtcbiAgICBwcml2YXRlIF9pc1NlbGVjdGVkO1xuICAgIHByaXZhdGUgX2hhc0NoaWxkcmVuO1xuICAgIHByaXZhdGUgc3Vic2NyaXB0aW9ucztcbiAgICBwcml2YXRlIGRvbVN1YnNjcmlwdGlvbnM7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIGV4cGFuZFNlcnZpY2U6IEV4cGFuZFN0YXRlU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2U6IE5hdmlnYXRpb25TZXJ2aWNlLCBub2RlQ2hpbGRyZW5TZXJ2aWNlOiBOb2RlQ2hpbGRyZW5TZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlLCB0cmVlVmlld0xvb2t1cFNlcnZpY2U6IFRyZWVWaWV3TG9va3VwU2VydmljZSwgbmdab25lOiBOZ1pvbmUsIHJlbmRlcmVyOiBSZW5kZXJlcjIsIGRhdGFDaGFuZ2VOb3RpZmljYXRpb246IERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlLCBsb2NhbGl6YXRpb246IExvY2FsaXphdGlvblNlcnZpY2UpO1xuICAgIG5nT25DaGFuZ2VzKF86IGFueSk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEJsdXJzIHRoZSBmb2N1c2VkIFRyZWVWaWV3IGl0ZW0uXG4gICAgICovXG4gICAgYmx1cigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGZpcnN0IGZvY3VzYWJsZSBpdGVtIGluIHRoZSBUcmVlVmlldyBjb21wb25lbnQgaWYgbm8gaGllcmFyY2hpY2FsIGluZGV4IGlzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqXG4gICAgICogIEBDb21wb25lbnQoe1xuICAgICAqICAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgIDxidXR0b24gKGNsaWNrKT1cInRyZWV2aWV3LmZvY3VzKCcxJylcIj5Gb2N1c2VzIHRoZSBzZWNvbmQgbm9kZTwvYnV0dG9uPlxuICAgICAqICAgICAgPGtlbmRvLXRyZWV2aWV3XG4gICAgICogICAgICAgICAgI3RyZWV2aWV3XG4gICAgICogICAgICAgICAgW25vZGVzXT1cImRhdGFcIlxuICAgICAqICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAqICAgICAgPlxuICAgICAqICAgICAgPC9rZW5kby10cmVldmlldz5cbiAgICAgKiAgYFxuICAgICAqICB9KVxuICAgICAqICBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtcbiAgICAgKiAgICAgICAgICB7IHRleHQ6IFwiRnVybml0dXJlXCIgfSxcbiAgICAgKiAgICAgICAgICB7IHRleHQ6IFwiRGVjb3JcIiB9XG4gICAgICogICAgICBdO1xuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoaW5kZXg/OiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgaW5kZXgsIHJldHVybnMgdGhlIFRyZWVJdGVtTG9va3VwIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gICAgICogQHJldHVybnMge1RyZWVJdGVtTG9va3VwfSAtIFRoZSBpdGVtIHRoYXQgd2FzIHNlYXJjaGVkIChsb29rZWQgdXApLlxuICAgICAqL1xuICAgIGl0ZW1Mb29rdXAoaW5kZXg6IHN0cmluZyk6IFRyZWVJdGVtTG9va3VwO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc0Rpc2FibGVkTm9kZShub2RlOiBhbnkpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBgZXhwYW5kYCBldmVudCBmb3IgdGhlIHByb3ZpZGVkIG5vZGUgYW5kIGRpc3BsYXlzIGl0J3MgbG9hZGluZyBpbmRpY2F0b3IuXG4gICAgICovXG4gICAgZXhwYW5kTm9kZShpdGVtOiBhbnksIGluZGV4OiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBgY29sbGFwc2VgIGV2ZW50IGZvciB0aGUgcHJvdmlkZWQgbm9kZS5cbiAgICAgKi9cbiAgICBjb2xsYXBzZU5vZGUoaXRlbTogYW55LCBpbmRleDogc3RyaW5nKTogdm9pZDtcbiAgICBwcml2YXRlIGF0dGFjaERvbUhhbmRsZXJzO1xuICAgIHByaXZhdGUgZm9jdXNIYW5kbGVyO1xuICAgIHByaXZhdGUgYmx1ckhhbmRsZXI7XG4gICAgcHJpdmF0ZSBjbGlja0hhbmRsZXI7XG4gICAgcHJpdmF0ZSBrZXlkb3duSGFuZGxlcjtcbn1cbiJdfQ==