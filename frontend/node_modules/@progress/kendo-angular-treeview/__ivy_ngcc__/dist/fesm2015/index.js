/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { EventEmitter, Injectable, Directive, TemplateRef, Optional, Component, ChangeDetectionStrategy, ElementRef, NgZone, Renderer2, HostBinding, ViewChild, ViewContainerRef, Input, Output, ContentChild, ChangeDetectorRef, NgModule, ComponentFactoryResolver } from '@angular/core';
import { isDocumentAvailable, Keys, hasObservers, isChanged, guid } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { Subject, of, BehaviorSubject, Subscription, EMPTY, merge } from 'rxjs';
import { trigger, transition, style, animate } from '@angular/animations';
import { getter, setter } from '@progress/kendo-common';
import { catchError, tap, filter, switchMap, take, map, delay, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import Draggable from '@telerik/kendo-draggable';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-l10n';
import * as ɵngcc2 from '@angular/common';

const _c0 = ["assetsContainer"];
const _c1 = ["kendoTreeViewGroup", ""];
function TreeViewGroupComponent_li_0_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 10);
    ɵngcc0.ɵɵlistener("click", function TreeViewGroupComponent_li_0_span_2_Template_span_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); const index_r3 = ctx_r10.index; const node_r2 = ctx_r10.$implicit; const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.expandNode(ctx_r9.nodeIndex(index_r3), node_r2, !ctx_r9.isExpanded(node_r2, ctx_r9.nodeIndex(index_r3))); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r12.$implicit;
    const index_r3 = ctx_r12.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("k-i-collapse", ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)))("k-i-expand", !ctx_r4.isExpanded(node_r2, ctx_r4.nodeIndex(index_r3)));
    ɵngcc0.ɵɵproperty("kendoTreeViewLoading", ctx_r4.nodeIndex(index_r3));
} }
function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "kendo-checkbox", 11);
    ɵngcc0.ɵɵlistener("checkStateChange", function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkStateChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r15); const index_r3 = ɵngcc0.ɵɵnextContext().index; const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.checkNode(ctx_r13.nodeIndex(index_r3)); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r16.$implicit;
    const index_r3 = ctx_r16.index;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("node", node_r2)("index", ctx_r5.nodeIndex(index_r3))("isChecked", ctx_r5.isChecked);
} }
function TreeViewGroupComponent_li_0_ng_container_6_ng_template_1_Template(rf, ctx) { }
const _c2 = function (a0, a1) { return { $implicit: a0, index: a1 }; };
function TreeViewGroupComponent_li_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, TreeViewGroupComponent_li_0_ng_container_6_ng_template_1_Template, 0, 0, "ng-template", 12);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r18 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r18.$implicit;
    const index_r3 = ctx_r18.index;
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r6.nodeTemplateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c2, node_r2, ctx_r6.nodeIndex(index_r3)));
} }
function TreeViewGroupComponent_li_0_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const node_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r7.nodeText(node_r2), " ");
} }
function TreeViewGroupComponent_li_0_ul_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ul", 13);
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext();
    const node_r2 = ctx_r20.$implicit;
    const index_r3 = ctx_r20.index;
    const ctx_r8 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("nodes", ctx_r8.fetchChildren)("checkboxes", ctx_r8.checkboxes)("expandIcons", ctx_r8.expandIcons)("touchActions", ctx_r8.touchActions)("children", ctx_r8.children)("hasChildren", ctx_r8.hasChildren)("isChecked", ctx_r8.isChecked)("isDisabled", ctx_r8.isDisabled)("disabled", ctx_r8.disabled || ctx_r8.isDisabled(node_r2, ctx_r8.nodeIndex(index_r3)))("isExpanded", ctx_r8.isExpanded)("isSelected", ctx_r8.isSelected)("nodeTemplateRef", ctx_r8.nodeTemplateRef)("parentIndex", ctx_r8.nodeIndex(index_r3))("parentDataItem", node_r2)("textField", ctx_r8.nextFields)("@toggle", true);
} }
function TreeViewGroupComponent_li_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 1);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, TreeViewGroupComponent_li_0_span_2_Template, 1, 5, "span", 3);
    ɵngcc0.ɵɵtemplate(3, TreeViewGroupComponent_li_0_kendo_checkbox_3_Template, 1, 3, "kendo-checkbox", 4);
    ɵngcc0.ɵɵelementStart(4, "span", 5);
    ɵngcc0.ɵɵelementContainerStart(5, 6);
    ɵngcc0.ɵɵtemplate(6, TreeViewGroupComponent_li_0_ng_container_6_Template, 2, 5, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(7, TreeViewGroupComponent_li_0_ng_container_7_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, TreeViewGroupComponent_li_0_ul_8_Template, 1, 16, "ul", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const node_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("dataItem", node_r2)("index", ctx_r1.nodeIndex(index_r3))("parentDataItem", ctx_r1.parentDataItem)("parentIndex", ctx_r1.parentIndex)("isChecked", ctx_r1.isChecked(node_r2, ctx_r1.nodeIndex(index_r3)))("isDisabled", ctx_r1.disabled || ctx_r1.isDisabled(node_r2, ctx_r1.nodeIndex(index_r3)))("isExpanded", ctx_r1.isExpanded(node_r2, ctx_r1.nodeIndex(index_r3)))("isSelected", ctx_r1.isSelected(node_r2, ctx_r1.nodeIndex(index_r3)));
    ɵngcc0.ɵɵattribute("data-treeindex", ctx_r1.nodeIndex(index_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.expandIcons && ctx_r1.hasChildren(node_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.checkboxes);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("touch-action", ctx_r1.touchActions ? "" : "none");
    ɵngcc0.ɵɵproperty("dataItem", node_r2)("index", ctx_r1.nodeIndex(index_r3))("initialSelection", ctx_r1.isSelected(node_r2, ctx_r1.nodeIndex(index_r3)))("isSelected", ctx_r1.isSelected);
    ɵngcc0.ɵɵattribute("data-treeindex", ctx_r1.nodeIndex(index_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r1.hasTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.isExpanded(node_r2, ctx_r1.nodeIndex(index_r3)) && ctx_r1.hasChildren(node_r2));
} }
function DragClueComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "span");
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r21 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("k-icon ", ctx_r21.statusIconClass, " k-drag-status");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r21.text);
} }
function DragClueComponent_1_ng_template_0_Template(rf, ctx) { }
const _c3 = function (a0, a1, a2, a3) { return { text: a0, action: a1, sourceItem: a2, destinationItem: a3 }; };
function DragClueComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DragClueComponent_1_ng_template_0_Template, 0, 0, "ng-template", 1);
} if (rf & 2) {
    const ctx_r22 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r22.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction4(2, _c3, ctx_r22.text, ctx_r22.action, ctx_r22.sourceItem, ctx_r22.destinationItem));
} }
function DropHintComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 2);
} }
function DropHintComponent_1_ng_template_0_ng_template_0_Template(rf, ctx) { }
function DropHintComponent_1_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template");
} }
function DropHintComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DropHintComponent_1_ng_template_0_Template, 1, 0, "ng-template", 3);
} if (rf & 2) {
    const ctx_r25 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r25.template);
} }
class DataChangeNotificationService {
    constructor() {
        this.changes = new EventEmitter();
    }
    notify() {
        this.changes.emit();
    }
}
DataChangeNotificationService.ɵfac = function DataChangeNotificationService_Factory(t) { return new (t || DataChangeNotificationService)(); };
DataChangeNotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DataChangeNotificationService, factory: DataChangeNotificationService.ɵfac });


/**
 * @hidden
 */
const hasChildren = () => false;
/**
 * @hidden
 */
const isChecked = () => 'none';
/**
 * @hidden
 */
const isDisabled = () => false;
/**
 * @hidden
 */
const isExpanded = () => true;
/**
 * @hidden
 */
const isSelected = () => false;

/**
 * @hidden
 */
class ExpandStateService {
    constructor() {
        this.changes = new Subject();
    }
    expand(index, dataItem) {
        this.changes.next({ dataItem, index, expand: true });
    }
    collapse(index, dataItem) {
        this.changes.next({ dataItem, index, expand: false });
    }
}
ExpandStateService.ɵfac = function ExpandStateService_Factory(t) { return new (t || ExpandStateService)(); };
ExpandStateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ExpandStateService, factory: ExpandStateService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandStateService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class IndexBuilderService {
    constructor() {
        this.INDEX_SEPARATOR = '_';
    }
    nodeIndex(index = '', parentIndex = '') {
        return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ''}${index}`;
    }
    indexForLevel(index, level) {
        return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);
    }
    lastLevelIndex(index = '') {
        const parts = index.split(this.INDEX_SEPARATOR);
        if (!parts.length) {
            return NaN;
        }
        return parseInt(parts[parts.length - 1], 10);
    }
    level(index) {
        return index.split(this.INDEX_SEPARATOR).length;
    }
}
IndexBuilderService.ɵfac = function IndexBuilderService_Factory(t) { return new (t || IndexBuilderService)(); };
IndexBuilderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IndexBuilderService, factory: IndexBuilderService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IndexBuilderService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @hidden
 */
class LoadingNotificationService {
    constructor() {
        this.changes = new Subject();
    }
    notifyLoaded(index) {
        this.changes.next(index);
    }
}
LoadingNotificationService.ɵfac = function LoadingNotificationService_Factory(t) { return new (t || LoadingNotificationService)(); };
LoadingNotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LoadingNotificationService, factory: LoadingNotificationService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadingNotificationService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
const match = (element, selector) => {
    const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (!matcher) {
        return false;
    }
    return matcher.call(element, selector);
};
/**
 * @hidden
 */
const closestWithMatch = (element, selector) => {
    if (!document.documentElement.contains(element)) {
        return null;
    }
    let parent = element;
    while (parent !== null && parent.nodeType === 1) {
        if (match(parent, selector)) {
            return parent;
        }
        parent = parent.parentElement || parent.parentNode;
    }
    return null;
};
/**
 * @hidden
 */
const noop = () => { };
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 */
const isNullOrEmptyString = (value) => isBlank(value) || value.trim().length === 0;
/**
 * @hidden
 */
const closestNode = (element) => {
    const selector = 'li.k-treeview-item';
    if (!isDocumentAvailable()) {
        return null;
    }
    if (element.closest) {
        return element.closest(selector);
    }
    else {
        return closestWithMatch(element, selector);
    }
};
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};
/**
 * @hidden
 */
const isContent = (element) => {
    const scopeSelector = '.k-in,.k-treeview-item,.k-treeview';
    if (!isDocumentAvailable()) {
        return null;
    }
    let node = element;
    while (node && !match(node, scopeSelector)) {
        node = node.parentNode;
    }
    if (node) {
        return match(node, '.k-in');
    }
};
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const hasParent = (element, container) => {
    return Boolean(closest(element, (node) => node === container));
};
/**
 * @hidden
 */
const focusableNode = (element) => element.nativeElement.querySelector('li[tabindex="0"]');
/**
 * @hidden
 */
const nodeId = (node) => node ? node.getAttribute('data-treeindex') : '';
/**
 * @hidden
 */
const nodeIndex = (item) => (item || {}).index;
/**
 * @hidden
 */
const dataItemsEqual = (first, second) => {
    if (!isPresent(first) && !isPresent(second)) {
        return true;
    }
    return isPresent(first) && isPresent(second) && first.item.dataItem === second.item.dataItem;
};

const last = (list) => list[list.length - 1];
const safe = node => (node || {});
const safeChildren = node => (safe(node).children || []);
const findLast = node => {
    let lastNode = node;
    let children = [].concat(safeChildren(node));
    while (children.length) {
        children = children.concat(safeChildren(last(children)));
        lastNode = children.shift();
    }
    return lastNode;
};
/**
 * @hidden
 */
class NavigationModel {
    constructor() {
        this.ib = new IndexBuilderService();
        this.nodes = [];
    }
    firstNode() {
        return this.nodes[0] || null;
    }
    lastNode() {
        const node = this.nodes[this.nodes.length - 1];
        if (!node) {
            return null;
        }
        return findLast(last(this.container(node))) || node;
    }
    closestNode(index) {
        const { prev } = safe(this.findNode(index));
        const sibling = prev || this.firstNode();
        return safe(sibling).index === index ? this.sibling(sibling, 1) : sibling;
    }
    findNode(index) {
        return this.find(index, this.nodes);
    }
    findParent(index) {
        const parentLevel = this.ib.level(index) - 1;
        return this.findNode(this.ib.indexForLevel(index, parentLevel));
    }
    findChild(index) {
        return safeChildren(this.findNode(index))[0] || null;
    }
    findPrev(item) {
        const index = item.index;
        const parent = this.findParent(index);
        const levelIndex = this.ib.lastLevelIndex(index);
        if (levelIndex === 0) {
            return parent;
        }
        const currentNode = this.findNode(index);
        let prev = this.sibling(currentNode, -1);
        if (prev) {
            let children = this.container(prev);
            while (children.length > 0) {
                prev = last(children);
                children = this.container(prev);
            }
        }
        return prev;
    }
    findNext(item) {
        const children = this.container(item);
        if (children.length === 0) {
            return this.sibling(item, 1);
        }
        return children[0];
    }
    registerItem(id, index, disabled) {
        const children = [];
        const level = this.ib.level(index);
        const parent = this.findParent(index);
        if (parent || level === 1) {
            const node = { id, children, index, parent, disabled };
            this.insert(node, parent);
        }
    }
    unregisterItem(id, index) {
        const node = this.find(index, this.nodes);
        if (!node || node.id !== id) {
            return;
        }
        const children = this.container(node.parent);
        children.splice(children.indexOf(node), 1);
    }
    childLevel(nodes) {
        const children = nodes.filter(node => isPresent(node));
        if (!children || !children.length) {
            return 1;
        }
        return this.ib.level(children[0].index);
    }
    container(node) {
        return node ? node.children : this.nodes;
    }
    find(index, nodes) {
        const childLevel = this.childLevel(nodes);
        const indexToMatch = this.ib.indexForLevel(index, childLevel);
        const isLeaf = childLevel === this.ib.level(index);
        const node = nodes.find(n => n && n.index === indexToMatch);
        if (!node) {
            return null;
        }
        return isLeaf ? node : this.find(index, node.children);
    }
    insert(node, parent) {
        const nodes = this.container(parent);
        nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
    }
    sibling(node, offset) {
        if (!node) {
            return null;
        }
        const parent = this.findParent(node.index);
        const container = this.container(parent);
        return container[container.indexOf(node) + offset] || this.sibling(parent, offset) || null;
    }
}

/**
 * @hidden
 */
class NavigationService {
    constructor(localization) {
        this.localization = localization;
        this.expands = new Subject();
        this.moves = new Subject();
        this.checks = new Subject();
        this.selects = new Subject();
        this.navigable = true;
        this.actions = {
            [Keys.ArrowUp]: () => this.activate(this.model.findPrev(this.focusableItem)),
            [Keys.ArrowDown]: () => this.activate(this.model.findNext(this.focusableItem)),
            [Keys.ArrowLeft]: () => (this.expand({
                expand: this.localization.rtl,
                intercept: this.localization.rtl ? this.moveToChild : this.moveToParent
            })),
            [Keys.ArrowRight]: () => (this.expand({
                expand: !this.localization.rtl,
                intercept: this.localization.rtl ? this.moveToParent : this.moveToChild
            })),
            [Keys.Home]: () => this.activate(this.model.firstNode()),
            [Keys.End]: () => this.activate(this.model.lastNode()),
            [Keys.Enter]: () => this.navigable && this.selectIndex(nodeIndex(this.activeItem)),
            [Keys.Space]: () => this.navigable && this.checkIndex(nodeIndex(this.activeItem))
        };
        this.isFocused = false;
        this._model = new NavigationModel();
        this.moveToChild = this.moveToChild.bind(this);
        this.moveToParent = this.moveToParent.bind(this);
    }
    get model() {
        return this._model;
    }
    set model(model) {
        this._model = model;
    }
    get activeIndex() {
        return nodeIndex(this.activeItem) || null;
    }
    get focusableItem() {
        return this.activeItem || this.model.firstNode();
    }
    get isActiveExpanded() {
        return this.activeItem && this.activeItem.children.length > 0;
    }
    activate(item) {
        if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
            return;
        }
        this.isFocused = true;
        this.activeItem = item || this.activeItem;
        this.notifyMove();
    }
    activateParent(index) {
        this.activate(this.model.findParent(index));
    }
    activateIndex(index) {
        if (!index) {
            return;
        }
        this.activate(this.model.findNode(index));
    }
    activateClosest(index) {
        if (!index || nodeIndex(this.focusableItem) !== index) {
            return;
        }
        this.activeItem = this.model.closestNode(index);
        this.notifyMove();
    }
    activateFocusable() {
        if (this.activeItem) {
            return;
        }
        this.activeItem = this.model.firstNode();
        this.notifyMove();
    }
    deactivate() {
        if (!this.navigable || !this.isFocused) {
            return;
        }
        this.isFocused = false;
        this.notifyMove();
    }
    checkIndex(index) {
        if (!this.isDisabled(index)) {
            this.checks.next(index);
        }
    }
    selectIndex(index) {
        if (!this.isDisabled(index)) {
            this.selects.next(index);
        }
    }
    isActive(index) {
        if (!index) {
            return false;
        }
        return this.isFocused && this.activeIndex === index;
    }
    isFocusable(index) {
        return nodeIndex(this.focusableItem) === index;
    }
    isDisabled(index) {
        return this.model.findNode(index).disabled;
    }
    registerItem(id, index, disabled) {
        this.model.registerItem(id, index, disabled);
    }
    unregisterItem(id, index) {
        if (this.isActive(index)) {
            this.activateParent(index);
        }
        this.model.unregisterItem(id, index);
    }
    move(e) {
        if (!this.navigable) {
            return;
        }
        const moveAction = this.actions[e.keyCode];
        if (!moveAction) {
            return;
        }
        moveAction();
        e.preventDefault();
    }
    expand({ expand, intercept }) {
        const index = nodeIndex(this.activeItem);
        if (!index || intercept(index)) {
            return;
        }
        this.notifyExpand(expand);
    }
    moveToParent() {
        if (this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findParent(nodeIndex(this.activeItem)));
        return true;
    }
    moveToChild() {
        if (!this.isActiveExpanded) {
            return false;
        }
        this.activate(this.model.findChild(nodeIndex(this.activeItem)));
        return true;
    }
    notifyExpand(expand) {
        this.expands.next(this.navigationState(expand));
    }
    notifyMove() {
        this.moves.next(this.navigationState());
    }
    navigationState(expand = false) {
        return ({ expand, index: nodeIndex(this.activeItem), isFocused: this.isFocused });
    }
}
NavigationService.ɵfac = function NavigationService_Factory(t) { return new (t || NavigationService)(ɵngcc0.ɵɵinject(ɵngcc1.LocalizationService)); };
NavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NavigationService, factory: NavigationService.ɵfac });
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: LocalizationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.LocalizationService }]; }, null); })();

/**
 * @hidden
 */
class NodeChildrenService {
    constructor() {
        this.changes = new Subject();
    }
    childrenLoaded(item, children) {
        this.changes.next({ item, children });
    }
}
NodeChildrenService.ɵfac = function NodeChildrenService_Factory(t) { return new (t || NodeChildrenService)(); };
NodeChildrenService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NodeChildrenService, factory: NodeChildrenService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NodeChildrenService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Represents the template for the TreeView nodes ([more information and example]({% slug nodetemplate_treeview %})).
 * The template helps to customize the content of the nodes. To define the node template, nest an `<ng-template>`
 * tag with the `kendoTreeViewNodeTemplate` directive inside a `<kendo-treeview>` tag.
 *
 *
 * The node data item and its hierarchical index are available as context variables:
 *
 * - `let-dataItem` (`any`) - available as implicit context variable
 * - `let-index="index"` (`string`)
 *
 *
 * @example
 * ```ts
 *
 *  import { Component } from '@angular/core';
 *  @Component({
 *      selector: 'my-app',
 *      template: `
 *      <kendo-treeview
 *          [nodes]="data"
 *          kendoTreeViewExpandable
 *
 *          kendoTreeViewHierarchyBinding
 *          childrenField="items">
 *        <ng-template kendoTreeViewNodeTemplate let-dataItem let-index="index">
 *          <span [style.fontWeight]="dataItem.items ? 'bolder': 'normal' ">{{ index }}: {{ dataItem.text }}</span>
 *        </ng-template>
 *      </kendo-treeview>
 *    `
 *  })
 *  export class AppComponent {
 *      public data: any[] = [
 *          {
 *              text: "Inbox",
 *              items: [{ text: "Read Mail" }]
 *          },
 *          {
 *              text: "Drafts"
 *          },
 *          {
 *              text: "Search Folders",
 *              items: [
 *                  { text: "Categorized Mail" },
 *                  { text: "Large Mail" },
 *                  { text: "Unread Mail"}
 *              ]
 *          },
 *          { text: "Settings" }
 *      ];
 *  }
 *
 * ```
 */
class NodeTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NodeTemplateDirective.ɵfac = function NodeTemplateDirective_Factory(t) { return new (t || NodeTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
NodeTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NodeTemplateDirective, selectors: [["", "kendoTreeViewNodeTemplate", ""]] });
/** @nocollapse */
NodeTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NodeTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewNodeTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @hidden
 */
class SelectionService {
    constructor() {
        this.changes = new Subject();
    }
    isFirstSelected(index) {
        return this.firstIndex === index;
    }
    setFirstSelected(index, selected) {
        if (this.firstIndex === index && selected === false) {
            this.firstIndex = null;
        }
        else if (!this.firstIndex && selected) {
            this.firstIndex = index;
        }
    }
    select(index, dataItem) {
        this.changes.next({ dataItem, index });
    }
}
SelectionService.ɵfac = function SelectionService_Factory(t) { return new (t || SelectionService)(); };
SelectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SelectionService, factory: SelectionService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectionService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const INDEX_REGEX = /\d+$/;
/**
 * @hidden
 */
class TreeViewLookupService {
    constructor() {
        this.map = new Map();
    }
    registerItem(item, parent) {
        const currentLookup = {
            children: [],
            item,
            parent: this.item(nodeIndex(parent))
        };
        this.map.set(item.index, currentLookup);
    }
    registerChildren(index, children) {
        const item = this.item(index);
        if (!item) {
            return;
        }
        item.children = children;
    }
    unregisterItem(index, dataItem) {
        const current = this.item(index);
        if (current && current.item.dataItem === dataItem) {
            this.map.delete(index);
            if (current.parent && current.parent.children) {
                current.parent.children = current.parent.children.filter(item => item.dataItem !== dataItem);
            }
        }
    }
    replaceItem(index, item, parent) {
        if (!item) {
            return;
        }
        this.unregisterItem(index, item.dataItem);
        this.registerItem(item, parent);
        this.addToParent(item, parent);
    }
    itemLookup(index) {
        const item = this.item(index);
        if (!item) {
            return null;
        }
        return {
            children: this.mapChildren(item.children),
            item: item.item,
            parent: item.parent
        };
    }
    hasItem(index) {
        return this.map.has(index);
    }
    item(index) {
        return this.map.get(index) || null;
    }
    addToParent(item, parent) {
        if (parent) {
            const parentItem = this.item(parent.index);
            const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);
            parentItem.children = parentItem.children || [];
            parentItem.children.splice(index, 0, item);
        }
    }
    mapChildren(children = []) {
        return children.map(c => {
            const { item, parent, children } = this.item(c.index);
            return {
                children: this.mapChildren(children),
                item,
                parent
            };
        });
    }
}
TreeViewLookupService.ɵfac = function TreeViewLookupService_Factory(t) { return new (t || TreeViewLookupService)(); };
TreeViewLookupService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TreeViewLookupService, factory: TreeViewLookupService.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeViewLookupService, [{
        type: Injectable
    }], function () { return []; }, null); })();

const providers = [
    ExpandStateService,
    IndexBuilderService,
    TreeViewLookupService,
    LoadingNotificationService,
    NodeChildrenService,
    NavigationService,
    SelectionService,
    DataChangeNotificationService,
    LocalizationService,
    {
        provide: L10N_PREFIX,
        useValue: 'kendo.treeview'
    }
];
/* tslint:disable:member-ordering */
/**
 * Represents the [Kendo UI TreeView component for Angular]({% slug overview_treeview %}).
 *
 * @example
 * {% meta height:350 %}
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 *  _@Component({
 *      selector: 'my-app',
 *      template: `
 *      <kendo-treeview
 *          [nodes]="data"
 *          textField="text"
 *          kendoTreeViewCheckable
 *          kendoTreeViewExpandable
 *          kendoTreeViewSelectable
 *
 *          kendoTreeViewHierarchyBinding
 *          childrenField="items">
 *      </kendo-treeview>
 *  `
 *  })
 *  export class AppComponent {
 *      public data: any[] = [
 *          {
 *              text: "Furniture", items: [
 *                  { text: "Tables & Chairs" },
 *                  { text: "Sofas" },
 *                  { text: "Occasional Furniture" }
 *              ]
 *          },
 *          {
 *              text: "Decor", items: [
 *                  { text: "Bed Linen" },
 *                  { text: "Curtains & Blinds" },
 *                  { text: "Carpets" }
 *              ]
 *          }
 *      ];
 *  }
 * ```
 * {% endmeta %}
 */
class TreeViewComponent {
    constructor(element, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {
        this.element = element;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.selectionService = selectionService;
        this.treeViewLookupService = treeViewLookupService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.dataChangeNotification = dataChangeNotification;
        this.localization = localization;
        this.classNames = true;
        this.role = 'tree';
        /** @hidden */
        this.fetchNodes = () => this.data;
        /**
         * Fires when the children of the expanded node are loaded.
         */
        this.childrenLoaded = new EventEmitter();
        /**
         * Fires when the user blurs the component.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires when the user focuses the component.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires when the user expands a TreeView node.
         */
        this.expand = new EventEmitter();
        /**
         * Fires when the user collapses a TreeView node.
         */
        this.collapse = new EventEmitter();
        /**
         * Fires just before the dragging of the node starts ([see example]({% slug draganddrop_treeview %}#toc-setup)). This event is preventable.
         * If you prevent the event default, no drag hint will be created and the subsequent drag-related events will not be fired.
         */
        this.nodeDragStart = new EventEmitter();
        /**
         * Fires when an item is being dragged ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDrag = new EventEmitter();
        /**
         * Fires on the target TreeView when a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * This event is preventable. If you prevent the event default (`event.preventDefualt()`) or invalidate its state (`event.setValid(false)`),
         * the `addItem` and `removeItem` events will not be triggered.
         *
         * Both operations cancel the default drop operation, but the indication to the user is different. `event.setValid(false)` indicates that the operation was
         * unsuccessful by animating the drag clue to its original position. `event.preventDefault()` simply removes the clue, as if it has been dropped successfully.
         * As a general rule, use `preventDefault` to manually handle the add and remove operations, and `setValid(false)` to indicate the operation was unsuccessful.
         */
        this.nodeDrop = new EventEmitter();
        /**
         * Fires on the source TreeView after the dragged item has been dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         */
        this.nodeDragEnd = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView where the item is dropped.
         */
        this.addItem = new EventEmitter();
        /**
         * Fires after a dragged item is dropped ([see example]({% slug draganddrop_treeview %}#toc-setup)).
         * Called on the TreeView from where the item is dragged.
         */
        this.removeItem = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node checkbox
         * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
         */
        this.checkedChange = new EventEmitter();
        /**
         * Fires when the user selects a TreeView node
         * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
         */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when the user clicks a TreeView node.
         */
        this.nodeClick = new EventEmitter();
        /**
         * Fires when the user double clicks a TreeView node.
         */
        this.nodeDblClick = new EventEmitter();
        /**
         * A function which determines if a specific node is disabled.
         */
        this.isDisabled = isDisabled;
        /**
         * Determines whether the TreeView keyboard navigable is enabled.
         */
        this.navigable = true;
        /**
         * A function which provides the child nodes for a given parent node
         * ([see example]({% slug databinding_treeview %})).
         */
        this.children = () => of([]);
        this.checkboxes = false;
        this.expandIcons = false;
        this.touchActions = true;
        this.isActive = false;
        this.data = new BehaviorSubject([]);
        this._animate = true;
        this.subscriptions = new Subscription();
        this.domSubscriptions = [];
    }
    /** @hidden */
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Determines whether the content animation is enabled.
     */
    set animate(value) {
        this._animate = value;
    }
    get animate() {
        return !this._animate;
    }
    /**
     * The nodes which will be displayed by the TreeView
     * ([see example]({% slug databinding_treeview %})).
     */
    set nodes(value) {
        this.dataChangeNotification.notify();
        this.data.next(value);
    }
    get nodes() {
        return this.data.value;
    }
    /**
     * A function which determines if a specific node has child nodes
     * ([see example]({% slug databinding_treeview %})).
     */
    get hasChildren() {
        return this._hasChildren || hasChildren;
    }
    set hasChildren(callback) {
        this._hasChildren = callback;
        this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
    }
    /**
     * A function which determines if a specific node is selected
     * ([see example]({% slug checkboxes_treeview %}#toc-modifying-the-checked-state)).
     */
    get isChecked() {
        return this._isChecked || isChecked;
    }
    set isChecked(callback) {
        this._isChecked = callback;
        this.checkboxes = Boolean(this._isChecked);
    }
    /**
     * A function which determines if a specific node is expanded.
     */
    get isExpanded() {
        return this._isExpanded || isExpanded;
    }
    set isExpanded(callback) {
        this._isExpanded = callback;
        this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
    }
    /**
     * A function which determines if a specific node is selected
     * ([see example]({% slug selection_treeview %}#toc-modifying-the-selection)).
     */
    get isSelected() {
        return this._isSelected || isSelected;
    }
    set isSelected(callback) {
        this._isSelected = callback;
    }
    ngOnChanges(_) {
        this.navigationService.navigable = Boolean(this.navigable);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.domSubscriptions.forEach(subscription => subscription());
    }
    ngOnInit() {
        this.subscriptions.add(this.nodeChildrenService
            .changes
            .subscribe((x) => this.childrenLoaded.emit(x)));
        this.subscriptions.add(this.expandService.changes
            .subscribe(({ index, dataItem, expand }) => expand
            ? this.expand.emit({ index, dataItem })
            : this.collapse.emit({ index, dataItem })));
        this.subscriptions.add(this.navigationService.checks
            .subscribe((x) => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));
        this.subscriptions.add(this.selectionService.changes
            .subscribe((x) => {
            if (hasObservers(this.selectionChange)) {
                this.ngZone.run(() => {
                    this.selectionChange.emit(x);
                });
            }
        }));
        if (this.element) {
            this.ngZone.runOutsideAngular(() => {
                this.attachDomHandlers();
            });
        }
    }
    /**
     * Blurs the focused TreeView item.
     */
    blur() {
        if (!isDocumentAvailable()) {
            return;
        }
        const target = focusableNode(this.element);
        if (document.activeElement === target) {
            target.blur();
        }
    }
    /**
     * Focuses the first focusable item in the TreeView component if no hierarchical index is provided.
     *
     * @example
     * ```ts
     * import { Component } from '@angular/core';
     *
     *  @Component({
     *      selector: 'my-app',
     *      template: `
     *      <button (click)="treeview.focus('1')">Focuses the second node</button>
     *      <kendo-treeview
     *          #treeview
     *          [nodes]="data"
     *          textField="text"
     *      >
     *      </kendo-treeview>
     *  `
     *  })
     *  export class AppComponent {
     *      public data: any[] = [
     *          { text: "Furniture" },
     *          { text: "Decor" }
     *      ];
     *  }
     * ```
     */
    focus(index) {
        this.navigationService.activateIndex(index);
        const target = focusableNode(this.element);
        if (target) {
            target.focus();
        }
    }
    /**
     * Based on the specified index, returns the TreeItemLookup node.
     *
     * @param index - The index of the node.
     * @returns {TreeItemLookup} - The item that was searched (looked up).
     */
    itemLookup(index) {
        return this.treeViewLookupService.itemLookup(index);
    }
    /**
     * @hidden
     */
    isDisabledNode(node) {
        return this.navigationService.isDisabled(node.item.index);
    }
    /**
     * Triggers the `expand` event for the provided node and displays it's loading indicator.
     */
    expandNode(item, index) {
        this.expandService.expand(index, item);
    }
    /**
     * Triggers the `collapse` event for the provided node.
     */
    collapseNode(item, index) {
        this.expandService.collapse(index, item);
    }
    attachDomHandlers() {
        const element = this.element.nativeElement;
        this.clickHandler = this.clickHandler.bind(this);
        this.domSubscriptions.push(this.renderer.listen(element, 'contextmenu', this.clickHandler), this.renderer.listen(element, 'click', this.clickHandler), this.renderer.listen(element, 'dblclick', this.clickHandler), this.renderer.listen(element, 'focusin', this.focusHandler.bind(this)), this.renderer.listen(element, 'focusout', this.blurHandler.bind(this)), this.renderer.listen(element, 'keydown', this.keydownHandler.bind(this)));
    }
    focusHandler(e) {
        let focusItem;
        if (match(e.target, '.k-treeview-item')) {
            focusItem = e.target;
        }
        else if (!isFocusable(e.target)) { // with compliments to IE
            focusItem = closestNode(e.target);
        }
        if (focusItem) {
            this.navigationService.activateIndex(nodeId(e.target));
            if (!this.isActive && hasObservers(this.onFocus)) {
                this.ngZone.run(() => {
                    this.onFocus.emit();
                });
            }
            this.isActive = true;
        }
    }
    blurHandler(e) {
        if (this.isActive && match(e.target, '.k-treeview-item') &&
            (!e.relatedTarget || !match(e.relatedTarget, '.k-treeview-item') || !hasParent(e.relatedTarget, this.element.nativeElement))) {
            this.navigationService.deactivate();
            this.isActive = false;
            if (hasObservers(this.onBlur)) {
                this.ngZone.run(() => {
                    this.onBlur.emit();
                });
            }
        }
    }
    clickHandler(e) {
        const target = e.target;
        if ((e.type === 'contextmenu' && !hasObservers(this.nodeClick)) ||
            (e.type === 'click' && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange)) ||
            (e.type === 'dblclick' && !hasObservers(this.nodeDblClick)) || isFocusable(target) ||
            !isContent(target) || !hasParent(target, this.element.nativeElement)) {
            return;
        }
        const index = nodeId(closestNode(target));
        // the disabled check is probably not needed due to the k-state-disabled styles
        if (!index || this.navigationService.isDisabled(index)) {
            return;
        }
        this.ngZone.run(() => {
            const lookup = this.treeViewLookupService.itemLookup(index);
            if (e.type === 'click') {
                this.navigationService.selectIndex(index);
            }
            const emitter = e.type === 'dblclick' ? this.nodeDblClick : this.nodeClick;
            emitter.emit({
                item: lookup.item,
                originalEvent: e,
                type: e.type
            });
        });
    }
    keydownHandler(e) {
        if (this.isActive && this.navigable) {
            this.ngZone.run(() => {
                this.navigationService.move(e);
            });
        }
    }
}
TreeViewComponent.ɵfac = function TreeViewComponent_Factory(t) { return new (t || TreeViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(NodeChildrenService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DataChangeNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocalizationService)); };
TreeViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeViewComponent, selectors: [["kendo-treeview"]], contentQueries: function TreeViewComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NodeTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
    } }, viewQuery: function TreeViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);
    } }, hostVars: 7, hostBindings: function TreeViewComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("dir", ctx.direction);
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@.disabled", ctx.animate);
        ɵngcc0.ɵɵclassProp("k-widget", ctx.classNames)("k-treeview", ctx.classNames);
    } }, inputs: { isDisabled: "isDisabled", navigable: "navigable", children: "children", animate: "animate", nodes: "nodes", hasChildren: "hasChildren", isChecked: "isChecked", isExpanded: "isExpanded", isSelected: "isSelected", textField: "textField" }, outputs: { childrenLoaded: "childrenLoaded", onBlur: "blur", onFocus: "focus", expand: "expand", collapse: "collapse", nodeDragStart: "nodeDragStart", nodeDrag: "nodeDrag", nodeDrop: "nodeDrop", nodeDragEnd: "nodeDragEnd", addItem: "addItem", removeItem: "removeItem", checkedChange: "checkedChange", selectionChange: "selectionChange", nodeClick: "nodeClick", nodeDblClick: "nodeDblClick" }, exportAs: ["kendoTreeView"], features: [ɵngcc0.ɵɵProvidersFeature(providers), ɵngcc0.ɵɵNgOnChangesFeature], decls: 3, vars: 12, consts: [["kendoTreeViewGroup", "", "role", "group", 1, "k-treeview-lines", 3, "checkboxes", "expandIcons", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "isExpanded", "isSelected", "nodeTemplateRef", "textField", "nodes"], ["assetsContainer", ""]], template: function TreeViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "ul", 0);
        ɵngcc0.ɵɵelementContainer(1, null, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("checkboxes", ctx.checkboxes)("expandIcons", ctx.expandIcons)("touchActions", ctx.touchActions)("children", ctx.children)("hasChildren", ctx.hasChildren)("isChecked", ctx.isChecked)("isDisabled", ctx.isDisabled)("isExpanded", ctx.isExpanded)("isSelected", ctx.isSelected)("nodeTemplateRef", ctx.nodeTemplate == null ? null : ctx.nodeTemplate.templateRef)("textField", ctx.textField)("nodes", ctx.fetchNodes);
    } }, directives: function () { return [TreeViewGroupComponent]; }, encapsulation: 2 });
/** @nocollapse */
TreeViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ExpandStateService },
    { type: NavigationService },
    { type: NodeChildrenService },
    { type: SelectionService },
    { type: TreeViewLookupService },
    { type: NgZone },
    { type: Renderer2 },
    { type: DataChangeNotificationService },
    { type: LocalizationService }
];
TreeViewComponent.propDecorators = {
    classNames: [{ type: HostBinding, args: ["class.k-widget",] }, { type: HostBinding, args: ["class.k-treeview",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    direction: [{ type: HostBinding, args: ["attr.dir",] }],
    assetsContainer: [{ type: ViewChild, args: ['assetsContainer', { read: ViewContainerRef, static: true },] }],
    animate: [{ type: Input }, { type: HostBinding, args: ['@.disabled',] }],
    childrenLoaded: [{ type: Output }],
    onBlur: [{ type: Output, args: ['blur',] }],
    onFocus: [{ type: Output, args: ['focus',] }],
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    nodeDragStart: [{ type: Output }],
    nodeDrag: [{ type: Output }],
    nodeDrop: [{ type: Output }],
    nodeDragEnd: [{ type: Output }],
    addItem: [{ type: Output }],
    removeItem: [{ type: Output }],
    checkedChange: [{ type: Output }],
    selectionChange: [{ type: Output }],
    nodeClick: [{ type: Output }],
    nodeDblClick: [{ type: Output }],
    nodeTemplate: [{ type: ContentChild, args: [NodeTemplateDirective,] }],
    nodes: [{ type: Input }],
    textField: [{ type: Input }],
    hasChildren: [{ type: Input }],
    isChecked: [{ type: Input }],
    isDisabled: [{ type: Input }],
    isExpanded: [{ type: Input }],
    isSelected: [{ type: Input }],
    navigable: [{ type: Input }],
    children: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeViewComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.Default,
                exportAs: 'kendoTreeView',
                providers: providers,
                selector: 'kendo-treeview',
                template: `
        <ul class="k-treeview-lines"
            kendoTreeViewGroup
            role="group"
            [checkboxes]="checkboxes"
            [expandIcons]="expandIcons"
            [touchActions]="touchActions"
            [children]="children"
            [hasChildren]="hasChildren"
            [isChecked]="isChecked"
            [isDisabled]="isDisabled"
            [isExpanded]="isExpanded"
            [isSelected]="isSelected"
            [nodeTemplateRef]="nodeTemplate?.templateRef"
            [textField]="textField"
            [nodes]="fetchNodes"
        >
        </ul>
        <ng-container #assetsContainer></ng-container>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ExpandStateService }, { type: NavigationService }, { type: NodeChildrenService }, { type: SelectionService }, { type: TreeViewLookupService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: DataChangeNotificationService }, { type: ɵngcc1.LocalizationService }]; }, { classNames: [{
            type: HostBinding,
            args: ["class.k-widget"]
        }, {
            type: HostBinding,
            args: ["class.k-treeview"]
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], childrenLoaded: [{
            type: Output
        }], onBlur: [{
            type: Output,
            args: ['blur']
        }], onFocus: [{
            type: Output,
            args: ['focus']
        }], expand: [{
            type: Output
        }], collapse: [{
            type: Output
        }], nodeDragStart: [{
            type: Output
        }], nodeDrag: [{
            type: Output
        }], nodeDrop: [{
            type: Output
        }], nodeDragEnd: [{
            type: Output
        }], addItem: [{
            type: Output
        }], removeItem: [{
            type: Output
        }], checkedChange: [{
            type: Output
        }], selectionChange: [{
            type: Output
        }], nodeClick: [{
            type: Output
        }], nodeDblClick: [{
            type: Output
        }], isDisabled: [{
            type: Input
        }], navigable: [{
            type: Input
        }], children: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ["attr.dir"]
        }], animate: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['@.disabled']
        }], nodes: [{
            type: Input
        }], hasChildren: [{
            type: Input
        }], isChecked: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], assetsContainer: [{
            type: ViewChild,
            args: ['assetsContainer', { read: ViewContainerRef, static: true }]
        }], nodeTemplate: [{
            type: ContentChild,
            args: [NodeTemplateDirective]
        }], textField: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class TreeViewGroupComponent {
    constructor(expandService, loadingService, indexBuilder, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.indexBuilder = indexBuilder;
        this.treeViewLookupService = treeViewLookupService;
        this.navigationService = navigationService;
        this.nodeChildrenService = nodeChildrenService;
        this.dataChangeNotification = dataChangeNotification;
        this.kGroupClass = true;
        this.touchActions = true;
        this.textField = "";
        this._data = [];
        this.isChecked = () => 'none';
        this.isDisabled = () => false;
        this.isExpanded = () => false;
        this.isSelected = () => false;
        this.children = () => of([]);
        this.hasChildren = () => false;
    }
    get role() { return 'group'; }
    get data() {
        return this._data;
    }
    set data(data) {
        this._data = data;
        const mappedChildren = this.mapToTreeItem(data);
        this.setNodeChildren(mappedChildren);
        this.emitChildrenLoaded(mappedChildren);
    }
    get hasTemplate() {
        return isPresent(this.nodeTemplateRef);
    }
    expandNode(index, dataItem, expand) {
        if (expand) {
            this.expandService.expand(index, dataItem);
        }
        else {
            this.expandService.collapse(index, dataItem);
        }
    }
    checkNode(index) {
        this.navigationService.checkIndex(index);
        this.navigationService.activateIndex(index);
    }
    nodeIndex(index) {
        return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);
    }
    nodeText(dataItem) {
        const textField = isArray(this.textField) ? this.textField[0] : this.textField;
        return getter(textField)(dataItem);
    }
    ngOnDestroy() {
        if (this.nodesSubscription) {
            this.nodesSubscription.unsubscribe();
        }
        if (this.dataChangeSubscription) {
            this.dataChangeSubscription.unsubscribe();
        }
    }
    ngOnInit() {
        this.subscribeToNodesChange();
        this.dataChangeSubscription = this.dataChangeNotification
            .changes
            .subscribe(this.subscribeToNodesChange.bind(this));
    }
    ngOnChanges(changes) {
        if (changes.parentIndex) {
            this.setNodeChildren(this.mapToTreeItem(this.data));
        }
    }
    fetchChildren(node, index) {
        return this.children(node)
            .pipe(catchError(() => {
            this.loadingService.notifyLoaded(index);
            return EMPTY;
        }), tap(() => this.loadingService.notifyLoaded(index)));
    }
    get nextFields() {
        if (isArray(this.textField)) {
            return this.textField.length > 1 ? this.textField.slice(1) : this.textField;
        }
        return [this.textField];
    }
    setNodeChildren(children) {
        this.treeViewLookupService.registerChildren(this.parentIndex, children);
    }
    mapToTreeItem(data) {
        if (!this.parentIndex) {
            return [];
        }
        return data.map((dataItem, idx) => ({ dataItem, index: this.nodeIndex(idx) }));
    }
    emitChildrenLoaded(children) {
        if (!this.parentIndex) {
            return;
        }
        this.nodeChildrenService.childrenLoaded({ dataItem: this.parentDataItem, index: this.parentIndex }, children);
    }
    subscribeToNodesChange() {
        if (this.nodesSubscription) {
            this.nodesSubscription.unsubscribe();
        }
        this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex).subscribe(x => { this.data = x; });
    }
}
TreeViewGroupComponent.ɵfac = function TreeViewGroupComponent_Factory(t) { return new (t || TreeViewGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(LoadingNotificationService), ɵngcc0.ɵɵdirectiveInject(IndexBuilderService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(NodeChildrenService), ɵngcc0.ɵɵdirectiveInject(DataChangeNotificationService)); };
TreeViewGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeViewGroupComponent, selectors: [["", "kendoTreeViewGroup", ""]], hostVars: 3, hostBindings: function TreeViewGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("k-group", ctx.kGroupClass);
    } }, inputs: { touchActions: "touchActions", textField: "textField", isChecked: "isChecked", isDisabled: "isDisabled", isExpanded: "isExpanded", isSelected: "isSelected", children: "children", hasChildren: "hasChildren", checkboxes: "checkboxes", expandIcons: "expandIcons", disabled: "disabled", nodes: "nodes", parentDataItem: "parentDataItem", parentIndex: "parentIndex", nodeTemplateRef: "nodeTemplateRef" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c1, decls: 1, vars: 1, consts: [["class", "k-item k-treeview-item", "kendoTreeViewItem", "", 3, "dataItem", "index", "parentDataItem", "parentIndex", "isChecked", "isDisabled", "isExpanded", "isSelected", 4, "ngFor", "ngForOf"], ["kendoTreeViewItem", "", 1, "k-item", "k-treeview-item", 3, "dataItem", "index", "parentDataItem", "parentIndex", "isChecked", "isDisabled", "isExpanded", "isSelected"], [1, "k-mid"], ["class", "k-icon", 3, "k-i-collapse", "k-i-expand", "kendoTreeViewLoading", "click", 4, "ngIf"], ["tabindex", "-1", 3, "node", "index", "isChecked", "checkStateChange", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-in", 3, "dataItem", "index", "initialSelection", "isSelected"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["kendoTreeViewGroup", "", "role", "group", 3, "nodes", "checkboxes", "expandIcons", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "disabled", "isExpanded", "isSelected", "nodeTemplateRef", "parentIndex", "parentDataItem", "textField", 4, "ngIf"], [1, "k-icon", 3, "kendoTreeViewLoading", "click"], ["tabindex", "-1", 3, "node", "index", "isChecked", "checkStateChange"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoTreeViewGroup", "", "role", "group", 3, "nodes", "checkboxes", "expandIcons", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "disabled", "isExpanded", "isSelected", "nodeTemplateRef", "parentIndex", "parentDataItem", "textField"]], template: function TreeViewGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeViewGroupComponent_li_0_Template, 9, 21, "li", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data);
    } }, directives: function () { return [ɵngcc2.NgForOf, TreeViewItemDirective, ɵngcc2.NgIf, TreeViewItemContentDirective, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault, LoadingIndicatorDirective,
        CheckBoxComponent, ɵngcc2.NgTemplateOutlet, TreeViewGroupComponent]; }, encapsulation: 2, data: { animation: [
            trigger('toggle', [
                transition('void => *', [
                    style({ height: 0 }),
                    animate('0.1s ease-in', style({ height: "*" }))
                ]),
                transition('* => void', [
                    style({ height: "*" }),
                    animate('0.1s ease-in', style({ height: 0 }))
                ])
            ])
        ] } });
/** @nocollapse */
TreeViewGroupComponent.ctorParameters = () => [
    { type: ExpandStateService },
    { type: LoadingNotificationService },
    { type: IndexBuilderService },
    { type: TreeViewLookupService },
    { type: NavigationService },
    { type: NodeChildrenService },
    { type: DataChangeNotificationService }
];
TreeViewGroupComponent.propDecorators = {
    kGroupClass: [{ type: HostBinding, args: ["class.k-group",] }],
    role: [{ type: HostBinding, args: ["attr.role",] }],
    checkboxes: [{ type: Input }],
    expandIcons: [{ type: Input }],
    disabled: [{ type: Input }],
    touchActions: [{ type: Input }],
    nodes: [{ type: Input }],
    textField: [{ type: Input }],
    parentDataItem: [{ type: Input }],
    parentIndex: [{ type: Input }],
    nodeTemplateRef: [{ type: Input }],
    isChecked: [{ type: Input }],
    isDisabled: [{ type: Input }],
    isExpanded: [{ type: Input }],
    isSelected: [{ type: Input }],
    children: [{ type: Input }],
    hasChildren: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeViewGroupComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('toggle', [
                        transition('void => *', [
                            style({ height: 0 }),
                            animate('0.1s ease-in', style({ height: "*" }))
                        ]),
                        transition('* => void', [
                            style({ height: "*" }),
                            animate('0.1s ease-in', style({ height: 0 }))
                        ])
                    ])
                ],
                selector: '[kendoTreeViewGroup]',
                template: `
        <li
            *ngFor="let node of data; let index = index" class="k-item k-treeview-item"
            kendoTreeViewItem
            [dataItem]="node"
            [index]="nodeIndex(index)"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [isChecked]="isChecked(node, nodeIndex(index))"
            [isDisabled]="disabled || isDisabled(node, nodeIndex(index))"
            [isExpanded]="isExpanded(node, nodeIndex(index))"
            [isSelected]="isSelected(node, nodeIndex(index))"
            [attr.data-treeindex]="nodeIndex(index)"
        >
            <div class="k-mid">
                <span
                    class="k-icon"
                    [class.k-i-collapse]="isExpanded(node, nodeIndex(index))"
                    [class.k-i-expand]="!isExpanded(node, nodeIndex(index))"
                    [kendoTreeViewLoading]="nodeIndex(index)"
                    (click)="expandNode(nodeIndex(index), node, !isExpanded(node, nodeIndex(index)))"
                    *ngIf="expandIcons && hasChildren(node)"
                    >
                </span>
                <kendo-checkbox
                    *ngIf="checkboxes"
                    [node]="node"
                    [index]="nodeIndex(index)"
                    [isChecked]="isChecked"
                    (checkStateChange)="checkNode(nodeIndex(index))"
                    tabindex="-1"
                ></kendo-checkbox>
                <span kendoTreeViewItemContent
                    [attr.data-treeindex]="nodeIndex(index)"
                    [dataItem]="node"
                    [index]="nodeIndex(index)"
                    [initialSelection]="isSelected(node, nodeIndex(index))"
                    [isSelected]="isSelected"
                    class="k-in"
                    [style.touch-action]="touchActions ? '' : 'none'"
                >
                    <ng-container [ngSwitch]="hasTemplate">
                        <ng-container *ngSwitchCase="true">
                            <ng-template
                                [ngTemplateOutlet]="nodeTemplateRef" [ngTemplateOutletContext]="{$implicit: node, index: nodeIndex(index)}"
                                >
                            </ng-template>
                        </ng-container>
                        <ng-container *ngSwitchDefault>
                            {{nodeText(node)}}
                        </ng-container>
                    </ng-container>
                </span>
            </div>
            <ul
                *ngIf="isExpanded(node, nodeIndex(index)) && hasChildren(node)"
                kendoTreeViewGroup
                role="group"
                [nodes]="fetchChildren"
                [checkboxes]="checkboxes"
                [expandIcons]="expandIcons"
                [touchActions]="touchActions"
                [children]="children"
                [hasChildren]="hasChildren"
                [isChecked]="isChecked"
                [isDisabled]="isDisabled"
                [disabled]="disabled || isDisabled(node, nodeIndex(index))"
                [isExpanded]="isExpanded"
                [isSelected]="isSelected"
                [nodeTemplateRef]="nodeTemplateRef"
                [parentIndex]="nodeIndex(index)"
                [parentDataItem]="node"
                [textField]="nextFields"
                [@toggle]="true"
                >
            </ul>
        </li>
    `
            }]
    }], function () { return [{ type: ExpandStateService }, { type: LoadingNotificationService }, { type: IndexBuilderService }, { type: TreeViewLookupService }, { type: NavigationService }, { type: NodeChildrenService }, { type: DataChangeNotificationService }]; }, { kGroupClass: [{
            type: HostBinding,
            args: ["class.k-group"]
        }], touchActions: [{
            type: Input
        }], textField: [{
            type: Input
        }], isChecked: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], children: [{
            type: Input
        }], hasChildren: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ["attr.role"]
        }], checkboxes: [{
            type: Input
        }], expandIcons: [{
            type: Input
        }], disabled: [{
            type: Input
        }], nodes: [{
            type: Input
        }], parentDataItem: [{
            type: Input
        }], parentIndex: [{
            type: Input
        }], nodeTemplateRef: [{
            type: Input
        }] }); })();

const indexChecked = (keys, index) => keys.filter(k => k === index).length > 0;
const matchKey = index => k => {
    if (index === k) {
        return true;
    }
    if (!k.split) {
        return false;
    }
    return k.split('_').reduce(({ key, result }, part) => {
        key += part;
        if (index === key || result) {
            return { result: true };
        }
        key += "_";
        return { key, result: false };
    }, { key: "", result: false }).result;
};
/**
 * A directive which manages the in-memory checked state of the TreeView node
 * ([see example]({% slug checkboxes_treeview %})).
 */
class CheckDirective {
    constructor(treeView, zone) {
        this.treeView = treeView;
        this.zone = zone;
        /**
         * Fires when the `checkedKeys` collection was updated.
         */
        this.checkedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.checkActions = {
            'multiple': (e) => this.checkMultiple(e),
            'single': (e) => this.checkSingle(e)
        };
        this._checkedKeys = [];
        this.subscriptions.add(this.treeView.checkedChange
            .subscribe((e) => this.check(e)));
        this.subscriptions.add(this.treeView.childrenLoaded
            .pipe(filter(() => this.options.checkChildren), switchMap(e => this.zone.onStable.pipe(take(1), map(() => e))))
            .subscribe((e) => this.addChildrenKeys(e)));
        this.treeView.isChecked = this.isItemChecked.bind(this);
    }
    /**
     * @hidden
     */
    set isChecked(value) {
        this.treeView.isChecked = value;
    }
    /**
     * Defines the collection that will store the checked keys
     * ([see example]({% slug checkboxes_treeview %})).
     */
    get checkedKeys() {
        return this._checkedKeys;
    }
    set checkedKeys(keys) {
        this._checkedKeys = keys;
    }
    get options() {
        const defaultOptions = {
            checkChildren: true,
            checkParents: true,
            enabled: true,
            mode: "multiple"
        };
        if (!isPresent(this.checkable) || typeof this.checkable === 'string') {
            return defaultOptions;
        }
        const isBoolean = typeof this.checkable === 'boolean';
        const checkSettings = isBoolean
            ? { enabled: this.checkable }
            : this.checkable;
        return Object.assign(defaultOptions, checkSettings);
    }
    ngOnChanges(changes) {
        if (changes.checkable) {
            this.treeView.checkboxes = this.options.enabled;
            this.toggleCheckOnClick();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.unsubscribeClick();
    }
    isItemChecked(dataItem, index) {
        if (!this.checkKey) {
            return this.isIndexChecked(index);
        }
        const keyIndex = this.checkedKeys.indexOf(this.itemKey({ dataItem, index }));
        return keyIndex > -1 ? 'checked' : 'none';
    }
    isIndexChecked(index) {
        const checkedKeys = this.checkedKeys.filter(matchKey(index));
        if (indexChecked(checkedKeys, index)) {
            return 'checked';
        }
        const { mode, checkParents } = this.options;
        if (mode === 'multiple' && checkParents && checkedKeys.length) {
            return 'indeterminate';
        }
        return 'none';
    }
    itemKey(e) {
        if (!this.checkKey) {
            return e.index;
        }
        if (typeof this.checkKey === "string") {
            return e.dataItem[this.checkKey];
        }
        if (typeof this.checkKey === "function") {
            return this.checkKey(e);
        }
    }
    check(e) {
        const { enabled, mode } = this.options;
        const performSelection = this.checkActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    }
    checkSingle(node) {
        const key = this.itemKey(node.item);
        this.checkedKeys = this.checkedKeys[0] !== key ? [key] : [];
        this.notify();
    }
    checkMultiple(node) {
        this.checkNode(node);
        if (this.options.checkParents) {
            this.checkParents(node.parent);
        }
        this.notify();
    }
    toggleCheckOnClick() {
        this.unsubscribeClick();
        if (this.options.checkOnClick) {
            this.clickSubscription = this.treeView.nodeClick.subscribe(args => {
                if (args.type === 'click') {
                    const lookup = this.treeView.itemLookup(args.item.index);
                    this.check(lookup);
                }
            });
        }
    }
    unsubscribeClick() {
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
            this.clickSubscription = null;
        }
    }
    checkNode(node, check) {
        const key = this.itemKey(node.item);
        const idx = this.checkedKeys.indexOf(key);
        const isChecked = idx > -1;
        const shouldCheck = check === undefined ? !isChecked : check;
        if (!isPresent(key) || (isChecked && check) || this.treeView.isDisabledNode(node)) {
            return;
        }
        if (isChecked) {
            this.checkedKeys.splice(idx, 1);
        }
        else {
            this.checkedKeys.push(key);
        }
        if (this.options.checkChildren) {
            node.children.map(n => this.checkNode(n, shouldCheck));
        }
    }
    checkParents(parent) {
        let currentParent = parent;
        while (currentParent) {
            const parentKey = this.itemKey(currentParent.item);
            const parentIndex = this.checkedKeys.indexOf(parentKey);
            if (this.allChildrenSelected(currentParent.children)) {
                if (parentIndex === -1) {
                    this.checkedKeys.push(parentKey);
                }
            }
            else if (parentIndex > -1) {
                this.checkedKeys.splice(parentIndex, 1);
            }
            currentParent = currentParent.parent;
        }
    }
    allChildrenSelected(children) {
        const isCheckedReducer = (acc, item) => (acc && this.isItemChecked(item.dataItem, item.index) === 'checked');
        return children.reduce(isCheckedReducer, true);
    }
    notify() {
        this.checkedKeysChange.emit(this.checkedKeys.slice());
    }
    addChildrenKeys(args) {
        if (this.checkedKeys.indexOf(this.itemKey(args.item)) === -1) {
            return;
        }
        const keys = args.children.reduce((acc, item) => {
            const itemKey = this.itemKey(item);
            const existingKey = this.checkedKeys.find(key => itemKey === key);
            if (!existingKey) {
                acc.push(itemKey);
            }
            return acc;
        }, []);
        if (keys.length) {
            this.checkedKeys = this.checkedKeys.concat(keys);
            this.zone.run(() => {
                this.notify();
            });
        }
    }
}
CheckDirective.ɵfac = function CheckDirective_Factory(t) { return new (t || CheckDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CheckDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CheckDirective, selectors: [["", "kendoTreeViewCheckable", ""]], inputs: { isChecked: "isChecked", checkedKeys: "checkedKeys", checkKey: ["checkBy", "checkKey"], checkable: ["kendoTreeViewCheckable", "checkable"] }, outputs: { checkedKeysChange: "checkedKeysChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
CheckDirective.ctorParameters = () => [
    { type: TreeViewComponent },
    { type: NgZone }
];
CheckDirective.propDecorators = {
    isChecked: [{ type: Input }],
    checkKey: [{ type: Input, args: ["checkBy",] }],
    checkedKeys: [{ type: Input }],
    checkable: [{ type: Input, args: ['kendoTreeViewCheckable',] }],
    checkedKeysChange: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewCheckable]' }]
    }], function () { return [{ type: TreeViewComponent }, { type: ɵngcc0.NgZone }]; }, { checkedKeysChange: [{
            type: Output
        }], isChecked: [{
            type: Input
        }], checkedKeys: [{
            type: Input
        }], checkKey: [{
            type: Input,
            args: ["checkBy"]
        }], checkable: [{
            type: Input,
            args: ['kendoTreeViewCheckable']
        }] }); })();

/**
 * A directive which manages the disabled in-memory state of the TreeView node
 * ([see example]({% slug disabledstate_treeview %})).
 */
class DisableDirective {
    constructor(treeView, cdr) {
        this.treeView = treeView;
        this.cdr = cdr;
        /**
         * Defines the collection that will store the disabled keys.
         */
        this.disabledKeys = [];
        this.treeView.isDisabled = (dataItem, index) => (this.disabledKeys.indexOf(this.itemKey({ dataItem, index })) > -1);
    }
    /**
     * @hidden
     */
    set isDisabled(value) {
        this.treeView.isDisabled = value;
    }
    ngOnChanges(changes = {}) {
        const { disabledKeys } = changes;
        if (disabledKeys && !disabledKeys.firstChange) {
            this.cdr.markForCheck();
        }
    }
    itemKey(e) {
        if (!this.disableKey) {
            return e.index;
        }
        if (typeof this.disableKey === "string") {
            return e.dataItem[this.disableKey];
        }
        if (typeof this.disableKey === "function") {
            return this.disableKey(e);
        }
    }
}
DisableDirective.ɵfac = function DisableDirective_Factory(t) { return new (t || DisableDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DisableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DisableDirective, selectors: [["", "kendoTreeViewDisable", ""]], inputs: { disabledKeys: "disabledKeys", isDisabled: "isDisabled", disableKey: ["kendoTreeViewDisable", "disableKey"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
DisableDirective.ctorParameters = () => [
    { type: TreeViewComponent },
    { type: ChangeDetectorRef }
];
DisableDirective.propDecorators = {
    isDisabled: [{ type: Input }],
    disableKey: [{ type: Input, args: ["kendoTreeViewDisable",] }],
    disabledKeys: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisableDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewDisable]' }]
    }], function () { return [{ type: TreeViewComponent }, { type: ɵngcc0.ChangeDetectorRef }]; }, { disabledKeys: [{
            type: Input
        }], isDisabled: [{
            type: Input
        }], disableKey: [{
            type: Input,
            args: ["kendoTreeViewDisable"]
        }] }); })();

/**
 * A directive which manages the expanded state of the TreeView
 * ([see example]({% slug expandedstate_treeview %})).
 */
class ExpandDirective {
    constructor(treeView) {
        this.treeView = treeView;
        /**
         * Fires when the `expandedKeys` collection was updated.
         */
        this.expandedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this._expandedKeys = [];
        this.subscriptions.add(merge(this.treeView.expand.pipe(map(e => (Object.assign({ expand: true }, e)))), this.treeView.collapse.pipe(map(e => (Object.assign({ expand: false }, e))))).subscribe(this.toggleExpand.bind(this)));
        this.treeView.isExpanded = (dataItem, index) => this.expandedKeys.indexOf(this.itemKey({ dataItem, index })) > -1;
    }
    /**
     * @hidden
     */
    set isExpanded(value) {
        this.treeView.isExpanded = value;
    }
    /**
     * Defines the collection that will store the expanded keys.
     */
    get expandedKeys() {
        return this._expandedKeys;
    }
    set expandedKeys(keys) {
        this._expandedKeys = keys;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    itemKey(e) {
        if (this.expandKey) {
            if (typeof this.expandKey === "string") {
                return e.dataItem[this.expandKey];
            }
            if (typeof this.expandKey === "function") {
                return this.expandKey(e);
            }
        }
        return e.index;
    }
    toggleExpand({ index, dataItem, expand }) {
        const item = this.itemKey({ index, dataItem });
        const idx = this.expandedKeys.indexOf(item);
        let notify = false;
        if (idx > -1 && !expand) {
            this.expandedKeys.splice(idx, 1);
            notify = true;
        }
        else if (idx === -1 && expand) {
            this.expandedKeys.push(item);
            notify = true;
        }
        if (notify) {
            this.expandedKeysChange.emit(this.expandedKeys);
        }
    }
}
ExpandDirective.ɵfac = function ExpandDirective_Factory(t) { return new (t || ExpandDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
ExpandDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ExpandDirective, selectors: [["", "kendoTreeViewExpandable", ""]], inputs: { isExpanded: "isExpanded", expandedKeys: "expandedKeys", expandKey: ["expandBy", "expandKey"] }, outputs: { expandedKeysChange: "expandedKeysChange" } });
/** @nocollapse */
ExpandDirective.ctorParameters = () => [
    { type: TreeViewComponent }
];
ExpandDirective.propDecorators = {
    isExpanded: [{ type: Input }],
    expandKey: [{ type: Input, args: ["expandBy",] }],
    expandedKeysChange: [{ type: Output }],
    expandedKeys: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ExpandDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewExpandable]' }]
    }], function () { return [{ type: TreeViewComponent }]; }, { expandedKeysChange: [{
            type: Output
        }], isExpanded: [{
            type: Input
        }], expandedKeys: [{
            type: Input
        }], expandKey: [{
            type: Input,
            args: ["expandBy"]
        }] }); })();

/**
 * A directive which manages the in-memory selection state of the TreeView node
 * ([see example]({% slug selection_treeview %})).
 */
class SelectDirective {
    constructor(treeView) {
        this.treeView = treeView;
        /**
         * Fires when the `selectedKeys` collection was updated.
         */
        this.selectedKeysChange = new EventEmitter();
        this.subscriptions = new Subscription();
        this.selectActions = {
            'multiple': (e) => this.selectMultiple(e),
            'single': (e) => this.selectSingle(e)
        };
        this._selectedKeys = [];
        this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));
        this.treeView.isSelected = (dataItem, index) => (this.selectedKeys.indexOf(this.itemKey({ dataItem, index })) > -1);
    }
    /**
     * @hidden
     */
    set isSelected(value) {
        this.treeView.isSelected = value;
    }
    /**
     * Defines the collection that will store the selected keys
     * ([see example]({% slug selection_treeview %}#toc-selection-modes)).
     */
    get selectedKeys() {
        return this._selectedKeys;
    }
    set selectedKeys(keys) {
        this._selectedKeys = keys;
    }
    get getAriaMultiselectable() {
        return this.options.mode === 'multiple';
    }
    get options() {
        const defaultOptions = {
            enabled: true,
            mode: 'single'
        };
        if (!isPresent(this.selection) || typeof this.selection === 'string') {
            return defaultOptions;
        }
        const isBoolean = typeof this.selection === 'boolean';
        const selectionSettings = isBoolean ? { enabled: this.selection } : this.selection;
        return Object.assign(defaultOptions, selectionSettings);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    itemKey(e) {
        if (!this.selectKey) {
            return e.index;
        }
        if (typeof this.selectKey === 'string') {
            return e.dataItem[this.selectKey];
        }
        if (typeof this.selectKey === 'function') {
            return this.selectKey(e);
        }
    }
    select(e) {
        const { enabled, mode } = this.options;
        const performSelection = this.selectActions[mode] || noop;
        if (!enabled) {
            return;
        }
        performSelection(e);
    }
    selectSingle(node) {
        const key = this.itemKey(node);
        if (this.selectedKeys[0] === key) {
            return;
        }
        this.selectedKeys = [key];
        this.notify();
    }
    selectMultiple(node) {
        const key = this.itemKey(node);
        const idx = this.selectedKeys.indexOf(key);
        const isSelected = idx > -1;
        if (!isPresent(key)) {
            return;
        }
        if (isSelected) {
            this.selectedKeys.splice(idx, 1);
        }
        else {
            this.selectedKeys.push(key);
        }
        this.notify();
    }
    notify() {
        this.selectedKeysChange.emit(this.selectedKeys.slice());
    }
}
SelectDirective.ɵfac = function SelectDirective_Factory(t) { return new (t || SelectDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
SelectDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SelectDirective, selectors: [["", "kendoTreeViewSelectable", ""]], hostVars: 1, hostBindings: function SelectDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-multiselectable", ctx.getAriaMultiselectable);
    } }, inputs: { isSelected: "isSelected", selectedKeys: "selectedKeys", selectKey: ["selectBy", "selectKey"], selection: ["kendoTreeViewSelectable", "selection"] }, outputs: { selectedKeysChange: "selectedKeysChange" } });
/** @nocollapse */
SelectDirective.ctorParameters = () => [
    { type: TreeViewComponent }
];
SelectDirective.propDecorators = {
    isSelected: [{ type: Input }],
    selectKey: [{ type: Input, args: ['selectBy',] }],
    selection: [{ type: Input, args: ['kendoTreeViewSelectable',] }],
    selectedKeys: [{ type: Input }],
    selectedKeysChange: [{ type: Output }],
    getAriaMultiselectable: [{ type: HostBinding, args: ['attr.aria-multiselectable',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SelectDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewSelectable]' }]
    }], function () { return [{ type: TreeViewComponent }]; }, { selectedKeysChange: [{
            type: Output
        }], isSelected: [{
            type: Input
        }], selectedKeys: [{
            type: Input
        }], getAriaMultiselectable: [{
            type: HostBinding,
            args: ['attr.aria-multiselectable']
        }], selectKey: [{
            type: Input,
            args: ['selectBy']
        }], selection: [{
            type: Input,
            args: ['kendoTreeViewSelectable']
        }] }); })();

/**
 * Describes the attempted drop action during dragging.
 * Passed as `action` value to the [`kendoTreeViewDragClueTemplate`]({% slug api_treeview_dragcluetemplatedirective %}) directive.
 * By default, this value defines the rendered icon in the drag clue.
 */
var DropAction;
(function (DropAction) {
    DropAction[DropAction["Add"] = 0] = "Add";
    DropAction[DropAction["InsertTop"] = 1] = "InsertTop";
    DropAction[DropAction["InsertBottom"] = 2] = "InsertBottom";
    DropAction[DropAction["InsertMiddle"] = 3] = "InsertMiddle";
    DropAction[DropAction["Invalid"] = 4] = "Invalid";
})(DropAction || (DropAction = {}));

/**
 * Describes where the dragged item is dropped relative to the drop target item.
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["Over"] = 0] = "Over";
    DropPosition[DropPosition["Before"] = 1] = "Before";
    DropPosition[DropPosition["After"] = 2] = "After";
})(DropPosition || (DropPosition = {}));

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the TreeView [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop) event.
 */
class TreeItemDropEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(initializer, originalEvent) {
        super();
        /**
         * @hidden
         */
        this.isValid = true;
        Object.assign(this, initializer);
        this.originalEvent = originalEvent;
    }
    /**
     * Specifies if the drop action should be marked as valid.
     * If set to `false`, the [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
     * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events will not be fired and the drag clue
     * will be animated back to the source item to indicate the action is marked as invalid.
     */
    setValid(isValid) {
        this.isValid = isValid;
    }
}

/**
 * Arguments for the TreeView [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart) event.
 */
class TreeItemDragStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(initializer) {
        super();
        Object.assign(this, initializer);
    }
}

/**
 * Arguments for the TreeView [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag) and
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend) events.
 */
class TreeItemDragEvent {
}

/**
 * Checks if the browser supports relative stacking context.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 */
const hasRelativeStackingContext = () => {
    if (!isDocumentAvailable()) {
        return false;
    }
    const top = 10;
    const parent = document.createElement("div");
    parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
    parent.innerHTML = `<div style="position: fixed; top: ${top}px;">child</div>`;
    document.body.appendChild(parent);
    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
const HAS_RELATIVE_STACKING_CONTEXT = hasRelativeStackingContext();
/**
 * @hidden
 *
 * Gets the offset of the parent element if the latter has the `transform` CSS prop applied.
 * Transformed parents create new stacking context and the `fixed` children must be position based on the transformed parent.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
 *
 * If no parent container is `transform`-ed the function will return `{ left: 0, top: 0 }`;
 */
const getContainerOffset = (element) => {
    if (!(element && HAS_RELATIVE_STACKING_CONTEXT)) {
        return { left: 0, top: 0 };
    }
    let offsetParent = element.parentElement;
    while (offsetParent) {
        if (window.getComputedStyle(offsetParent).transform !== 'none') {
            break;
        }
        offsetParent = offsetParent.parentElement;
    }
    if (offsetParent) {
        const rect = offsetParent.getBoundingClientRect();
        return {
            left: rect.left - offsetParent.scrollLeft,
            top: rect.top - offsetParent.scrollTop
        };
    }
    return { left: 0, top: 0 };
};
/**
 * @hidden
 */
const getDropAction = (dropPosition, dropTarget) => {
    if (!(isPresent(dropPosition) && isPresent(dropTarget))) {
        return DropAction.Invalid;
    }
    switch (dropPosition) {
        case DropPosition.Over:
            return DropAction.Add;
        case DropPosition.Before:
            return isPresent(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
        case DropPosition.After:
            return isPresent(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
        default:
            return DropAction.Invalid;
    }
};
/**
 * @hidden
 */
const getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {
    if (!(isPresent(draggedItem) && isPresent(target) && isPresent(targetTreeView) && isPresent(containerOffset))) {
        return;
    }
    // the .k-mid element starts just after the checkbox/expand arrow and stretches till the end of the treeview on the right
    const item = closestWithMatch(target, '.k-mid');
    if (!isPresent(item)) {
        return;
    }
    // the .k-in element holds just the treeview item text (the actual content)
    const content = item.querySelector('.k-in');
    const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
    if (!isPresent(content) || (content === draggedItem) || targetChildOfDraggedItem) {
        return;
    }
    const itemViewPortCoords = content.getBoundingClientRect();
    /*
        if the user is hovering a treeview item, split the item height into four parts:
            - dropping into the top quarter should insert the dragged item before the drop target
            - dropping into the bottom quarter should insert the dragged item after the drop target
            - dropping into the second or third quarter should add the item as child node of the drop target

        if the user is NOT hovering a treeview item (he's dragging somewhere in the right), split the item height to just parts:
            - dropping should insert before or after
    */
    const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
    // clear any possible container offset created by parent elements with `transform` css property set
    const pointerPosition = clientY - containerOffset.top;
    const itemTop = itemViewPortCoords.top - containerOffset.top;
    if (pointerPosition < itemTop + itemDivisionHeight) {
        return DropPosition.Before;
    }
    if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
        return DropPosition.After;
    }
    return DropPosition.Over;
};
/**
 * @hidden
 */
const treeItemFromEventTarget = (treeView, dropTarget) => {
    if (!(isPresent(treeView) && isPresent(dropTarget))) {
        return;
    }
    const node = closestNode(dropTarget);
    const index = nodeId(node);
    return treeView.itemLookup(index);
};
/**
 * @hidden
 *
 * Emits `collapse` on the specified TreeView node if the latter is left empty after its last child node was dragged out.
 */
const collapseEmptyParent = (parent, parentNodes, treeview) => {
    if (isPresent(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
        treeview.collapseNode(parent.item.dataItem, parent.item.index);
    }
};
/**
 * @hidden
 *
 * Expands the node if it's dropped into and it's not yet expanded.
 */
const expandDropTarget = (dropTarget, treeView) => {
    if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
        treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
    }
};
/**
 * @hidden
 *
 * Extracts the event target from the viewport coords. Required for touch devices
 * where the `event.target` of a `pointermove` event is always the initially dragged item.
 */
const getDropTarget = (event) => {
    if (!(isDocumentAvailable() && isPresent(document.elementFromPoint))) {
        return event.target;
    }
    return document.elementFromPoint(event.clientX, event.clientY);
};

/**
 * @hidden
 */
class HierarchyEditingService {
    constructor(hierarchyBinding) {
        this.hierarchyBinding = hierarchyBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, destinationTree }) {
        const destinationDataItem = destinationItem.item.dataItem;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const sourceDataItem = Object.assign({}, sourceItem.item.dataItem);
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationChildren = getter(this.hierarchyBinding.childrenField)(destinationDataItem) || [];
            destinationChildren.push(sourceDataItem);
            setter(this.hierarchyBinding.childrenField)(destinationDataItem, destinationChildren);
        }
        else {
            const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = destinationParentNodes.indexOf(destinationDataItem) + shiftIndex;
            destinationParentNodes.splice(targetIndex, 0, sourceDataItem);
        }
    }
    remove({ sourceItem, sourceTree }) {
        const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
        const sourceItemIndex = sourceParentNodes.indexOf(sourceItem.item.dataItem);
        sourceParentNodes.splice(sourceItemIndex, 1);
        // emit collapse for the parent node if its last child node was spliced
        collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
    }
    getParentNodes(node, treeView) {
        return node.parent ?
            getter(this.hierarchyBinding.childrenField)(node.parent.item.dataItem) :
            treeView.nodes;
    }
}

/**
 * A directive which encapsulates the retrieval of child nodes.
 */
class HierarchyBindingDirective {
    constructor(treeView) {
        this.treeView = treeView;
    }
    /**
     * The field name which holds the data items of the child component.
     */
    set childrenField(value) {
        if (!value) {
            throw new Error("'childrenField' cannot be empty");
        }
        this._childrenField = value;
    }
    /**
     * The field name which holds the data items of the child component.
     */
    get childrenField() {
        return this._childrenField;
    }
    ngOnInit() {
        if (isPresent(this.childrenField)) {
            this.treeView.children = item => of(getter(this.childrenField)(item));
            this.treeView.hasChildren = item => {
                const children = getter(this.childrenField)(item);
                return Boolean(children && children.length);
            };
            this.treeView.editService = new HierarchyEditingService(this);
        }
    }
}
HierarchyBindingDirective.ɵfac = function HierarchyBindingDirective_Factory(t) { return new (t || HierarchyBindingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
HierarchyBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: HierarchyBindingDirective, selectors: [["", "kendoTreeViewHierarchyBinding", ""]], inputs: { childrenField: "childrenField" } });
/** @nocollapse */
HierarchyBindingDirective.ctorParameters = () => [
    { type: TreeViewComponent }
];
HierarchyBindingDirective.propDecorators = {
    childrenField: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HierarchyBindingDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewHierarchyBinding]' }]
    }], function () { return [{ type: TreeViewComponent }]; }, { childrenField: [{
            type: Input
        }] }); })();

/**
 * @hidden
 */
class LoadingIndicatorDirective {
    constructor(expandService, loadingService, cd) {
        this.expandService = expandService;
        this.loadingService = loadingService;
        this.cd = cd;
        this._loading = false;
    }
    get loading() {
        return this._loading;
    }
    set loading(value) {
        this._loading = value;
        this.cd.markForCheck();
    }
    ngOnInit() {
        const loadingNotifications = this.loadingService
            .changes
            .pipe(filter(index => index === this.index));
        this.subscription = this.expandService
            .changes
            .pipe(filter(({ index }) => index === this.index), tap(({ expand }) => {
            if (!expand && this.loading) {
                this.loading = false;
            }
        }), filter(({ expand }) => expand), switchMap(x => of(x).pipe(delay(100), takeUntil(loadingNotifications))))
            .subscribe(() => this.loading = true);
        this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
LoadingIndicatorDirective.ɵfac = function LoadingIndicatorDirective_Factory(t) { return new (t || LoadingIndicatorDirective)(ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(LoadingNotificationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
LoadingIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LoadingIndicatorDirective, selectors: [["", "kendoTreeViewLoading", ""]], hostVars: 2, hostBindings: function LoadingIndicatorDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-i-loading", ctx.loading);
    } }, inputs: { index: ["kendoTreeViewLoading", "index"] } });
/** @nocollapse */
LoadingIndicatorDirective.ctorParameters = () => [
    { type: ExpandStateService },
    { type: LoadingNotificationService },
    { type: ChangeDetectorRef }
];
LoadingIndicatorDirective.propDecorators = {
    loading: [{ type: HostBinding, args: ["class.k-i-loading",] }],
    index: [{ type: Input, args: ["kendoTreeViewLoading",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadingIndicatorDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewLoading]' }]
    }], function () { return [{ type: ExpandStateService }, { type: LoadingNotificationService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { loading: [{
            type: HostBinding,
            args: ["class.k-i-loading"]
        }], index: [{
            type: Input,
            args: ["kendoTreeViewLoading"]
        }] }); })();

/**
 * @hidden
 * Performs the right-to-left function composition. Functions must have a unary.
 */
const compose = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);

/**
 * @hidden
 */
class FlatEditingService {
    constructor(flatBinding) {
        this.flatBinding = flatBinding;
    }
    add({ sourceItem, destinationItem, dropPosition, sourceTree, destinationTree }) {
        const destinationDataItem = destinationItem.item.dataItem;
        // shallow clone the item as not to mistake it for its 'older' version when the remove handler kicks in to splice the item at its old position
        const sourceDataItem = Object.assign({}, sourceItem.item.dataItem);
        if (dropPosition === DropPosition.Over) {
            // expand the item that was dropped into
            expandDropTarget(destinationItem, destinationTree);
            const destinationItemId = getter(this.flatBinding.idField)(destinationDataItem);
            setter(this.flatBinding.parentIdField)(sourceDataItem, destinationItemId);
            this.flatBinding.originalData.push(sourceDataItem);
        }
        else {
            const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
            const targetIndex = this.flatBinding.originalData.indexOf(destinationDataItem) + shiftIndex;
            this.flatBinding.originalData.splice(targetIndex, 0, sourceDataItem);
            const destinationItemParentId = getter(this.flatBinding.parentIdField)(destinationDataItem);
            setter(this.flatBinding.parentIdField)(sourceDataItem, destinationItemParentId);
        }
        if (sourceTree !== destinationTree) {
            this.addChildNodes(sourceDataItem, sourceTree);
        }
        this.flatBinding.nodes = this.flatBinding.originalData;
    }
    remove({ sourceItem, sourceTree, destinationTree }) {
        const sourceDataItem = sourceItem.item.dataItem;
        const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
        this.flatBinding.originalData.splice(sourceItemIndex, 1);
        if (sourceTree !== destinationTree) {
            this.removeChildNodes(sourceDataItem, sourceTree);
        }
        this.flatBinding.nodes = this.flatBinding.originalData;
        // emit collapse for the parent node if its last child node was spliced
        const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
        collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
    }
    addChildNodes(dataItem, source) {
        const itemChildren = this.fetchAllDescendantNodes(dataItem, source);
        this.flatBinding.originalData.push(...itemChildren);
    }
    removeChildNodes(dataItem, source) {
        const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
        sourceChildren.forEach(item => {
            const index = this.flatBinding.originalData.indexOf(item);
            this.flatBinding.originalData.splice(index, 1);
        });
    }
    fetchAllDescendantNodes(node, sourceTreeView) {
        if (!node) {
            return [];
        }
        let nodes = [];
        sourceTreeView
            .children(node)
            .pipe(take(1))
            .subscribe(children => {
            nodes = nodes.concat(children || []);
            children.forEach(child => nodes = nodes.concat(this.fetchAllDescendantNodes(child, sourceTreeView) || []));
        });
        return nodes;
    }
}

const findChildren = (prop, nodes, value) => nodes.filter(x => prop(x) === value);
/**
 * A directive which encapsulates the retrieval of the child nodes.
 */
class FlatDataBindingDirective {
    constructor(treeView) {
        this.treeView = treeView;
        /**
         * @hidden
         */
        this.originalData = [];
    }
    /**
     * The nodes which will be displayed by the TreeView.
     */
    set nodes(values) {
        this.originalData = values || [];
        if (!isNullOrEmptyString(this.parentIdField)) {
            const prop = getter(this.parentIdField);
            this.treeView.nodes = (this.originalData).filter(compose(isBlank, prop));
        }
        else {
            this.treeView.nodes = this.originalData.slice(0);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (isPresent(this.parentIdField) && isPresent(this.idField)) {
            const fetchChildren = node => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));
            this.treeView.hasChildren = node => fetchChildren(node).length > 0;
            this.treeView.children = node => of(fetchChildren(node));
            this.treeView.editService = new FlatEditingService(this);
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (isChanged("parentIdField", changes, false)) {
            this.nodes = this.originalData;
        }
    }
}
FlatDataBindingDirective.ɵfac = function FlatDataBindingDirective_Factory(t) { return new (t || FlatDataBindingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
FlatDataBindingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FlatDataBindingDirective, selectors: [["", "kendoTreeViewFlatDataBinding", ""]], inputs: { nodes: "nodes", parentIdField: "parentIdField", idField: "idField" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
FlatDataBindingDirective.ctorParameters = () => [
    { type: TreeViewComponent }
];
FlatDataBindingDirective.propDecorators = {
    nodes: [{ type: Input }],
    parentIdField: [{ type: Input }],
    idField: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FlatDataBindingDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewFlatDataBinding]' }]
    }], function () { return [{ type: TreeViewComponent }]; }, { nodes: [{
            type: Input
        }], parentIdField: [{
            type: Input
        }], idField: [{
            type: Input
        }] }); })();

const buildItem = (index, dataItem) => ({ dataItem, index });
let id = 0;
/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
class TreeViewItemDirective {
    constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {
        this.element = element;
        this.expandService = expandService;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.lookupService = lookupService;
        this.renderer = renderer;
        this.ib = ib;
        this.isDisabled = false;
        this.ariaChecked = 'false';
        this.id = id++;
        this.isInitialized = false;
        this.subscriptions = [];
        this.subscribe();
    }
    set isChecked(checked) {
        if (checked === 'checked') {
            this.ariaChecked = 'true';
        }
        else if (checked === 'indeterminate') {
            this.ariaChecked = 'mixed';
        }
        else {
            this.ariaChecked = 'false';
        }
    }
    get isExpanded() {
        return this._isExpanded || false;
    }
    set isExpanded(isExpanded) {
        this._isExpanded = isExpanded;
    }
    get isSelected() {
        return this._isSelected || false;
    }
    set isSelected(isSelected) {
        this._isSelected = isSelected;
    }
    get treeItem() {
        return buildItem(this.index, this.dataItem);
    }
    get parentTreeItem() {
        return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;
    }
    ngOnInit() {
        this.lookupService.registerItem(this.treeItem, this.parentTreeItem);
        this.registerNavigationItem();
        this.isInitialized = true;
        this.setAttribute('role', 'treeitem');
        this.setAriaAttributes();
        this.setDisabledClass();
        this.updateTabIndex();
    }
    ngOnChanges(changes) {
        const { index, isDisabled } = changes;
        if (index || changes.isChecked || changes.isExpanded || changes.isSelected) {
            this.setAriaAttributes();
        }
        if (isDisabled) {
            this.setDisabledClass();
        }
        this.moveLookupItem(changes);
        this.moveNavigationItem(index);
        this.disableNavigationItem(isDisabled);
    }
    ngOnDestroy() {
        this.navigationService.unregisterItem(this.id, this.index);
        this.lookupService.unregisterItem(this.index, this.dataItem);
        this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);
    }
    subscribe() {
        this.subscriptions = [
            this.navigationService.moves
                .subscribe(() => {
                this.updateTabIndex();
                this.focusItem();
            }),
            this.navigationService.expands
                .pipe(filter(({ index }) => index === this.index && !this.isDisabled))
                .subscribe(({ expand }) => this.expand(expand))
        ];
    }
    registerNavigationItem() {
        this.navigationService.registerItem(this.id, this.index, this.isDisabled);
        this.activateItem();
    }
    activateItem() {
        if (this.isDisabled) {
            return;
        }
        const navigationService = this.navigationService;
        const selectionService = this.selectionService;
        const index = this.index;
        selectionService.setFirstSelected(index, this.isSelected);
        if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {
            navigationService.activateIndex(index);
        }
    }
    expand(shouldExpand) {
        this.expandService[shouldExpand ? 'expand' : 'collapse'](this.index, this.dataItem);
    }
    isFocusable() {
        return !this.isDisabled && this.navigationService.isFocusable(this.index);
    }
    focusItem() {
        if (this.isInitialized && this.navigationService.isActive(this.index)) {
            this.element.nativeElement.focus();
        }
    }
    moveLookupItem(changes = {}) {
        const { dataItem, index, parentDataItem, parentIndex } = changes;
        if ((index && index.firstChange) || //skip first change
            (!dataItem && !index && !parentDataItem && !parentIndex)) {
            return;
        }
        const oldIndex = (index || {}).previousValue || this.index;
        this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);
    }
    moveNavigationItem(indexChange = {}) {
        const { currentValue, firstChange, previousValue } = indexChange;
        if (!firstChange && isPresent(currentValue) && isPresent(previousValue)) {
            this.navigationService.unregisterItem(this.id, previousValue);
            this.navigationService.registerItem(this.id, currentValue, this.isDisabled);
        }
    }
    disableNavigationItem(disableChange) {
        if (!disableChange || disableChange.firstChange) {
            return;
        }
        const service = this.navigationService;
        if (this.isDisabled) {
            service.activateClosest(this.index); //activate before unregister the item
        }
        else {
            service.activateFocusable();
        }
        service.unregisterItem(this.id, this.index);
        service.registerItem(this.id, this.index, this.isDisabled);
    }
    setAriaAttributes() {
        this.setAttribute('aria-level', this.ib.level(this.index).toString());
        this.setAttribute('aria-expanded', this.isExpanded.toString());
        this.setAttribute('aria-selected', this.isSelected.toString());
        this.setAttribute('aria-checked', this.ariaChecked);
    }
    setDisabledClass() {
        this.setClass('k-state-disabled', this.isDisabled);
    }
    setClass(className, toggle) {
        const action = toggle ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    }
    updateTabIndex() {
        this.setAttribute('tabIndex', this.isFocusable() ? '0' : '-1');
    }
    setAttribute(attr, value) {
        this.renderer.setAttribute(this.element.nativeElement, attr, value);
    }
}
TreeViewItemDirective.ɵfac = function TreeViewItemDirective_Factory(t) { return new (t || TreeViewItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ExpandStateService), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(TreeViewLookupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IndexBuilderService)); };
TreeViewItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TreeViewItemDirective, selectors: [["", "kendoTreeViewItem", ""]], inputs: { isDisabled: "isDisabled", isChecked: "isChecked", isExpanded: "isExpanded", isSelected: "isSelected", dataItem: "dataItem", index: "index", parentDataItem: "parentDataItem", parentIndex: "parentIndex" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
TreeViewItemDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ExpandStateService },
    { type: NavigationService },
    { type: SelectionService },
    { type: TreeViewLookupService },
    { type: Renderer2 },
    { type: IndexBuilderService }
];
TreeViewItemDirective.propDecorators = {
    dataItem: [{ type: Input }],
    index: [{ type: Input }],
    parentDataItem: [{ type: Input }],
    parentIndex: [{ type: Input }],
    isChecked: [{ type: Input }],
    isDisabled: [{ type: Input }],
    isExpanded: [{ type: Input }],
    isSelected: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeViewItemDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewItem]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ExpandStateService }, { type: NavigationService }, { type: SelectionService }, { type: TreeViewLookupService }, { type: ɵngcc0.Renderer2 }, { type: IndexBuilderService }]; }, { isDisabled: [{
            type: Input
        }], isChecked: [{
            type: Input
        }], isExpanded: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], dataItem: [{
            type: Input
        }], index: [{
            type: Input
        }], parentDataItem: [{
            type: Input
        }], parentIndex: [{
            type: Input
        }] }); })();

/**
 * @hidden
 *
 * A directive which manages the expanded state of the TreeView.
 */
class TreeViewItemContentDirective {
    constructor(element, navigationService, selectionService, renderer) {
        this.element = element;
        this.navigationService = navigationService;
        this.selectionService = selectionService;
        this.renderer = renderer;
        this.initialSelection = false;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.navigationService.moves
            .subscribe(this.updateItem.bind(this)));
        this.subscriptions.add(this.navigationService.selects
            .pipe(filter((index) => index === this.index))
            .subscribe((index) => this.selectionService.select(index, this.dataItem)));
        this.subscriptions.add(this.selectionService.changes
            .subscribe(() => {
            this.updateSelection(this.isSelected(this.dataItem, this.index));
        }));
    }
    ngOnChanges(changes) {
        if (changes.initialSelection) {
            this.updateSelection(this.initialSelection);
        }
    }
    ngOnInit() {
        this.updateSelection(this.initialSelection);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    updateItem() {
        this.render(this.navigationService.isActive(this.index), 'k-state-focused');
    }
    updateSelection(selected) {
        this.render(selected, 'k-state-selected');
    }
    render(addClass, className) {
        const action = addClass ? 'addClass' : 'removeClass';
        this.renderer[action](this.element.nativeElement, className);
    }
}
TreeViewItemContentDirective.ɵfac = function TreeViewItemContentDirective_Factory(t) { return new (t || TreeViewItemContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NavigationService), ɵngcc0.ɵɵdirectiveInject(SelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
TreeViewItemContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TreeViewItemContentDirective, selectors: [["", "kendoTreeViewItemContent", ""]], inputs: { initialSelection: "initialSelection", dataItem: "dataItem", index: "index", isSelected: "isSelected" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
TreeViewItemContentDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NavigationService },
    { type: SelectionService },
    { type: Renderer2 }
];
TreeViewItemContentDirective.propDecorators = {
    dataItem: [{ type: Input }],
    index: [{ type: Input }],
    initialSelection: [{ type: Input }],
    isSelected: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeViewItemContentDirective, [{
        type: Directive,
        args: [{ selector: '[kendoTreeViewItemContent]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NavigationService }, { type: SelectionService }, { type: ɵngcc0.Renderer2 }]; }, { initialSelection: [{
            type: Input
        }], dataItem: [{
            type: Input
        }], index: [{
            type: Input
        }], isSelected: [{
            type: Input
        }] }); })();

/**
 * @hidden
 *
 * Represents the CheckBox component of the Kendo UI TreeView for Angular.
 *
 */
class CheckBoxComponent {
    constructor(element, renderer, changeDetector) {
        this.element = element;
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        /**
         * Specifies the [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) of the component.
         */
        this.id = `_${guid()}`;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires when the user changes the check state of the component.
         */
        this.checkStateChange = new EventEmitter();
        this.checkState = 'none';
    }
    //XXX: implement ComponentValueAccessor
    //XXX: focus/blur methods
    get classWrapper() { return true; }
    get indeterminate() {
        return this.checkState === 'indeterminate';
    }
    get checked() {
        return this.checkState === 'checked';
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.element.nativeElement, "tabindex");
    }
    ngDoCheck() {
        this.checkState = this.isChecked(this.node, this.index);
    }
    handleChange(e) {
        const state = e.target.checked ? 'checked' : 'none';
        // update the View State so that Angular updates the input if the isChecked value is the same
        this.checkState = state;
        this.changeDetector.detectChanges();
        this.checkStateChange.emit(state);
    }
}
CheckBoxComponent.ɵfac = function CheckBoxComponent_Factory(t) { return new (t || CheckBoxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
CheckBoxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CheckBoxComponent, selectors: [["kendo-checkbox"]], hostVars: 2, hostBindings: function CheckBoxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("k-checkbox-wrapper", ctx.classWrapper);
    } }, inputs: { id: "id", tabindex: "tabindex", isChecked: "isChecked", node: "node", index: "index", labelText: "labelText" }, outputs: { checkStateChange: "checkStateChange" }, decls: 3, vars: 6, consts: [["type", "checkbox", 1, "k-checkbox", 3, "id", "checked", "indeterminate", "tabindex", "change"], ["tabindex", "-1", 1, "k-checkbox-label", 3, "for"]], template: function CheckBoxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "input", 0);
        ɵngcc0.ɵɵlistener("change", function CheckBoxComponent_Template_input_change_0_listener($event) { return ctx.handleChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.id)("checked", ctx.checked)("indeterminate", ctx.indeterminate)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("for", ctx.id);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.labelText);
    } }, encapsulation: 2 });
/** @nocollapse */
CheckBoxComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
CheckBoxComponent.propDecorators = {
    classWrapper: [{ type: HostBinding, args: ['class.k-checkbox-wrapper',] }],
    id: [{ type: Input }],
    isChecked: [{ type: Input }],
    node: [{ type: Input }],
    index: [{ type: Input }],
    labelText: [{ type: Input }],
    tabindex: [{ type: Input }],
    checkStateChange: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckBoxComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-checkbox',
                template: `
        <input
            class="k-checkbox"
            type="checkbox"
            [id]="id"
            [checked]="checked"
            [indeterminate]="indeterminate"
            [tabindex]="tabindex"
            (change)="handleChange($event)"
        />
        <label
            class="k-checkbox-label"
            tabindex="-1"
            [for]="id"
        >{{labelText}}</label>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { id: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], checkStateChange: [{
            type: Output
        }], classWrapper: [{
            type: HostBinding,
            args: ['class.k-checkbox-wrapper']
        }], isChecked: [{
            type: Input
        }], node: [{
            type: Input
        }], index: [{
            type: Input
        }], labelText: [{
            type: Input
        }] }); })();

const COMPONENT_DIRECTIVES = [
    CheckBoxComponent
];
/**
 * @hidden
 *
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the CheckBox component.
 */
class CheckBoxModule {
}
CheckBoxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CheckBoxModule });
CheckBoxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CheckBoxModule_Factory(t) { return new (t || CheckBoxModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CheckBoxModule, { declarations: [CheckBoxComponent], exports: [CheckBoxComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CheckBoxModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES],
                exports: [COMPONENT_DIRECTIVES]
            }]
    }], null, null); })();

/**
 * @hidden
 */
class DragClueComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.hostClasses = true;
        this.posistionStyle = 'fixed';
    }
    get statusIconClass() {
        switch (this.action) {
            case DropAction.Add: return 'k-i-plus';
            case DropAction.InsertTop: return 'k-i-insert-up';
            case DropAction.InsertBottom: return 'k-i-insert-down';
            case DropAction.InsertMiddle: return 'k-i-insert-middle';
            case DropAction.Invalid:
            default: return 'k-i-cancel';
        }
    }
    // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
    detectChanges() {
        this.cdr.detectChanges();
    }
}
DragClueComponent.ɵfac = function DragClueComponent_Factory(t) { return new (t || DragClueComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DragClueComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DragClueComponent, selectors: [["kendo-treeview-drag-clue"]], hostVars: 6, hostBindings: function DragClueComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("position", ctx.posistionStyle);
        ɵngcc0.ɵɵclassProp("k-header", ctx.hostClasses)("k-drag-clue", ctx.hostClasses);
    } }, decls: 2, vars: 2, consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function DragClueComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DragClueComponent_ng_container_0_Template, 4, 4, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, DragClueComponent_1_Template, 1, 7, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.template);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
DragClueComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
DragClueComponent.propDecorators = {
    hostClasses: [{ type: HostBinding, args: ['class.k-header',] }, { type: HostBinding, args: ['class.k-drag-clue',] }],
    posistionStyle: [{ type: HostBinding, args: ['style.position',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragClueComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treeview-drag-clue',
                template: `
        <ng-container *ngIf="!template">
            <span class="k-icon {{statusIconClass}} k-drag-status"></span>
            <span>{{text}}</span>
        </ng-container>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                text: text,
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { hostClasses: [{
            type: HostBinding,
            args: ['class.k-header']
        }, {
            type: HostBinding,
            args: ['class.k-drag-clue']
        }], posistionStyle: [{
            type: HostBinding,
            args: ['style.position']
        }] }); })();

/**
 * @hidden
 */
class DragAndDropAssetService {
    get componentRef() {
        if (!isPresent(this._componentRef)) {
            throw new Error('The `initalize` method must be called before calling other service methods.');
        }
        return this._componentRef;
    }
    set componentRef(componentRef) {
        this._componentRef = componentRef;
    }
    get element() {
        return this.componentRef.location.nativeElement;
    }
    ngOnDestroy() {
        if (!isPresent(this._componentRef)) {
            return;
        }
        this.element.parentElement.removeChild(this.element);
        this.componentRef.destroy();
        this.componentRef = null;
    }
    show() {
        this.element.style.display = '';
    }
    hide() {
        this.element.style.display = 'none';
    }
    move(left, top, offset = 0) {
        this.element.style.left = `${left + offset}px`;
        this.element.style.top = `${top + offset}px`;
    }
}
DragAndDropAssetService.ɵfac = function DragAndDropAssetService_Factory(t) { return new (t || DragAndDropAssetService)(); };
DragAndDropAssetService.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DragAndDropAssetService });


/**
 * @hidden
 */
const CLUE_OFFSET = 10;
/**
 * @hidden
 */
const RETURN_ANIMATION_DURATION = 200;
/**
 * @hidden
 */
class DragClueService extends DragAndDropAssetService {
    constructor(componentFactoryResolver) {
        super();
        this.componentFactoryResolver = componentFactoryResolver;
    }
    initialize(container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        const clueComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DragClueComponent);
        this.componentRef = container.createComponent(clueComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    }
    ngOnDestroy() {
        this.cancelReturnAnimation();
        super.ngOnDestroy();
    }
    move(left, top) {
        super.move(left, top, CLUE_OFFSET);
    }
    animateDragClueToElementPosition(target) {
        if (!(isPresent(target) && isPresent(this.element.animate))) {
            this.hide();
            return;
        }
        const targetElementViewPortCoords = target.getBoundingClientRect();
        const clueElementViewPortCoords = this.element.getBoundingClientRect();
        this.returnAnimation = this.element.animate([
            { transform: 'translate(0, 0)' },
            { transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)` }
        ], RETURN_ANIMATION_DURATION);
        this.returnAnimation.onfinish = () => this.hide();
    }
    cancelReturnAnimation() {
        if (!isPresent(this.returnAnimation)) {
            return;
        }
        this.returnAnimation.cancel();
        this.returnAnimation = null;
    }
    updateDragClueData(action, sourceItem, destinationItem) {
        const dragClue = this.componentRef.instance;
        if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
            return;
        }
        dragClue.action = action;
        dragClue.sourceItem = sourceItem;
        dragClue.destinationItem = destinationItem;
        dragClue.detectChanges();
    }
    updateText(text) {
        if (text === this.componentRef.instance.text) {
            return;
        }
        this.componentRef.instance.text = text;
        this.componentRef.instance.detectChanges();
    }
}
DragClueService.ɵfac = function DragClueService_Factory(t) { return new (t || DragClueService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
DragClueService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DragClueService, factory: DragClueService.ɵfac });
/** @nocollapse */
DragClueService.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragClueService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();

/**
 * @hidden
 */
class DropHintComponent {
    constructor() {
        this.hostClass = true;
        this.position = 'fixed';
        this.pointerEvents = 'none';
    }
}
DropHintComponent.ɵfac = function DropHintComponent_Factory(t) { return new (t || DropHintComponent)(); };
DropHintComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DropHintComponent, selectors: [["kendo-treeview-drop-hint"]], hostVars: 6, hostBindings: function DropHintComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("position", ctx.position)("pointer-events", ctx.pointerEvents);
        ɵngcc0.ɵɵclassProp("k-drop-hint-container", ctx.hostClass);
    } }, decls: 2, vars: 2, consts: [["class", "k-icon k-i-drag-and-drop", 4, "ngIf"], [4, "ngIf"], [1, "k-icon", "k-i-drag-and-drop"], [3, "ngTemplateOutlet"]], template: function DropHintComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DropHintComponent_span_0_Template, 1, 0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, DropHintComponent_1_Template, 1, 1, undefined, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.template);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
DropHintComponent.propDecorators = {
    hostClass: [{ type: HostBinding, args: ['class.k-drop-hint-container',] }],
    position: [{ type: HostBinding, args: ['style.position',] }],
    pointerEvents: [{ type: HostBinding, args: ['style.pointer-events',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropHintComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-treeview-drop-hint',
                template: `
        <span
            *ngIf="!template"
            class="k-icon k-i-drag-and-drop"
        >
        </span>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
        >
        <ng-template>
    `
            }]
    }], function () { return []; }, { hostClass: [{
            type: HostBinding,
            args: ['class.k-drop-hint-container']
        }], position: [{
            type: HostBinding,
            args: ['style.position']
        }], pointerEvents: [{
            type: HostBinding,
            args: ['style.pointer-events']
        }] }); })();

/**
 * @hidden
 */
class DropHintService extends DragAndDropAssetService {
    constructor(componentFactoryResolver) {
        super();
        this.componentFactoryResolver = componentFactoryResolver;
    }
    initialize(container, template) {
        if (isPresent(this._componentRef)) {
            this.ngOnDestroy();
        }
        const hintComponentFactory = this.componentFactoryResolver.resolveComponentFactory(DropHintComponent);
        this.componentRef = container.createComponent(hintComponentFactory);
        this.hide();
        this.componentRef.instance.template = template;
        this.componentRef.changeDetectorRef.detectChanges();
    }
}
DropHintService.ɵfac = function DropHintService_Factory(t) { return new (t || DropHintService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
DropHintService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DropHintService, factory: DropHintService.ɵfac });
/** @nocollapse */
DropHintService.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropHintService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();

/**
 * Represents the template for the TreeView drag clue when an item is dragged. To define the clue template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDragClueTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 *
 *
 * The text, attempted drop action, source item and destination item are available as context variables in the template:
 *
 *
 * - `let-text="text"` (`string`)
 * - `let-action="action"` ([`DropAction`]({% slug api_treeview_dropaction %}))
 * - `let-sourceItem="sourceItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 * - `let-destinationItem="destinationItem"` ([`TreeItemLookup`]({% slug api_treeview_treeitemlookup %}))
 */
class DragClueTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DragClueTemplateDirective.ɵfac = function DragClueTemplateDirective_Factory(t) { return new (t || DragClueTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DragClueTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DragClueTemplateDirective, selectors: [["", "kendoTreeViewDragClueTemplate", ""]] });
/** @nocollapse */
DragClueTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragClueTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDragClueTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Represents the template for the TreeView drop hint when an item is dragged. To define the hint template,
 * nest an `<ng-template>` tag with the `kendoTreeViewDropHintTemplate` directive inside a `<kendo-treeview>` tag
 * ([see example]({% slug draganddrop_treeview %}#toc-templates)).
 */
class DropHintTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DropHintTemplateDirective.ɵfac = function DropHintTemplateDirective_Factory(t) { return new (t || DropHintTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DropHintTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DropHintTemplateDirective, selectors: [["", "kendoTreeViewDropHintTemplate", ""]] });
/** @nocollapse */
DropHintTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DropHintTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDropHintTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * A directive which enables the dragging and dropping items inside the current TreeView or between multiple linked TreeView component instances.
 * Triggers the [`nodeDragStart`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragstart),
 * [`nodeDrag`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrag),
 * [`nodeDrop`]({% slug api_treeview_treeviewcomponent %}#toc-nodedrop),
 * [`nodeDragEnd`]({% slug api_treeview_treeviewcomponent %}#toc-nodedragend),
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and
 * [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * events when the corresponding actions occur on the respective TreeView instance.
 */
class DragAndDropDirective {
    constructor(element, zone, treeview, dragClueService, dropHintService) {
        this.element = element;
        this.zone = zone;
        this.treeview = treeview;
        this.dragClueService = dragClueService;
        this.dropHintService = dropHintService;
        /**
         * Specifies whether the `removeItem` event will be fired after an item is dropped when the `ctrl` key is pressed.
         * If enabled, the `removeItem` event will not be fired on the source TreeView
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         *
         * @default false
         */
        this.allowCopy = false;
        /**
         * Specifes the TreeViewComponent instances into which dragged items from the current TreeViewComponent can be dropped
         * ([see example]({% slug draganddrop_treeview %}#toc-multiple-treeviews)).
         */
        this.dropZoneTreeViews = [];
        /**
         * @hidden
         */
        this.userSelectStyle = 'none';
        /**
         * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
         * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
         */
        this.containerOffset = { top: 0, left: 0 };
        this.treeview.touchActions = false;
    }
    ngAfterContentInit() {
        this.initalizeDraggable();
        this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
        this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
    }
    ngOnDestroy() {
        this.draggable.destroy();
    }
    /**
     * @hidden
     */
    handlePress({ originalEvent }) {
        if (!isContent(originalEvent.target)) {
            return;
        }
        const dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDragStart)) {
            const dragStartEvent = this.zone.run(() => this.notifyDragStart(originalEvent, dropTarget));
            if (dragStartEvent.isDefaultPrevented()) {
                return;
            }
        }
        // store the drag target on press, show it only when it's actually dragged
        this.draggedItem = closestWithMatch(originalEvent.target, '.k-in');
        this.dragClueService.cancelReturnAnimation();
        this.dragClueService.updateText(this.draggedItem.innerText);
        this.containerOffset = getContainerOffset(this.draggedItem);
    }
    /**
     * @hidden
     */
    handleDrag({ originalEvent, clientX, clientY }) {
        if (!isPresent(this.draggedItem)) {
            return;
        }
        const dropTarget = getDropTarget(originalEvent);
        if (hasObservers(this.treeview.nodeDrag)) {
            this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));
        }
        const targetTreeView = this.getTargetTreeView(dropTarget);
        const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
        const dropHintAnchor = closestWithMatch(dropTarget, '.k-mid');
        this.updateDropHintState(dropPosition, dropHintAnchor);
        const dropAction = getDropAction(dropPosition, dropTarget);
        const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
        const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
        this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
    }
    /**
     * @hidden
     */
    handleRelease({ originalEvent, clientY }) {
        if (!isPresent(this.draggedItem)) {
            return;
        }
        const dropTarget = getDropTarget(originalEvent);
        const sourceTree = this.treeview;
        const destinationTree = this.getTargetTreeView(dropTarget);
        const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
        const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
        const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
        if (isPresent(destinationItem) && isPresent(dropPosition)) {
            this.zone.run(() => this.notifyDrop({ sourceItem, destinationItem, dropPosition, sourceTree, destinationTree }, originalEvent));
        }
        else {
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
        if (hasObservers(this.treeview.nodeDragEnd)) {
            this.zone.run(() => this.notifyDragEnd({ sourceItem, destinationItem, originalEvent }));
        }
        this.dropHintService.hide();
        this.draggedItem = null;
    }
    updateDropHintState(dropPosition, dropHintAnchor) {
        if (!isPresent(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent(dropPosition)) {
            this.dropHintService.hide();
            return;
        }
        const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
        const insertBefore = dropPosition === DropPosition.Before;
        const top = insertBefore ? anchorViewPortCoords.top : (anchorViewPortCoords.top + anchorViewPortCoords.height);
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
        this.dropHintService.show();
    }
    updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {
        // clear any possible container offset created by parent elements with `transform` css property set
        this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
        this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
        this.dragClueService.show();
    }
    initalizeDraggable() {
        this.draggable = new Draggable({
            press: this.handlePress.bind(this),
            drag: this.handleDrag.bind(this),
            release: this.handleRelease.bind(this)
        });
        this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
    }
    notifyDragStart(originalEvent, dropTarget) {
        const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
        const event = new TreeItemDragStartEvent({ sourceItem, originalEvent });
        this.treeview.nodeDragStart.emit(event);
        return event;
    }
    notifyDrag(originalEvent, dropTarget) {
        const dragEvent = {
            sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
            destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
            originalEvent
        };
        this.treeview.nodeDrag.emit(dragEvent);
    }
    notifyDrop(args, originalEvent) {
        const event = new TreeItemDropEvent(args, originalEvent);
        args.destinationTree.nodeDrop.emit(event);
        // disable the animations on drop and restore them afterwards (if they were initially turned on)
        this.disableAnimationsForNextTick(args.destinationTree);
        if (args.sourceTree !== args.destinationTree) {
            this.disableAnimationsForNextTick(args.sourceTree);
        }
        if (!event.isDefaultPrevented() && event.isValid) {
            this.dragClueService.hide();
            // order matters in a flat data binding scenario (first add, then remove)
            args.destinationTree.addItem.emit(args);
            if (!(originalEvent.ctrlKey && this.allowCopy)) {
                args.sourceTree.removeItem.emit(args);
            }
        }
        else if (event.isDefaultPrevented()) {
            // directly hide the clue if the default is prevented
            this.dragClueService.hide();
        }
        else if (!event.isValid) {
            // animate the clue back to the source item position if marked as invalid
            this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
        }
    }
    notifyDragEnd(dragEndEvent) {
        this.treeview.nodeDragEnd.emit(dragEndEvent);
    }
    getTargetTreeView(dropTarget) {
        const treeViewTagName = this.treeview.element.nativeElement.tagName;
        const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
        return [this.treeview, ...this.dropZoneTreeViews].find(treeView => isPresent(treeView) && treeView.element.nativeElement === targetTreeView);
    }
    disableAnimationsForNextTick(treeView) {
        // the treeView.animate getter returns `true` when the animations are turned off
        // confusing, but seems on purpose (the `animate` prop sets the value of the @.disabled host-bound attribute)
        if (treeView.animate) {
            return;
        }
        treeView.animate = false;
        this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));
    }
}
DragAndDropDirective.ɵfac = function DragAndDropDirective_Factory(t) { return new (t || DragAndDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(TreeViewComponent), ɵngcc0.ɵɵdirectiveInject(DragClueService), ɵngcc0.ɵɵdirectiveInject(DropHintService)); };
DragAndDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DragAndDropDirective, selectors: [["", "kendoTreeViewDragAndDrop", ""]], contentQueries: function DragAndDropDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);
    } }, hostVars: 4, hostBindings: function DragAndDropDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("user-select", ctx.userSelectStyle)("-ms-user-select", ctx.userSelectStyle);
    } }, inputs: { allowCopy: "allowCopy", dropZoneTreeViews: "dropZoneTreeViews" }, features: [ɵngcc0.ɵɵProvidersFeature([
            DragClueService,
            DropHintService
        ])] });
/** @nocollapse */
DragAndDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: TreeViewComponent },
    { type: DragClueService },
    { type: DropHintService }
];
DragAndDropDirective.propDecorators = {
    allowCopy: [{ type: Input }],
    dropZoneTreeViews: [{ type: Input }],
    dragClueTemplate: [{ type: ContentChild, args: [DragClueTemplateDirective,] }],
    dropHintTemplate: [{ type: ContentChild, args: [DropHintTemplateDirective,] }],
    userSelectStyle: [{ type: HostBinding, args: ['style.user-select',] }, { type: HostBinding, args: ['style.-ms-user-select',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragAndDropDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDragAndDrop]',
                providers: [
                    DragClueService,
                    DropHintService
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: TreeViewComponent }, { type: DragClueService }, { type: DropHintService }]; }, { allowCopy: [{
            type: Input
        }], dropZoneTreeViews: [{
            type: Input
        }], userSelectStyle: [{
            type: HostBinding,
            args: ['style.user-select']
        }, {
            type: HostBinding,
            args: ['style.-ms-user-select']
        }], dragClueTemplate: [{
            type: ContentChild,
            args: [DragClueTemplateDirective]
        }], dropHintTemplate: [{
            type: ContentChild,
            args: [DropHintTemplateDirective]
        }] }); })();

/**
 * A directive which enables the update of the initially provided data array during drag-and-drop.
 *
 * Either use this directive in combination with one of the data binding directives ([`kendoTreeViewHierarchyBinding`]({% slug api_treeview_hierarchybindingdirective %})
 * or [`kendoTreeViewFlatDataBinding`]({% slug api_treeview_flatdatabindingdirective %})) which set their own edit handlers, or provide
 * your own [`editService`]({% slug api_treeview_editservice %}) to this directive. The latter subscribes to and calls the
 * [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem) and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem)
 * handlers when the corresponding events are triggered by the TreeView component.
 */
class DragAndDropEditingDirective {
    constructor(treeview) {
        this.treeview = treeview;
        this.subscriptions = new Subscription();
        this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));
        this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));
    }
    /**
     * Specifies the handlers called on drag-and-drop [`addItem`]({% slug api_treeview_treeviewcomponent %}#toc-additem)
     * and [`removeItem`]({% slug api_treeview_treeviewcomponent %}#toc-removeitem) events.
     */
    set editService(service) {
        this.treeview.editService = service;
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    handleAdd(args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.add(args);
    }
    handleRemove(args) {
        if (!isPresent(this.treeview.editService)) {
            throw new Error('No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).');
        }
        this.treeview.editService.remove(args);
    }
}
DragAndDropEditingDirective.ɵfac = function DragAndDropEditingDirective_Factory(t) { return new (t || DragAndDropEditingDirective)(ɵngcc0.ɵɵdirectiveInject(TreeViewComponent)); };
DragAndDropEditingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DragAndDropEditingDirective, selectors: [["", "kendoTreeViewDragAndDropEditing", ""]], inputs: { editService: "editService" } });
/** @nocollapse */
DragAndDropEditingDirective.ctorParameters = () => [
    { type: TreeViewComponent }
];
DragAndDropEditingDirective.propDecorators = {
    editService: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DragAndDropEditingDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoTreeViewDragAndDropEditing]'
            }]
    }], function () { return [{ type: TreeViewComponent }]; }, { editService: [{
            type: Input
        }] }); })();

const COMPONENT_DIRECTIVES$1 = [
    TreeViewComponent,
    TreeViewGroupComponent,
    TreeViewItemDirective,
    TreeViewItemContentDirective,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    LoadingIndicatorDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DragClueComponent,
    DropHintTemplateDirective,
    DropHintComponent,
    DragAndDropEditingDirective
];
/**
 * @hidden
 */
class SharedModule {
}
SharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SharedModule });
SharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SharedModule_Factory(t) { return new (t || SharedModule)(); }, imports: [[CommonModule, CheckBoxModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SharedModule, { declarations: function () { return [TreeViewComponent,
        TreeViewGroupComponent,
        TreeViewItemDirective,
        TreeViewItemContentDirective,
        NodeTemplateDirective,
        CheckDirective,
        DisableDirective,
        ExpandDirective,
        SelectDirective,
        HierarchyBindingDirective,
        LoadingIndicatorDirective,
        FlatDataBindingDirective,
        DragAndDropDirective,
        DragClueTemplateDirective,
        DragClueComponent,
        DropHintTemplateDirective,
        DropHintComponent,
        DragAndDropEditingDirective]; }, imports: function () { return [CommonModule,
        CheckBoxModule]; }, exports: function () { return [TreeViewComponent,
        TreeViewGroupComponent,
        TreeViewItemDirective,
        TreeViewItemContentDirective,
        NodeTemplateDirective,
        CheckDirective,
        DisableDirective,
        ExpandDirective,
        SelectDirective,
        HierarchyBindingDirective,
        LoadingIndicatorDirective,
        FlatDataBindingDirective,
        DragAndDropDirective,
        DragClueTemplateDirective,
        DragClueComponent,
        DropHintTemplateDirective,
        DropHintComponent,
        DragAndDropEditingDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SharedModule, [{
        type: NgModule,
        args: [{
                declarations: [COMPONENT_DIRECTIVES$1],
                exports: [COMPONENT_DIRECTIVES$1],
                imports: [CommonModule, CheckBoxModule],
                entryComponents: [
                    DragClueComponent,
                    DropHintComponent
                ]
            }]
    }], null, null); })();

const EXPORTS = [
    TreeViewComponent,
    NodeTemplateDirective,
    CheckDirective,
    DisableDirective,
    ExpandDirective,
    SelectDirective,
    HierarchyBindingDirective,
    FlatDataBindingDirective,
    DragAndDropDirective,
    DragClueTemplateDirective,
    DropHintTemplateDirective,
    DragAndDropEditingDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}) definition for the TreeView component.
 */
class TreeViewModule {
}
TreeViewModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TreeViewModule });
TreeViewModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TreeViewModule_Factory(t) { return new (t || TreeViewModule)(); }, imports: [[SharedModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeViewModule, { imports: [SharedModule], exports: [TreeViewComponent,
        NodeTemplateDirective,
        CheckDirective,
        DisableDirective,
        ExpandDirective,
        SelectDirective,
        HierarchyBindingDirective,
        FlatDataBindingDirective,
        DragAndDropDirective,
        DragClueTemplateDirective,
        DropHintTemplateDirective,
        DragAndDropEditingDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeViewModule, [{
        type: NgModule,
        args: [{
                exports: [EXPORTS],
                imports: [SharedModule]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CheckBoxComponent, CheckBoxModule, DataChangeNotificationService, DragClueComponent, DragClueService, DropHintComponent, DropHintService, DragAndDropAssetService, PreventableEvent, ExpandStateService, IndexBuilderService, LoadingIndicatorDirective, LoadingNotificationService, NavigationService, NodeChildrenService, SelectionService, SharedModule, TreeViewGroupComponent, TreeViewItemContentDirective, TreeViewItemDirective, TreeViewLookupService, TreeViewComponent, TreeViewModule, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragAndDropEditingDirective, DropHintTemplateDirective, DragClueTemplateDirective, DropAction, DropPosition, TreeItemDropEvent, TreeItemDragStartEvent, TreeItemDragEvent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21IQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztvRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJJQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkZBNEJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUErRkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrV0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlJBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhSQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2lPQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bU1BR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztpRUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZRQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrWUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21UQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFxQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7cUdBd0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZHQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozt5RkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztxR0FtQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZHQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozt5RkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VKQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dUpBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7ZUFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cU1BS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiwgT3B0aW9uYWwsIENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIEVsZW1lbnRSZWYsIE5nWm9uZSwgUmVuZGVyZXIyLCBIb3N0QmluZGluZywgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmLCBJbnB1dCwgT3V0cHV0LCBDb250ZW50Q2hpbGQsIENoYW5nZURldGVjdG9yUmVmLCBOZ01vZHVsZSwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc0RvY3VtZW50QXZhaWxhYmxlLCBLZXlzLCBoYXNPYnNlcnZlcnMsIGlzQ2hhbmdlZCwgZ3VpZCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgU3ViamVjdCwgb2YsIEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBFTVBUWSwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRyaWdnZXIsIHRyYW5zaXRpb24sIHN0eWxlLCBhbmltYXRlIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBnZXR0ZXIsIHNldHRlciB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1jb21tb24nO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgdGFwLCBmaWx0ZXIsIHN3aXRjaE1hcCwgdGFrZSwgbWFwLCBkZWxheSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnQHRlbGVyaWsva2VuZG8tZHJhZ2dhYmxlJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5lbWl0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGFzQ2hpbGRyZW4gPSAoKSA9PiBmYWxzZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc0NoZWNrZWQgPSAoKSA9PiAnbm9uZSc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNEaXNhYmxlZCA9ICgpID0+IGZhbHNlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzRXhwYW5kZWQgPSAoKSA9PiB0cnVlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzU2VsZWN0ZWQgPSAoKSA9PiBmYWxzZTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEV4cGFuZFN0YXRlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIGV4cGFuZChpbmRleCwgZGF0YUl0ZW0pIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoeyBkYXRhSXRlbSwgaW5kZXgsIGV4cGFuZDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY29sbGFwc2UoaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHsgZGF0YUl0ZW0sIGluZGV4LCBleHBhbmQ6IGZhbHNlIH0pO1xuICAgIH1cbn1cbkV4cGFuZFN0YXRlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEluZGV4QnVpbGRlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLklOREVYX1NFUEFSQVRPUiA9ICdfJztcbiAgICB9XG4gICAgbm9kZUluZGV4KGluZGV4ID0gJycsIHBhcmVudEluZGV4ID0gJycpIHtcbiAgICAgICAgcmV0dXJuIGAke3BhcmVudEluZGV4fSR7cGFyZW50SW5kZXggPyB0aGlzLklOREVYX1NFUEFSQVRPUiA6ICcnfSR7aW5kZXh9YDtcbiAgICB9XG4gICAgaW5kZXhGb3JMZXZlbChpbmRleCwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4LnNwbGl0KHRoaXMuSU5ERVhfU0VQQVJBVE9SKS5zbGljZSgwLCBsZXZlbCkuam9pbih0aGlzLklOREVYX1NFUEFSQVRPUik7XG4gICAgfVxuICAgIGxhc3RMZXZlbEluZGV4KGluZGV4ID0gJycpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBpbmRleC5zcGxpdCh0aGlzLklOREVYX1NFUEFSQVRPUik7XG4gICAgICAgIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSwgMTApO1xuICAgIH1cbiAgICBsZXZlbChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXguc3BsaXQodGhpcy5JTkRFWF9TRVBBUkFUT1IpLmxlbmd0aDtcbiAgICB9XG59XG5JbmRleEJ1aWxkZXJTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTG9hZGluZ05vdGlmaWNhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBub3RpZnlMb2FkZWQoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoaW5kZXgpO1xuICAgIH1cbn1cbkxvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG5jb25zdCBmb2N1c2FibGVSZWdleCA9IC9eKD86YXxpbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG1hdGNoID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlciA9IGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVyLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0V2l0aE1hdGNoID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChtYXRjaChwYXJlbnQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudCB8fCBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNQcmVzZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQmxhbmsgPSAodmFsdWUpID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaXNOdWxsT3JFbXB0eVN0cmluZyA9ICh2YWx1ZSkgPT4gaXNCbGFuayh2YWx1ZSkgfHwgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0Tm9kZSA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSAnbGkuay10cmVldmlldy1pdGVtJztcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY2xvc2VzdCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjbG9zZXN0V2l0aE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzRm9jdXNhYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICAgICAgY29uc3Qgc2tpcFRhYiA9IHRhYkluZGV4ID09PSAnLTEnO1xuICAgICAgICBsZXQgZm9jdXNhYmxlID0gdGFiSW5kZXggIT09IG51bGwgJiYgIXNraXBUYWI7XG4gICAgICAgIGlmIChmb2N1c2FibGVSZWdleC50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICBmb2N1c2FibGUgPSAhZWxlbWVudC5kaXNhYmxlZCAmJiAhc2tpcFRhYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9jdXNhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzQ29udGVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3Qgc2NvcGVTZWxlY3RvciA9ICcuay1pbiwuay10cmVldmlldy1pdGVtLC5rLXRyZWV2aWV3JztcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSBlbGVtZW50O1xuICAgIHdoaWxlIChub2RlICYmICFtYXRjaChub2RlLCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbWF0Y2gobm9kZSwgJy5rLWluJyk7XG4gICAgfVxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjbG9zZXN0ID0gKG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc1BhcmVudCA9IChlbGVtZW50LCBjb250YWluZXIpID0+IHtcbiAgICByZXR1cm4gQm9vbGVhbihjbG9zZXN0KGVsZW1lbnQsIChub2RlKSA9PiBub2RlID09PSBjb250YWluZXIpKTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9jdXNhYmxlTm9kZSA9IChlbGVtZW50KSA9PiBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignbGlbdGFiaW5kZXg9XCIwXCJdJyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgbm9kZUlkID0gKG5vZGUpID0+IG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS10cmVlaW5kZXgnKSA6ICcnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IG5vZGVJbmRleCA9IChpdGVtKSA9PiAoaXRlbSB8fCB7fSkuaW5kZXg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGF0YUl0ZW1zRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgIGlmICghaXNQcmVzZW50KGZpcnN0KSAmJiAhaXNQcmVzZW50KHNlY29uZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1ByZXNlbnQoZmlyc3QpICYmIGlzUHJlc2VudChzZWNvbmQpICYmIGZpcnN0Lml0ZW0uZGF0YUl0ZW0gPT09IHNlY29uZC5pdGVtLmRhdGFJdGVtO1xufTtcblxuY29uc3QgbGFzdCA9IChsaXN0KSA9PiBsaXN0W2xpc3QubGVuZ3RoIC0gMV07XG5jb25zdCBzYWZlID0gbm9kZSA9PiAobm9kZSB8fCB7fSk7XG5jb25zdCBzYWZlQ2hpbGRyZW4gPSBub2RlID0+IChzYWZlKG5vZGUpLmNoaWxkcmVuIHx8IFtdKTtcbmNvbnN0IGZpbmRMYXN0ID0gbm9kZSA9PiB7XG4gICAgbGV0IGxhc3ROb2RlID0gbm9kZTtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXS5jb25jYXQoc2FmZUNoaWxkcmVuKG5vZGUpKTtcbiAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KHNhZmVDaGlsZHJlbihsYXN0KGNoaWxkcmVuKSkpO1xuICAgICAgICBsYXN0Tm9kZSA9IGNoaWxkcmVuLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiBsYXN0Tm9kZTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvbk1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pYiA9IG5ldyBJbmRleEJ1aWxkZXJTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG4gICAgZmlyc3ROb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXSB8fCBudWxsO1xuICAgIH1cbiAgICBsYXN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZExhc3QobGFzdCh0aGlzLmNvbnRhaW5lcihub2RlKSkpIHx8IG5vZGU7XG4gICAgfVxuICAgIGNsb3Nlc3ROb2RlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgcHJldiB9ID0gc2FmZSh0aGlzLmZpbmROb2RlKGluZGV4KSk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBwcmV2IHx8IHRoaXMuZmlyc3ROb2RlKCk7XG4gICAgICAgIHJldHVybiBzYWZlKHNpYmxpbmcpLmluZGV4ID09PSBpbmRleCA/IHRoaXMuc2libGluZyhzaWJsaW5nLCAxKSA6IHNpYmxpbmc7XG4gICAgfVxuICAgIGZpbmROb2RlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQoaW5kZXgsIHRoaXMubm9kZXMpO1xuICAgIH1cbiAgICBmaW5kUGFyZW50KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudExldmVsID0gdGhpcy5pYi5sZXZlbChpbmRleCkgLSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kTm9kZSh0aGlzLmliLmluZGV4Rm9yTGV2ZWwoaW5kZXgsIHBhcmVudExldmVsKSk7XG4gICAgfVxuICAgIGZpbmRDaGlsZChpbmRleCkge1xuICAgICAgICByZXR1cm4gc2FmZUNoaWxkcmVuKHRoaXMuZmluZE5vZGUoaW5kZXgpKVswXSB8fCBudWxsO1xuICAgIH1cbiAgICBmaW5kUHJldihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbS5pbmRleDtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5maW5kUGFyZW50KGluZGV4KTtcbiAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuaWIubGFzdExldmVsSW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAobGV2ZWxJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRoaXMuZmluZE5vZGUoaW5kZXgpO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc2libGluZyhjdXJyZW50Tm9kZSwgLTEpO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jb250YWluZXIocHJldik7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBsYXN0KGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY29udGFpbmVyKHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cbiAgICBmaW5kTmV4dChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jb250YWluZXIoaXRlbSk7XG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpYmxpbmcoaXRlbSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICByZWdpc3Rlckl0ZW0oaWQsIGluZGV4LCBkaXNhYmxlZCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaWIubGV2ZWwoaW5kZXgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnQoaW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50IHx8IGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0geyBpZCwgY2hpbGRyZW4sIGluZGV4LCBwYXJlbnQsIGRpc2FibGVkIH07XG4gICAgICAgICAgICB0aGlzLmluc2VydChub2RlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVnaXN0ZXJJdGVtKGlkLCBpbmRleCkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5maW5kKGluZGV4LCB0aGlzLm5vZGVzKTtcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaWQgIT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNvbnRhaW5lcihub2RlLnBhcmVudCk7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZHJlbi5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICB9XG4gICAgY2hpbGRMZXZlbChub2Rlcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IGlzUHJlc2VudChub2RlKSk7XG4gICAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWIubGV2ZWwoY2hpbGRyZW5bMF0uaW5kZXgpO1xuICAgIH1cbiAgICBjb250YWluZXIobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSA/IG5vZGUuY2hpbGRyZW4gOiB0aGlzLm5vZGVzO1xuICAgIH1cbiAgICBmaW5kKGluZGV4LCBub2Rlcykge1xuICAgICAgICBjb25zdCBjaGlsZExldmVsID0gdGhpcy5jaGlsZExldmVsKG5vZGVzKTtcbiAgICAgICAgY29uc3QgaW5kZXhUb01hdGNoID0gdGhpcy5pYi5pbmRleEZvckxldmVsKGluZGV4LCBjaGlsZExldmVsKTtcbiAgICAgICAgY29uc3QgaXNMZWFmID0gY2hpbGRMZXZlbCA9PT0gdGhpcy5pYi5sZXZlbChpbmRleCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5maW5kKG4gPT4gbiAmJiBuLmluZGV4ID09PSBpbmRleFRvTWF0Y2gpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0xlYWYgPyBub2RlIDogdGhpcy5maW5kKGluZGV4LCBub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgaW5zZXJ0KG5vZGUsIHBhcmVudCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuY29udGFpbmVyKHBhcmVudCk7XG4gICAgICAgIG5vZGVzLnNwbGljZSh0aGlzLmliLmxhc3RMZXZlbEluZGV4KG5vZGUuaW5kZXgpLCAwLCBub2RlKTtcbiAgICB9XG4gICAgc2libGluZyhub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnQobm9kZS5pbmRleCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKHBhcmVudCk7XG4gICAgICAgIHJldHVybiBjb250YWluZXJbY29udGFpbmVyLmluZGV4T2Yobm9kZSkgKyBvZmZzZXRdIHx8IHRoaXMuc2libGluZyhwYXJlbnQsIG9mZnNldCkgfHwgbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBOYXZpZ2F0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmV4cGFuZHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm1vdmVzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5jaGVja3MgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnNlbGVjdHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm5hdmlnYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIFtLZXlzLkFycm93VXBdOiAoKSA9PiB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZFByZXYodGhpcy5mb2N1c2FibGVJdGVtKSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd0Rvd25dOiAoKSA9PiB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZE5leHQodGhpcy5mb2N1c2FibGVJdGVtKSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd0xlZnRdOiAoKSA9PiAodGhpcy5leHBhbmQoe1xuICAgICAgICAgICAgICAgIGV4cGFuZDogdGhpcy5sb2NhbGl6YXRpb24ucnRsLFxuICAgICAgICAgICAgICAgIGludGVyY2VwdDogdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gdGhpcy5tb3ZlVG9DaGlsZCA6IHRoaXMubW92ZVRvUGFyZW50XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBbS2V5cy5BcnJvd1JpZ2h0XTogKCkgPT4gKHRoaXMuZXhwYW5kKHtcbiAgICAgICAgICAgICAgICBleHBhbmQ6ICF0aGlzLmxvY2FsaXphdGlvbi5ydGwsXG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0OiB0aGlzLmxvY2FsaXphdGlvbi5ydGwgPyB0aGlzLm1vdmVUb1BhcmVudCA6IHRoaXMubW92ZVRvQ2hpbGRcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIFtLZXlzLkhvbWVdOiAoKSA9PiB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmlyc3ROb2RlKCkpLFxuICAgICAgICAgICAgW0tleXMuRW5kXTogKCkgPT4gdGhpcy5hY3RpdmF0ZSh0aGlzLm1vZGVsLmxhc3ROb2RlKCkpLFxuICAgICAgICAgICAgW0tleXMuRW50ZXJdOiAoKSA9PiB0aGlzLm5hdmlnYWJsZSAmJiB0aGlzLnNlbGVjdEluZGV4KG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pKSxcbiAgICAgICAgICAgIFtLZXlzLlNwYWNlXTogKCkgPT4gdGhpcy5uYXZpZ2FibGUgJiYgdGhpcy5jaGVja0luZGV4KG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tb2RlbCA9IG5ldyBOYXZpZ2F0aW9uTW9kZWwoKTtcbiAgICAgICAgdGhpcy5tb3ZlVG9DaGlsZCA9IHRoaXMubW92ZVRvQ2hpbGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlVG9QYXJlbnQgPSB0aGlzLm1vdmVUb1BhcmVudC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgICB9XG4gICAgc2V0IG1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIGdldCBhY3RpdmVJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pIHx8IG51bGw7XG4gICAgfVxuICAgIGdldCBmb2N1c2FibGVJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVJdGVtIHx8IHRoaXMubW9kZWwuZmlyc3ROb2RlKCk7XG4gICAgfVxuICAgIGdldCBpc0FjdGl2ZUV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVJdGVtICYmIHRoaXMuYWN0aXZlSXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBhY3RpdmF0ZShpdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUgfHwgIWl0ZW0gfHwgdGhpcy5pc0FjdGl2ZShub2RlSW5kZXgoaXRlbSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBpdGVtIHx8IHRoaXMuYWN0aXZlSXRlbTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlUGFyZW50KGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kUGFyZW50KGluZGV4KSk7XG4gICAgfVxuICAgIGFjdGl2YXRlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kTm9kZShpbmRleCkpO1xuICAgIH1cbiAgICBhY3RpdmF0ZUNsb3Nlc3QoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpbmRleCB8fCBub2RlSW5kZXgodGhpcy5mb2N1c2FibGVJdGVtKSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSB0aGlzLm1vZGVsLmNsb3Nlc3ROb2RlKGluZGV4KTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGFjdGl2YXRlRm9jdXNhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtID0gdGhpcy5tb2RlbC5maXJzdE5vZGUoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUgfHwgIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub3RpZnlNb3ZlKCk7XG4gICAgfVxuICAgIGNoZWNrSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcy5uZXh0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0cy5uZXh0KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0FjdGl2ZShpbmRleCkge1xuICAgICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGb2N1c2VkICYmIHRoaXMuYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICAgIH1cbiAgICBpc0ZvY3VzYWJsZShpbmRleCkge1xuICAgICAgICByZXR1cm4gbm9kZUluZGV4KHRoaXMuZm9jdXNhYmxlSXRlbSkgPT09IGluZGV4O1xuICAgIH1cbiAgICBpc0Rpc2FibGVkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmROb2RlKGluZGV4KS5kaXNhYmxlZDtcbiAgICB9XG4gICAgcmVnaXN0ZXJJdGVtKGlkLCBpbmRleCwgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5yZWdpc3Rlckl0ZW0oaWQsIGluZGV4LCBkaXNhYmxlZCk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJJdGVtKGlkLCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZShpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVQYXJlbnQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwudW5yZWdpc3Rlckl0ZW0oaWQsIGluZGV4KTtcbiAgICB9XG4gICAgbW92ZShlKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXZpZ2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb3ZlQWN0aW9uID0gdGhpcy5hY3Rpb25zW2Uua2V5Q29kZV07XG4gICAgICAgIGlmICghbW92ZUFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVBY3Rpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBleHBhbmQoeyBleHBhbmQsIGludGVyY2VwdCB9KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbm9kZUluZGV4KHRoaXMuYWN0aXZlSXRlbSk7XG4gICAgICAgIGlmICghaW5kZXggfHwgaW50ZXJjZXB0KGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5RXhwYW5kKGV4cGFuZCk7XG4gICAgfVxuICAgIG1vdmVUb1BhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVFeHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUodGhpcy5tb2RlbC5maW5kUGFyZW50KG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlVG9DaGlsZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlRXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2YXRlKHRoaXMubW9kZWwuZmluZENoaWxkKG5vZGVJbmRleCh0aGlzLmFjdGl2ZUl0ZW0pKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub3RpZnlFeHBhbmQoZXhwYW5kKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kcy5uZXh0KHRoaXMubmF2aWdhdGlvblN0YXRlKGV4cGFuZCkpO1xuICAgIH1cbiAgICBub3RpZnlNb3ZlKCkge1xuICAgICAgICB0aGlzLm1vdmVzLm5leHQodGhpcy5uYXZpZ2F0aW9uU3RhdGUoKSk7XG4gICAgfVxuICAgIG5hdmlnYXRpb25TdGF0ZShleHBhbmQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gKHsgZXhwYW5kLCBpbmRleDogbm9kZUluZGV4KHRoaXMuYWN0aXZlSXRlbSksIGlzRm9jdXNlZDogdGhpcy5pc0ZvY3VzZWQgfSk7XG4gICAgfVxufVxuTmF2aWdhdGlvblNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbk5hdmlnYXRpb25TZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTG9jYWxpemF0aW9uU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTm9kZUNoaWxkcmVuU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIGNoaWxkcmVuTG9hZGVkKGl0ZW0sIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHsgaXRlbSwgY2hpbGRyZW4gfSk7XG4gICAgfVxufVxuTm9kZUNoaWxkcmVuU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIFRyZWVWaWV3IG5vZGVzIChbbW9yZSBpbmZvcm1hdGlvbiBhbmQgZXhhbXBsZV0oeyUgc2x1ZyBub2RldGVtcGxhdGVfdHJlZXZpZXcgJX0pKS5cbiAqIFRoZSB0ZW1wbGF0ZSBoZWxwcyB0byBjdXN0b21pemUgdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGVzLiBUbyBkZWZpbmUgdGhlIG5vZGUgdGVtcGxhdGUsIG5lc3QgYW4gYDxuZy10ZW1wbGF0ZT5gXG4gKiB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZVZpZXdOb2RlVGVtcGxhdGVgIGRpcmVjdGl2ZSBpbnNpZGUgYSBgPGtlbmRvLXRyZWV2aWV3PmAgdGFnLlxuICpcbiAqXG4gKiBUaGUgbm9kZSBkYXRhIGl0ZW0gYW5kIGl0cyBoaWVyYXJjaGljYWwgaW5kZXggYXJlIGF2YWlsYWJsZSBhcyBjb250ZXh0IHZhcmlhYmxlczpcbiAqXG4gKiAtIGBsZXQtZGF0YUl0ZW1gIChgYW55YCkgLSBhdmFpbGFibGUgYXMgaW1wbGljaXQgY29udGV4dCB2YXJpYWJsZVxuICogLSBgbGV0LWluZGV4PVwiaW5kZXhcImAgKGBzdHJpbmdgKVxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqXG4gKiAgaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGtlbmRvLXRyZWV2aWV3XG4gKiAgICAgICAgICBbbm9kZXNdPVwiZGF0YVwiXG4gKiAgICAgICAgICBrZW5kb1RyZWVWaWV3RXhwYW5kYWJsZVxuICpcbiAqICAgICAgICAgIGtlbmRvVHJlZVZpZXdIaWVyYXJjaHlCaW5kaW5nXG4gKiAgICAgICAgICBjaGlsZHJlbkZpZWxkPVwiaXRlbXNcIj5cbiAqICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9UcmVlVmlld05vZGVUZW1wbGF0ZSBsZXQtZGF0YUl0ZW0gbGV0LWluZGV4PVwiaW5kZXhcIj5cbiAqICAgICAgICAgIDxzcGFuIFtzdHlsZS5mb250V2VpZ2h0XT1cImRhdGFJdGVtLml0ZW1zID8gJ2JvbGRlcic6ICdub3JtYWwnIFwiPnt7IGluZGV4IH19OiB7eyBkYXRhSXRlbS50ZXh0IH19PC9zcGFuPlxuICogICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwva2VuZG8tdHJlZXZpZXc+XG4gKiAgICBgXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgICAgcHVibGljIGRhdGE6IGFueVtdID0gW1xuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIHRleHQ6IFwiSW5ib3hcIixcbiAqICAgICAgICAgICAgICBpdGVtczogW3sgdGV4dDogXCJSZWFkIE1haWxcIiB9XVxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICB0ZXh0OiBcIkRyYWZ0c1wiXG4gKiAgICAgICAgICB9LFxuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIHRleHQ6IFwiU2VhcmNoIEZvbGRlcnNcIixcbiAqICAgICAgICAgICAgICBpdGVtczogW1xuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiQ2F0ZWdvcml6ZWQgTWFpbFwiIH0sXG4gKiAgICAgICAgICAgICAgICAgIHsgdGV4dDogXCJMYXJnZSBNYWlsXCIgfSxcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIlVucmVhZCBNYWlsXCJ9XG4gKiAgICAgICAgICAgICAgXVxuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIHsgdGV4dDogXCJTZXR0aW5nc1wiIH1cbiAqICAgICAgXTtcbiAqICB9XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn1cbk5vZGVUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdOb2RlVGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Ob2RlVGVtcGxhdGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlbGVjdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBpc0ZpcnN0U2VsZWN0ZWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RJbmRleCA9PT0gaW5kZXg7XG4gICAgfVxuICAgIHNldEZpcnN0U2VsZWN0ZWQoaW5kZXgsIHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0SW5kZXggPT09IGluZGV4ICYmIHNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdEluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5maXJzdEluZGV4ICYmIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3QoaW5kZXgsIGRhdGFJdGVtKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5uZXh0KHsgZGF0YUl0ZW0sIGluZGV4IH0pO1xuICAgIH1cbn1cblNlbGVjdGlvblNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG5cbmNvbnN0IElOREVYX1JFR0VYID0gL1xcZCskLztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUcmVlVmlld0xvb2t1cFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJJdGVtKGl0ZW0sIHBhcmVudCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TG9va3VwID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5pdGVtKG5vZGVJbmRleChwYXJlbnQpKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcC5zZXQoaXRlbS5pbmRleCwgY3VycmVudExvb2t1cCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2hpbGRyZW4oaW5kZXgsIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW0oaW5kZXgpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuICAgIHVucmVnaXN0ZXJJdGVtKGluZGV4LCBkYXRhSXRlbSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5pdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pdGVtLmRhdGFJdGVtID09PSBkYXRhSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnBhcmVudCAmJiBjdXJyZW50LnBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucGFyZW50LmNoaWxkcmVuID0gY3VycmVudC5wYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGl0ZW0gPT4gaXRlbS5kYXRhSXRlbSAhPT0gZGF0YUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VJdGVtKGluZGV4LCBpdGVtLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnJlZ2lzdGVySXRlbShpbmRleCwgaXRlbS5kYXRhSXRlbSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtKGl0ZW0sIHBhcmVudCk7XG4gICAgICAgIHRoaXMuYWRkVG9QYXJlbnQoaXRlbSwgcGFyZW50KTtcbiAgICB9XG4gICAgaXRlbUxvb2t1cChpbmRleCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMubWFwQ2hpbGRyZW4oaXRlbS5jaGlsZHJlbiksXG4gICAgICAgICAgICBpdGVtOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICBwYXJlbnQ6IGl0ZW0ucGFyZW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIGhhc0l0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhpbmRleCk7XG4gICAgfVxuICAgIGl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChpbmRleCkgfHwgbnVsbDtcbiAgICB9XG4gICAgYWRkVG9QYXJlbnQoaXRlbSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSB0aGlzLml0ZW0ocGFyZW50LmluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoSU5ERVhfUkVHRVguZXhlYyhpdGVtLmluZGV4KVswXSwgMTApO1xuICAgICAgICAgICAgcGFyZW50SXRlbS5jaGlsZHJlbiA9IHBhcmVudEl0ZW0uY2hpbGRyZW4gfHwgW107XG4gICAgICAgICAgICBwYXJlbnRJdGVtLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4ubWFwKGMgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpdGVtLCBwYXJlbnQsIGNoaWxkcmVuIH0gPSB0aGlzLml0ZW0oYy5pbmRleCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLm1hcENoaWxkcmVuKGNoaWxkcmVuKSxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuVHJlZVZpZXdMb29rdXBTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuXG5jb25zdCBwcm92aWRlcnMgPSBbXG4gICAgRXhwYW5kU3RhdGVTZXJ2aWNlLFxuICAgIEluZGV4QnVpbGRlclNlcnZpY2UsXG4gICAgVHJlZVZpZXdMb29rdXBTZXJ2aWNlLFxuICAgIExvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlLFxuICAgIE5vZGVDaGlsZHJlblNlcnZpY2UsXG4gICAgTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgU2VsZWN0aW9uU2VydmljZSxcbiAgICBEYXRhQ2hhbmdlTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgIHVzZVZhbHVlOiAna2VuZG8udHJlZXZpZXcnXG4gICAgfVxuXTtcbi8qIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZyAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgVHJlZVZpZXcgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3RyZWV2aWV3ICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogeyUgbWV0YSBoZWlnaHQ6MzUwICV9XG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAgX0BDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxrZW5kby10cmVldmlld1xuICogICAgICAgICAgW25vZGVzXT1cImRhdGFcIlxuICogICAgICAgICAgdGV4dEZpZWxkPVwidGV4dFwiXG4gKiAgICAgICAgICBrZW5kb1RyZWVWaWV3Q2hlY2thYmxlXG4gKiAgICAgICAgICBrZW5kb1RyZWVWaWV3RXhwYW5kYWJsZVxuICogICAgICAgICAga2VuZG9UcmVlVmlld1NlbGVjdGFibGVcbiAqXG4gKiAgICAgICAgICBrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ1xuICogICAgICAgICAgY2hpbGRyZW5GaWVsZD1cIml0ZW1zXCI+XG4gKiAgICAgIDwva2VuZG8tdHJlZXZpZXc+XG4gKiAgYFxuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgICAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICB0ZXh0OiBcIkZ1cm5pdHVyZVwiLCBpdGVtczogW1xuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiVGFibGVzICYgQ2hhaXJzXCIgfSxcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIlNvZmFzXCIgfSxcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIk9jY2FzaW9uYWwgRnVybml0dXJlXCIgfVxuICogICAgICAgICAgICAgIF1cbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgdGV4dDogXCJEZWNvclwiLCBpdGVtczogW1xuICogICAgICAgICAgICAgICAgICB7IHRleHQ6IFwiQmVkIExpbmVuXCIgfSxcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIkN1cnRhaW5zICYgQmxpbmRzXCIgfSxcbiAqICAgICAgICAgICAgICAgICAgeyB0ZXh0OiBcIkNhcnBldHNcIiB9XG4gKiAgICAgICAgICAgICAgXVxuICogICAgICAgICAgfVxuICogICAgICBdO1xuICogIH1cbiAqIGBgYFxuICogeyUgZW5kbWV0YSAlfVxuICovXG5jbGFzcyBUcmVlVmlld0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgZXhwYW5kU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIG5vZGVDaGlsZHJlblNlcnZpY2UsIHNlbGVjdGlvblNlcnZpY2UsIHRyZWVWaWV3TG9va3VwU2VydmljZSwgbmdab25lLCByZW5kZXJlciwgZGF0YUNoYW5nZU5vdGlmaWNhdGlvbiwgbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXhwYW5kU2VydmljZSA9IGV4cGFuZFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ub2RlQ2hpbGRyZW5TZXJ2aWNlID0gbm9kZUNoaWxkcmVuU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UgPSB0cmVlVmlld0xvb2t1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZU5vdGlmaWNhdGlvbiA9IGRhdGFDaGFuZ2VOb3RpZmljYXRpb247XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnJvbGUgPSAndHJlZSc7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuZmV0Y2hOb2RlcyA9ICgpID0+IHRoaXMuZGF0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGNoaWxkcmVuIG9mIHRoZSBleHBhbmRlZCBub2RlIGFyZSBsb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuTG9hZGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBibHVycyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGZvY3VzZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgZXhwYW5kcyBhIFRyZWVWaWV3IG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cGFuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY29sbGFwc2VzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBqdXN0IGJlZm9yZSB0aGUgZHJhZ2dpbmcgb2YgdGhlIG5vZGUgc3RhcnRzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZHJhZ2FuZGRyb3BfdHJlZXZpZXcgJX0jdG9jLXNldHVwKSkuIFRoaXMgZXZlbnQgaXMgcHJldmVudGFibGUuXG4gICAgICAgICAqIElmIHlvdSBwcmV2ZW50IHRoZSBldmVudCBkZWZhdWx0LCBubyBkcmFnIGhpbnQgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgc3Vic2VxdWVudCBkcmFnLXJlbGF0ZWQgZXZlbnRzIHdpbGwgbm90IGJlIGZpcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlRHJhZ1N0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhbiBpdGVtIGlzIGJlaW5nIGRyYWdnZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2Mtc2V0dXApKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURyYWcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBvbiB0aGUgdGFyZ2V0IFRyZWVWaWV3IHdoZW4gYSBkcmFnZ2VkIGl0ZW0gaXMgZHJvcHBlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHByZXZlbnRhYmxlLiBJZiB5b3UgcHJldmVudCB0aGUgZXZlbnQgZGVmYXVsdCAoYGV2ZW50LnByZXZlbnREZWZ1YWx0KClgKSBvciBpbnZhbGlkYXRlIGl0cyBzdGF0ZSAoYGV2ZW50LnNldFZhbGlkKGZhbHNlKWApLFxuICAgICAgICAgKiB0aGUgYGFkZEl0ZW1gIGFuZCBgcmVtb3ZlSXRlbWAgZXZlbnRzIHdpbGwgbm90IGJlIHRyaWdnZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQm90aCBvcGVyYXRpb25zIGNhbmNlbCB0aGUgZGVmYXVsdCBkcm9wIG9wZXJhdGlvbiwgYnV0IHRoZSBpbmRpY2F0aW9uIHRvIHRoZSB1c2VyIGlzIGRpZmZlcmVudC4gYGV2ZW50LnNldFZhbGlkKGZhbHNlKWAgaW5kaWNhdGVzIHRoYXQgdGhlIG9wZXJhdGlvbiB3YXNcbiAgICAgICAgICogdW5zdWNjZXNzZnVsIGJ5IGFuaW1hdGluZyB0aGUgZHJhZyBjbHVlIHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbi4gYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIHNpbXBseSByZW1vdmVzIHRoZSBjbHVlLCBhcyBpZiBpdCBoYXMgYmVlbiBkcm9wcGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICogQXMgYSBnZW5lcmFsIHJ1bGUsIHVzZSBgcHJldmVudERlZmF1bHRgIHRvIG1hbnVhbGx5IGhhbmRsZSB0aGUgYWRkIGFuZCByZW1vdmUgb3BlcmF0aW9ucywgYW5kIGBzZXRWYWxpZChmYWxzZSlgIHRvIGluZGljYXRlIHRoZSBvcGVyYXRpb24gd2FzIHVuc3VjY2Vzc2Z1bC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURyb3AgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBvbiB0aGUgc291cmNlIFRyZWVWaWV3IGFmdGVyIHRoZSBkcmFnZ2VkIGl0ZW0gaGFzIGJlZW4gZHJvcHBlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlRHJhZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGFmdGVyIGEgZHJhZ2dlZCBpdGVtIGlzIGRyb3BwZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2Mtc2V0dXApKS5cbiAgICAgICAgICogQ2FsbGVkIG9uIHRoZSBUcmVlVmlldyB3aGVyZSB0aGUgaXRlbSBpcyBkcm9wcGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGRJdGVtID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgYSBkcmFnZ2VkIGl0ZW0gaXMgZHJvcHBlZCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1zZXR1cCkpLlxuICAgICAgICAgKiBDYWxsZWQgb24gdGhlIFRyZWVWaWV3IGZyb20gd2hlcmUgdGhlIGl0ZW0gaXMgZHJhZ2dlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIFRyZWVWaWV3IG5vZGUgY2hlY2tib3hcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjaGVja2JveGVzX3RyZWV2aWV3ICV9I3RvYy1tb2RpZnlpbmctdGhlLWNoZWNrZWQtc3RhdGUpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIFRyZWVWaWV3IG5vZGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fdHJlZXZpZXcgJX0jdG9jLW1vZGlmeWluZy10aGUtc2VsZWN0aW9uKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZUNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIGEgVHJlZVZpZXcgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9kZURibENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFRyZWVWaWV3IGtleWJvYXJkIG5hdmlnYWJsZSBpcyBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB3aGljaCBwcm92aWRlcyB0aGUgY2hpbGQgbm9kZXMgZm9yIGEgZ2l2ZW4gcGFyZW50IG5vZGVcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkYXRhYmluZGluZ190cmVldmlldyAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9ICgpID0+IG9mKFtdKTtcbiAgICAgICAgdGhpcy5jaGVja2JveGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhwYW5kSWNvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6YXRpb24ucnRsID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb250ZW50IGFuaW1hdGlvbiBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIHNldCBhbmltYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGFuaW1hdGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fYW5pbWF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5vZGVzIHdoaWNoIHdpbGwgYmUgZGlzcGxheWVkIGJ5IHRoZSBUcmVlVmlld1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZGF0YWJpbmRpbmdfdHJlZXZpZXcgJX0pKS5cbiAgICAgKi9cbiAgICBzZXQgbm9kZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uLm5vdGlmeSgpO1xuICAgICAgICB0aGlzLmRhdGEubmV4dCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBub2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBoYXMgY2hpbGQgbm9kZXNcbiAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRhdGFiaW5kaW5nX3RyZWV2aWV3ICV9KSkuXG4gICAgICovXG4gICAgZ2V0IGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzQ2hpbGRyZW4gfHwgaGFzQ2hpbGRyZW47XG4gICAgfVxuICAgIHNldCBoYXNDaGlsZHJlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9oYXNDaGlsZHJlbiA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4cGFuZEljb25zID0gQm9vbGVhbih0aGlzLl9pc0V4cGFuZGVkICYmIHRoaXMuX2hhc0NoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hlY2tib3hlc190cmVldmlldyAlfSN0b2MtbW9kaWZ5aW5nLXRoZS1jaGVja2VkLXN0YXRlKSkuXG4gICAgICovXG4gICAgZ2V0IGlzQ2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2hlY2tlZCB8fCBpc0NoZWNrZWQ7XG4gICAgfVxuICAgIHNldCBpc0NoZWNrZWQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faXNDaGVja2VkID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY2hlY2tib3hlcyA9IEJvb2xlYW4odGhpcy5faXNDaGVja2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBleHBhbmRlZC5cbiAgICAgKi9cbiAgICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRXhwYW5kZWQgfHwgaXNFeHBhbmRlZDtcbiAgICB9XG4gICAgc2V0IGlzRXhwYW5kZWQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5faXNFeHBhbmRlZCA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmV4cGFuZEljb25zID0gQm9vbGVhbih0aGlzLl9pc0V4cGFuZGVkICYmIHRoaXMuX2hhc0NoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgc3BlY2lmaWMgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2VsZWN0aW9uX3RyZWV2aWV3ICV9I3RvYy1tb2RpZnlpbmctdGhlLXNlbGVjdGlvbikpLlxuICAgICAqL1xuICAgIGdldCBpc1NlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RlZCB8fCBpc1NlbGVjdGVkO1xuICAgIH1cbiAgICBzZXQgaXNTZWxlY3RlZChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKF8pIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5uYXZpZ2FibGUgPSBCb29sZWFuKHRoaXMubmF2aWdhYmxlKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4gc3Vic2NyaXB0aW9uKCkpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5vZGVDaGlsZHJlblNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh4KSA9PiB0aGlzLmNoaWxkcmVuTG9hZGVkLmVtaXQoeCkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLmV4cGFuZFNlcnZpY2UuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBpbmRleCwgZGF0YUl0ZW0sIGV4cGFuZCB9KSA9PiBleHBhbmRcbiAgICAgICAgICAgID8gdGhpcy5leHBhbmQuZW1pdCh7IGluZGV4LCBkYXRhSXRlbSB9KVxuICAgICAgICAgICAgOiB0aGlzLmNvbGxhcHNlLmVtaXQoeyBpbmRleCwgZGF0YUl0ZW0gfSkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNoZWNrc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeCkgPT4gdGhpcy5jaGVja2VkQ2hhbmdlLmVtaXQodGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UuaXRlbUxvb2t1cCh4KSkpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnNlbGVjdGlvblNlcnZpY2UuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgoeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnNlbGVjdGlvbkNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaERvbUhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbHVycyB0aGUgZm9jdXNlZCBUcmVlVmlldyBpdGVtLlxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZm9jdXNhYmxlTm9kZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGZpcnN0IGZvY3VzYWJsZSBpdGVtIGluIHRoZSBUcmVlVmlldyBjb21wb25lbnQgaWYgbm8gaGllcmFyY2hpY2FsIGluZGV4IGlzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqXG4gICAgICogIEBDb21wb25lbnQoe1xuICAgICAqICAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAqICAgICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgIDxidXR0b24gKGNsaWNrKT1cInRyZWV2aWV3LmZvY3VzKCcxJylcIj5Gb2N1c2VzIHRoZSBzZWNvbmQgbm9kZTwvYnV0dG9uPlxuICAgICAqICAgICAgPGtlbmRvLXRyZWV2aWV3XG4gICAgICogICAgICAgICAgI3RyZWV2aWV3XG4gICAgICogICAgICAgICAgW25vZGVzXT1cImRhdGFcIlxuICAgICAqICAgICAgICAgIHRleHRGaWVsZD1cInRleHRcIlxuICAgICAqICAgICAgPlxuICAgICAqICAgICAgPC9rZW5kby10cmVldmlldz5cbiAgICAgKiAgYFxuICAgICAqICB9KVxuICAgICAqICBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgKiAgICAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtcbiAgICAgKiAgICAgICAgICB7IHRleHQ6IFwiRnVybml0dXJlXCIgfSxcbiAgICAgKiAgICAgICAgICB7IHRleHQ6IFwiRGVjb3JcIiB9XG4gICAgICogICAgICBdO1xuICAgICAqICB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZm9jdXMoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hY3RpdmF0ZUluZGV4KGluZGV4KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZm9jdXNhYmxlTm9kZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGluZGV4LCByZXR1cm5zIHRoZSBUcmVlSXRlbUxvb2t1cCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBub2RlLlxuICAgICAqIEByZXR1cm5zIHtUcmVlSXRlbUxvb2t1cH0gLSBUaGUgaXRlbSB0aGF0IHdhcyBzZWFyY2hlZCAobG9va2VkIHVwKS5cbiAgICAgKi9cbiAgICBpdGVtTG9va3VwKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVWaWV3TG9va3VwU2VydmljZS5pdGVtTG9va3VwKGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGlzRGlzYWJsZWROb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaXNEaXNhYmxlZChub2RlLml0ZW0uaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgYGV4cGFuZGAgZXZlbnQgZm9yIHRoZSBwcm92aWRlZCBub2RlIGFuZCBkaXNwbGF5cyBpdCdzIGxvYWRpbmcgaW5kaWNhdG9yLlxuICAgICAqL1xuICAgIGV4cGFuZE5vZGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZChpbmRleCwgaXRlbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBgY29sbGFwc2VgIGV2ZW50IGZvciB0aGUgcHJvdmlkZWQgbm9kZS5cbiAgICAgKi9cbiAgICBjb2xsYXBzZU5vZGUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmNvbGxhcHNlKGluZGV4LCBpdGVtKTtcbiAgICB9XG4gICAgYXR0YWNoRG9tSGFuZGxlcnMoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5jbGlja0hhbmRsZXIgPSB0aGlzLmNsaWNrSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnY29udGV4dG1lbnUnLCB0aGlzLmNsaWNrSGFuZGxlciksIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyKSwgdGhpcy5yZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2RibGNsaWNrJywgdGhpcy5jbGlja0hhbmRsZXIpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXNpbicsIHRoaXMuZm9jdXNIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXNvdXQnLCB0aGlzLmJsdXJIYW5kbGVyLmJpbmQodGhpcykpLCB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICBmb2N1c0hhbmRsZXIoZSkge1xuICAgICAgICBsZXQgZm9jdXNJdGVtO1xuICAgICAgICBpZiAobWF0Y2goZS50YXJnZXQsICcuay10cmVldmlldy1pdGVtJykpIHtcbiAgICAgICAgICAgIGZvY3VzSXRlbSA9IGUudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0ZvY3VzYWJsZShlLnRhcmdldCkpIHsgLy8gd2l0aCBjb21wbGltZW50cyB0byBJRVxuICAgICAgICAgICAgZm9jdXNJdGVtID0gY2xvc2VzdE5vZGUoZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb2N1c0l0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWN0aXZhdGVJbmRleChub2RlSWQoZS50YXJnZXQpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSAmJiBoYXNPYnNlcnZlcnModGhpcy5vbkZvY3VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibHVySGFuZGxlcihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlICYmIG1hdGNoKGUudGFyZ2V0LCAnLmstdHJlZXZpZXctaXRlbScpICYmXG4gICAgICAgICAgICAoIWUucmVsYXRlZFRhcmdldCB8fCAhbWF0Y2goZS5yZWxhdGVkVGFyZ2V0LCAnLmstdHJlZXZpZXctaXRlbScpIHx8ICFoYXNQYXJlbnQoZS5yZWxhdGVkVGFyZ2V0LCB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoYXNPYnNlcnZlcnModGhpcy5vbkJsdXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkJsdXIuZW1pdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsaWNrSGFuZGxlcihlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoKGUudHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiAhaGFzT2JzZXJ2ZXJzKHRoaXMubm9kZUNsaWNrKSkgfHxcbiAgICAgICAgICAgIChlLnR5cGUgPT09ICdjbGljaycgJiYgIWhhc09ic2VydmVycyh0aGlzLm5vZGVDbGljaykgJiYgIWhhc09ic2VydmVycyh0aGlzLnNlbGVjdGlvbkNoYW5nZSkpIHx8XG4gICAgICAgICAgICAoZS50eXBlID09PSAnZGJsY2xpY2snICYmICFoYXNPYnNlcnZlcnModGhpcy5ub2RlRGJsQ2xpY2spKSB8fCBpc0ZvY3VzYWJsZSh0YXJnZXQpIHx8XG4gICAgICAgICAgICAhaXNDb250ZW50KHRhcmdldCkgfHwgIWhhc1BhcmVudCh0YXJnZXQsIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbm9kZUlkKGNsb3Nlc3ROb2RlKHRhcmdldCkpO1xuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgY2hlY2sgaXMgcHJvYmFibHkgbm90IG5lZWRlZCBkdWUgdG8gdGhlIGstc3RhdGUtZGlzYWJsZWQgc3R5bGVzXG4gICAgICAgIGlmICghaW5kZXggfHwgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5pc0Rpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLnRyZWVWaWV3TG9va3VwU2VydmljZS5pdGVtTG9va3VwKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBlLnR5cGUgPT09ICdkYmxjbGljaycgPyB0aGlzLm5vZGVEYmxDbGljayA6IHRoaXMubm9kZUNsaWNrO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KHtcbiAgICAgICAgICAgICAgICBpdGVtOiBsb29rdXAuaXRlbSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGUudHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlkb3duSGFuZGxlcihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlICYmIHRoaXMubmF2aWdhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UubW92ZShlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuVHJlZVZpZXdDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1RyZWVWaWV3JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWV2aWV3JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dWwgY2xhc3M9XCJrLXRyZWV2aWV3LWxpbmVzXCJcbiAgICAgICAgICAgIGtlbmRvVHJlZVZpZXdHcm91cFxuICAgICAgICAgICAgcm9sZT1cImdyb3VwXCJcbiAgICAgICAgICAgIFtjaGVja2JveGVzXT1cImNoZWNrYm94ZXNcIlxuICAgICAgICAgICAgW2V4cGFuZEljb25zXT1cImV4cGFuZEljb25zXCJcbiAgICAgICAgICAgIFt0b3VjaEFjdGlvbnNdPVwidG91Y2hBY3Rpb25zXCJcbiAgICAgICAgICAgIFtjaGlsZHJlbl09XCJjaGlsZHJlblwiXG4gICAgICAgICAgICBbaGFzQ2hpbGRyZW5dPVwiaGFzQ2hpbGRyZW5cIlxuICAgICAgICAgICAgW2lzQ2hlY2tlZF09XCJpc0NoZWNrZWRcIlxuICAgICAgICAgICAgW2lzRGlzYWJsZWRdPVwiaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICBbaXNFeHBhbmRlZF09XCJpc0V4cGFuZGVkXCJcbiAgICAgICAgICAgIFtpc1NlbGVjdGVkXT1cImlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgW25vZGVUZW1wbGF0ZVJlZl09XCJub2RlVGVtcGxhdGU/LnRlbXBsYXRlUmVmXCJcbiAgICAgICAgICAgIFt0ZXh0RmllbGRdPVwidGV4dEZpZWxkXCJcbiAgICAgICAgICAgIFtub2Rlc109XCJmZXRjaE5vZGVzXCJcbiAgICAgICAgPlxuICAgICAgICA8L3VsPlxuICAgICAgICA8bmctY29udGFpbmVyICNhc3NldHNDb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UcmVlVmlld0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IEV4cGFuZFN0YXRlU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5vZGVDaGlsZHJlblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNlbGVjdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFRyZWVWaWV3TG9va3VwU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IERhdGFDaGFuZ2VOb3RpZmljYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2NhbGl6YXRpb25TZXJ2aWNlIH1cbl07XG5UcmVlVmlld0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjbGFzc05hbWVzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogW1wiY2xhc3Muay13aWRnZXRcIixdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFtcImNsYXNzLmstdHJlZXZpZXdcIixdIH1dLFxuICAgIHJvbGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbXCJhdHRyLnJvbGVcIixdIH1dLFxuICAgIGRpcmVjdGlvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFtcImF0dHIuZGlyXCIsXSB9XSxcbiAgICBhc3NldHNDb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydhc3NldHNDb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgYW5pbWF0ZTogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydALmRpc2FibGVkJyxdIH1dLFxuICAgIGNoaWxkcmVuTG9hZGVkOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgb25CbHVyOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnYmx1cicsXSB9XSxcbiAgICBvbkZvY3VzOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnZm9jdXMnLF0gfV0sXG4gICAgZXhwYW5kOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgY29sbGFwc2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBub2RlRHJhZ1N0YXJ0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgbm9kZURyYWc6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBub2RlRHJvcDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG5vZGVEcmFnRW5kOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgYWRkSXRlbTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHJlbW92ZUl0ZW06IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBjaGVja2VkQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc2VsZWN0aW9uQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgbm9kZUNsaWNrOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgbm9kZURibENsaWNrOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgbm9kZVRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtOb2RlVGVtcGxhdGVEaXJlY3RpdmUsXSB9XSxcbiAgICBub2RlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGV4dEZpZWxkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoYXNDaGlsZHJlbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNDaGVja2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc0Rpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc0V4cGFuZGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc1NlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBuYXZpZ2FibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFRyZWVWaWV3R3JvdXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGV4cGFuZFNlcnZpY2UsIGxvYWRpbmdTZXJ2aWNlLCBpbmRleEJ1aWxkZXIsIHRyZWVWaWV3TG9va3VwU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2UsIG5vZGVDaGlsZHJlblNlcnZpY2UsIGRhdGFDaGFuZ2VOb3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2VydmljZSA9IGxvYWRpbmdTZXJ2aWNlO1xuICAgICAgICB0aGlzLmluZGV4QnVpbGRlciA9IGluZGV4QnVpbGRlcjtcbiAgICAgICAgdGhpcy50cmVlVmlld0xvb2t1cFNlcnZpY2UgPSB0cmVlVmlld0xvb2t1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ub2RlQ2hpbGRyZW5TZXJ2aWNlID0gbm9kZUNoaWxkcmVuU2VydmljZTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlTm90aWZpY2F0aW9uID0gZGF0YUNoYW5nZU5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5rR3JvdXBDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50ZXh0RmllbGQgPSBcIlwiO1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgIHRoaXMuaXNDaGVja2VkID0gKCkgPT4gJ25vbmUnO1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9ICgpID0+IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gKCkgPT4gb2YoW10pO1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICAgIGdldCByb2xlKCkgeyByZXR1cm4gJ2dyb3VwJzsgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgY29uc3QgbWFwcGVkQ2hpbGRyZW4gPSB0aGlzLm1hcFRvVHJlZUl0ZW0oZGF0YSk7XG4gICAgICAgIHRoaXMuc2V0Tm9kZUNoaWxkcmVuKG1hcHBlZENoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5lbWl0Q2hpbGRyZW5Mb2FkZWQobWFwcGVkQ2hpbGRyZW4pO1xuICAgIH1cbiAgICBnZXQgaGFzVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ub2RlVGVtcGxhdGVSZWYpO1xuICAgIH1cbiAgICBleHBhbmROb2RlKGluZGV4LCBkYXRhSXRlbSwgZXhwYW5kKSB7XG4gICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmQoaW5kZXgsIGRhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5jb2xsYXBzZShpbmRleCwgZGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTm9kZShpbmRleCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNoZWNrSW5kZXgoaW5kZXgpO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmFjdGl2YXRlSW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgICBub2RlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhCdWlsZGVyLm5vZGVJbmRleChpbmRleC50b1N0cmluZygpLCB0aGlzLnBhcmVudEluZGV4KTtcbiAgICB9XG4gICAgbm9kZVRleHQoZGF0YUl0ZW0pIHtcbiAgICAgICAgY29uc3QgdGV4dEZpZWxkID0gaXNBcnJheSh0aGlzLnRleHRGaWVsZCkgPyB0aGlzLnRleHRGaWVsZFswXSA6IHRoaXMudGV4dEZpZWxkO1xuICAgICAgICByZXR1cm4gZ2V0dGVyKHRleHRGaWVsZCkoZGF0YUl0ZW0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb05vZGVzQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMuZGF0YUNoYW5nZU5vdGlmaWNhdGlvblxuICAgICAgICAgICAgLmNoYW5nZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5zdWJzY3JpYmVUb05vZGVzQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNldE5vZGVDaGlsZHJlbih0aGlzLm1hcFRvVHJlZUl0ZW0odGhpcy5kYXRhKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hDaGlsZHJlbihub2RlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbihub2RlKVxuICAgICAgICAgICAgLnBpcGUoY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTZXJ2aWNlLm5vdGlmeUxvYWRlZChpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgIH0pLCB0YXAoKCkgPT4gdGhpcy5sb2FkaW5nU2VydmljZS5ub3RpZnlMb2FkZWQoaW5kZXgpKSk7XG4gICAgfVxuICAgIGdldCBuZXh0RmllbGRzKCkge1xuICAgICAgICBpZiAoaXNBcnJheSh0aGlzLnRleHRGaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRGaWVsZC5sZW5ndGggPiAxID8gdGhpcy50ZXh0RmllbGQuc2xpY2UoMSkgOiB0aGlzLnRleHRGaWVsZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMudGV4dEZpZWxkXTtcbiAgICB9XG4gICAgc2V0Tm9kZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMudHJlZVZpZXdMb29rdXBTZXJ2aWNlLnJlZ2lzdGVyQ2hpbGRyZW4odGhpcy5wYXJlbnRJbmRleCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBtYXBUb1RyZWVJdGVtKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEubWFwKChkYXRhSXRlbSwgaWR4KSA9PiAoeyBkYXRhSXRlbSwgaW5kZXg6IHRoaXMubm9kZUluZGV4KGlkeCkgfSkpO1xuICAgIH1cbiAgICBlbWl0Q2hpbGRyZW5Mb2FkZWQoY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlQ2hpbGRyZW5TZXJ2aWNlLmNoaWxkcmVuTG9hZGVkKHsgZGF0YUl0ZW06IHRoaXMucGFyZW50RGF0YUl0ZW0sIGluZGV4OiB0aGlzLnBhcmVudEluZGV4IH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlVG9Ob2Rlc0NoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVzU3Vic2NyaXB0aW9uID0gdGhpcy5ub2Rlcyh0aGlzLnBhcmVudERhdGFJdGVtLCB0aGlzLnBhcmVudEluZGV4KS5zdWJzY3JpYmUoeCA9PiB7IHRoaXMuZGF0YSA9IHg7IH0pO1xuICAgIH1cbn1cblRyZWVWaWV3R3JvdXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3RvZ2dsZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IGhlaWdodDogMCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCcwLjFzIGVhc2UtaW4nLCBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnMC4xcyBlYXNlLWluJywgc3R5bGUoeyBoZWlnaHQ6IDAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0dyb3VwXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGxpXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgbm9kZSBvZiBkYXRhOyBsZXQgaW5kZXggPSBpbmRleFwiIGNsYXNzPVwiay1pdGVtIGstdHJlZXZpZXctaXRlbVwiXG4gICAgICAgICAgICBrZW5kb1RyZWVWaWV3SXRlbVxuICAgICAgICAgICAgW2RhdGFJdGVtXT1cIm5vZGVcIlxuICAgICAgICAgICAgW2luZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgW3BhcmVudERhdGFJdGVtXT1cInBhcmVudERhdGFJdGVtXCJcbiAgICAgICAgICAgIFtwYXJlbnRJbmRleF09XCJwYXJlbnRJbmRleFwiXG4gICAgICAgICAgICBbaXNDaGVja2VkXT1cImlzQ2hlY2tlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICBbaXNEaXNhYmxlZF09XCJkaXNhYmxlZCB8fCBpc0Rpc2FibGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgIFtpc0V4cGFuZGVkXT1cImlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgW2lzU2VsZWN0ZWRdPVwiaXNTZWxlY3RlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXRyZWVpbmRleF09XCJub2RlSW5kZXgoaW5kZXgpXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImstbWlkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJrLWljb25cIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWNvbGxhcHNlXT1cImlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSlcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3Muay1pLWV4cGFuZF09XCIhaXNFeHBhbmRlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICAgICAgICAgIFtrZW5kb1RyZWVWaWV3TG9hZGluZ109XCJub2RlSW5kZXgoaW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImV4cGFuZE5vZGUobm9kZUluZGV4KGluZGV4KSwgbm9kZSwgIWlzRXhwYW5kZWQobm9kZSwgbm9kZUluZGV4KGluZGV4KSkpXCJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJleHBhbmRJY29ucyAmJiBoYXNDaGlsZHJlbihub2RlKVwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGtlbmRvLWNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiY2hlY2tib3hlc1wiXG4gICAgICAgICAgICAgICAgICAgIFtub2RlXT1cIm5vZGVcIlxuICAgICAgICAgICAgICAgICAgICBbaW5kZXhdPVwibm9kZUluZGV4KGluZGV4KVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc0NoZWNrZWRdPVwiaXNDaGVja2VkXCJcbiAgICAgICAgICAgICAgICAgICAgKGNoZWNrU3RhdGVDaGFuZ2UpPVwiY2hlY2tOb2RlKG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgPjwva2VuZG8tY2hlY2tib3g+XG4gICAgICAgICAgICAgICAgPHNwYW4ga2VuZG9UcmVlVmlld0l0ZW1Db250ZW50XG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtdHJlZWluZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YUl0ZW1dPVwibm9kZVwiXG4gICAgICAgICAgICAgICAgICAgIFtpbmRleF09XCJub2RlSW5kZXgoaW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgW2luaXRpYWxTZWxlY3Rpb25dPVwiaXNTZWxlY3RlZChub2RlLCBub2RlSW5kZXgoaW5kZXgpKVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc1NlbGVjdGVkXT1cImlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImstaW5cIlxuICAgICAgICAgICAgICAgICAgICBbc3R5bGUudG91Y2gtYWN0aW9uXT1cInRvdWNoQWN0aW9ucyA/ICcnIDogJ25vbmUnXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cImhhc1RlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vZGVUZW1wbGF0ZVJlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBub2RlLCBpbmRleDogbm9kZUluZGV4KGluZGV4KX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hEZWZhdWx0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bm9kZVRleHQobm9kZSl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHVsXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJpc0V4cGFuZGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpICYmIGhhc0NoaWxkcmVuKG5vZGUpXCJcbiAgICAgICAgICAgICAgICBrZW5kb1RyZWVWaWV3R3JvdXBcbiAgICAgICAgICAgICAgICByb2xlPVwiZ3JvdXBcIlxuICAgICAgICAgICAgICAgIFtub2Rlc109XCJmZXRjaENoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICBbY2hlY2tib3hlc109XCJjaGVja2JveGVzXCJcbiAgICAgICAgICAgICAgICBbZXhwYW5kSWNvbnNdPVwiZXhwYW5kSWNvbnNcIlxuICAgICAgICAgICAgICAgIFt0b3VjaEFjdGlvbnNdPVwidG91Y2hBY3Rpb25zXCJcbiAgICAgICAgICAgICAgICBbY2hpbGRyZW5dPVwiY2hpbGRyZW5cIlxuICAgICAgICAgICAgICAgIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiXG4gICAgICAgICAgICAgICAgW2lzQ2hlY2tlZF09XCJpc0NoZWNrZWRcIlxuICAgICAgICAgICAgICAgIFtpc0Rpc2FibGVkXT1cImlzRGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZCB8fCBpc0Rpc2FibGVkKG5vZGUsIG5vZGVJbmRleChpbmRleCkpXCJcbiAgICAgICAgICAgICAgICBbaXNFeHBhbmRlZF09XCJpc0V4cGFuZGVkXCJcbiAgICAgICAgICAgICAgICBbaXNTZWxlY3RlZF09XCJpc1NlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICBbbm9kZVRlbXBsYXRlUmVmXT1cIm5vZGVUZW1wbGF0ZVJlZlwiXG4gICAgICAgICAgICAgICAgW3BhcmVudEluZGV4XT1cIm5vZGVJbmRleChpbmRleClcIlxuICAgICAgICAgICAgICAgIFtwYXJlbnREYXRhSXRlbV09XCJub2RlXCJcbiAgICAgICAgICAgICAgICBbdGV4dEZpZWxkXT1cIm5leHRGaWVsZHNcIlxuICAgICAgICAgICAgICAgIFtAdG9nZ2xlXT1cInRydWVcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvbGk+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5UcmVlVmlld0dyb3VwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRXhwYW5kU3RhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBMb2FkaW5nTm90aWZpY2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogSW5kZXhCdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogVHJlZVZpZXdMb29rdXBTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYXZpZ2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogTm9kZUNoaWxkcmVuU2VydmljZSB9LFxuICAgIHsgdHlwZTogRGF0YUNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UgfVxuXTtcblRyZWVWaWV3R3JvdXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAga0dyb3VwQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbXCJjbGFzcy5rLWdyb3VwXCIsXSB9XSxcbiAgICByb2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogW1wiYXR0ci5yb2xlXCIsXSB9XSxcbiAgICBjaGVja2JveGVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBleHBhbmRJY29uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvdWNoQWN0aW9uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbm9kZXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRleHRGaWVsZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFyZW50RGF0YUl0ZW06IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhcmVudEluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBub2RlVGVtcGxhdGVSZWY6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzQ2hlY2tlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNEaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNFeHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNTZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hpbGRyZW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhhc0NoaWxkcmVuOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuY29uc3QgaW5kZXhDaGVja2VkID0gKGtleXMsIGluZGV4KSA9PiBrZXlzLmZpbHRlcihrID0+IGsgPT09IGluZGV4KS5sZW5ndGggPiAwO1xuY29uc3QgbWF0Y2hLZXkgPSBpbmRleCA9PiBrID0+IHtcbiAgICBpZiAoaW5kZXggPT09IGspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghay5zcGxpdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrLnNwbGl0KCdfJykucmVkdWNlKCh7IGtleSwgcmVzdWx0IH0sIHBhcnQpID0+IHtcbiAgICAgICAga2V5ICs9IHBhcnQ7XG4gICAgICAgIGlmIChpbmRleCA9PT0ga2V5IHx8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAga2V5ICs9IFwiX1wiO1xuICAgICAgICByZXR1cm4geyBrZXksIHJlc3VsdDogZmFsc2UgfTtcbiAgICB9LCB7IGtleTogXCJcIiwgcmVzdWx0OiBmYWxzZSB9KS5yZXN1bHQ7XG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBtYW5hZ2VzIHRoZSBpbi1tZW1vcnkgY2hlY2tlZCBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcgbm9kZVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjaGVja2JveGVzX3RyZWV2aWV3ICV9KSkuXG4gKi9cbmNsYXNzIENoZWNrRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlVmlldywgem9uZSkge1xuICAgICAgICB0aGlzLnRyZWVWaWV3ID0gdHJlZVZpZXc7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgY2hlY2tlZEtleXNgIGNvbGxlY3Rpb24gd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBY3Rpb25zID0ge1xuICAgICAgICAgICAgJ211bHRpcGxlJzogKGUpID0+IHRoaXMuY2hlY2tNdWx0aXBsZShlKSxcbiAgICAgICAgICAgICdzaW5nbGUnOiAoZSkgPT4gdGhpcy5jaGVja1NpbmdsZShlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGVja2VkS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZVZpZXcuY2hlY2tlZENoYW5nZVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4gdGhpcy5jaGVjayhlKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZVZpZXcuY2hpbGRyZW5Mb2FkZWRcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLm9wdGlvbnMuY2hlY2tDaGlsZHJlbiksIHN3aXRjaE1hcChlID0+IHRoaXMuem9uZS5vblN0YWJsZS5waXBlKHRha2UoMSksIG1hcCgoKSA9PiBlKSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZSkgPT4gdGhpcy5hZGRDaGlsZHJlbktleXMoZSkpKTtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0NoZWNrZWQgPSB0aGlzLmlzSXRlbUNoZWNrZWQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBpc0NoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0NoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgY29sbGVjdGlvbiB0aGF0IHdpbGwgc3RvcmUgdGhlIGNoZWNrZWQga2V5c1xuICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hlY2tib3hlc190cmVldmlldyAlfSkpLlxuICAgICAqL1xuICAgIGdldCBjaGVja2VkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWRLZXlzO1xuICAgIH1cbiAgICBzZXQgY2hlY2tlZEtleXMoa2V5cykge1xuICAgICAgICB0aGlzLl9jaGVja2VkS2V5cyA9IGtleXM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNoZWNrQ2hpbGRyZW46IHRydWUsXG4gICAgICAgICAgICBjaGVja1BhcmVudHM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogXCJtdWx0aXBsZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMuY2hlY2thYmxlKSB8fCB0eXBlb2YgdGhpcy5jaGVja2FibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gdHlwZW9mIHRoaXMuY2hlY2thYmxlID09PSAnYm9vbGVhbic7XG4gICAgICAgIGNvbnN0IGNoZWNrU2V0dGluZ3MgPSBpc0Jvb2xlYW5cbiAgICAgICAgICAgID8geyBlbmFibGVkOiB0aGlzLmNoZWNrYWJsZSB9XG4gICAgICAgICAgICA6IHRoaXMuY2hlY2thYmxlO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgY2hlY2tTZXR0aW5ncyk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuY2hlY2thYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3LmNoZWNrYm94ZXMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2hlY2tPbkNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICB9XG4gICAgaXNJdGVtQ2hlY2tlZChkYXRhSXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0luZGV4Q2hlY2tlZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5SW5kZXggPSB0aGlzLmNoZWNrZWRLZXlzLmluZGV4T2YodGhpcy5pdGVtS2V5KHsgZGF0YUl0ZW0sIGluZGV4IH0pKTtcbiAgICAgICAgcmV0dXJuIGtleUluZGV4ID4gLTEgPyAnY2hlY2tlZCcgOiAnbm9uZSc7XG4gICAgfVxuICAgIGlzSW5kZXhDaGVja2VkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRLZXlzID0gdGhpcy5jaGVja2VkS2V5cy5maWx0ZXIobWF0Y2hLZXkoaW5kZXgpKTtcbiAgICAgICAgaWYgKGluZGV4Q2hlY2tlZChjaGVja2VkS2V5cywgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NoZWNrZWQnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbW9kZSwgY2hlY2tQYXJlbnRzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChtb2RlID09PSAnbXVsdGlwbGUnICYmIGNoZWNrUGFyZW50cyAmJiBjaGVja2VkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG4gICAgaXRlbUtleShlKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNoZWNrS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5kYXRhSXRlbVt0aGlzLmNoZWNrS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hlY2tLZXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tLZXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2soZSkge1xuICAgICAgICBjb25zdCB7IGVuYWJsZWQsIG1vZGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgcGVyZm9ybVNlbGVjdGlvbiA9IHRoaXMuY2hlY2tBY3Rpb25zW21vZGVdIHx8IG5vb3A7XG4gICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBlcmZvcm1TZWxlY3Rpb24oZSk7XG4gICAgfVxuICAgIGNoZWNrU2luZ2xlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUuaXRlbSk7XG4gICAgICAgIHRoaXMuY2hlY2tlZEtleXMgPSB0aGlzLmNoZWNrZWRLZXlzWzBdICE9PSBrZXkgPyBba2V5XSA6IFtdO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBjaGVja011bHRpcGxlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja05vZGUobm9kZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2hlY2tQYXJlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUGFyZW50cyhub2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgdG9nZ2xlQ2hlY2tPbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2xpY2soKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja09uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTdWJzY3JpcHRpb24gPSB0aGlzLnRyZWVWaWV3Lm5vZGVDbGljay5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLnRyZWVWaWV3Lml0ZW1Mb29rdXAoYXJncy5pdGVtLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVjayhsb29rdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWNrU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmNsaWNrU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja05vZGUobm9kZSwgY2hlY2spIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUuaXRlbSk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuY2hlY2tlZEtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBjb25zdCBpc0NoZWNrZWQgPSBpZHggPiAtMTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2hlY2sgPSBjaGVjayA9PT0gdW5kZWZpbmVkID8gIWlzQ2hlY2tlZCA6IGNoZWNrO1xuICAgICAgICBpZiAoIWlzUHJlc2VudChrZXkpIHx8IChpc0NoZWNrZWQgJiYgY2hlY2spIHx8IHRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrZWRLZXlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaGVja0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLm1hcChuID0+IHRoaXMuY2hlY2tOb2RlKG4sIHNob3VsZENoZWNrKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tQYXJlbnRzKHBhcmVudCkge1xuICAgICAgICBsZXQgY3VycmVudFBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IHRoaXMuaXRlbUtleShjdXJyZW50UGFyZW50Lml0ZW0pO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SW5kZXggPSB0aGlzLmNoZWNrZWRLZXlzLmluZGV4T2YocGFyZW50S2V5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbENoaWxkcmVuU2VsZWN0ZWQoY3VycmVudFBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZEtleXMucHVzaChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWRLZXlzLnNwbGljZShwYXJlbnRJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsQ2hpbGRyZW5TZWxlY3RlZChjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBpc0NoZWNrZWRSZWR1Y2VyID0gKGFjYywgaXRlbSkgPT4gKGFjYyAmJiB0aGlzLmlzSXRlbUNoZWNrZWQoaXRlbS5kYXRhSXRlbSwgaXRlbS5pbmRleCkgPT09ICdjaGVja2VkJyk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UoaXNDaGVja2VkUmVkdWNlciwgdHJ1ZSk7XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkS2V5c0NoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZEtleXMuc2xpY2UoKSk7XG4gICAgfVxuICAgIGFkZENoaWxkcmVuS2V5cyhhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrZWRLZXlzLmluZGV4T2YodGhpcy5pdGVtS2V5KGFyZ3MuaXRlbSkpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBhcmdzLmNoaWxkcmVuLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtS2V5ID0gdGhpcy5pdGVtS2V5KGl0ZW0pO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdLZXkgPSB0aGlzLmNoZWNrZWRLZXlzLmZpbmQoa2V5ID0+IGl0ZW1LZXkgPT09IGtleSk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goaXRlbUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkS2V5cyA9IHRoaXMuY2hlY2tlZEtleXMuY29uY2F0KGtleXMpO1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuQ2hlY2tEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0NoZWNrYWJsZV0nIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ2hlY2tEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlVmlld0NvbXBvbmVudCB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5DaGVja0RpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBpc0NoZWNrZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoZWNrS2V5OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogW1wiY2hlY2tCeVwiLF0gfV0sXG4gICAgY2hlY2tlZEtleXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoZWNrYWJsZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsna2VuZG9UcmVlVmlld0NoZWNrYWJsZScsXSB9XSxcbiAgICBjaGVja2VkS2V5c0NoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIGRpc2FibGVkIGluLW1lbW9yeSBzdGF0ZSBvZiB0aGUgVHJlZVZpZXcgbm9kZVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkaXNhYmxlZHN0YXRlX3RyZWV2aWV3ICV9KSkuXG4gKi9cbmNsYXNzIERpc2FibGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRyZWVWaWV3LCBjZHIpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldyA9IHRyZWVWaWV3O1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgdGhlIGNvbGxlY3Rpb24gdGhhdCB3aWxsIHN0b3JlIHRoZSBkaXNhYmxlZCBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0Rpc2FibGVkID0gKGRhdGFJdGVtLCBpbmRleCkgPT4gKHRoaXMuZGlzYWJsZWRLZXlzLmluZGV4T2YodGhpcy5pdGVtS2V5KHsgZGF0YUl0ZW0sIGluZGV4IH0pKSA+IC0xKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNldCBpc0Rpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHJlZVZpZXcuaXNEaXNhYmxlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBkaXNhYmxlZEtleXMgfSA9IGNoYW5nZXM7XG4gICAgICAgIGlmIChkaXNhYmxlZEtleXMgJiYgIWRpc2FibGVkS2V5cy5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXRlbUtleShlKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzYWJsZUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGUuZGF0YUl0ZW1bdGhpcy5kaXNhYmxlS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzYWJsZUtleSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlS2V5KGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuRGlzYWJsZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3RGlzYWJsZV0nIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRGlzYWJsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRyZWVWaWV3Q29tcG9uZW50IH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuRGlzYWJsZURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBpc0Rpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlS2V5OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogW1wia2VuZG9UcmVlVmlld0Rpc2FibGVcIixdIH1dLFxuICAgIGRpc2FibGVkS2V5czogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIFRyZWVWaWV3XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGV4cGFuZGVkc3RhdGVfdHJlZXZpZXcgJX0pKS5cbiAqL1xuY2xhc3MgRXhwYW5kRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlVmlldykge1xuICAgICAgICB0aGlzLnRyZWVWaWV3ID0gdHJlZVZpZXc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBgZXhwYW5kZWRLZXlzYCBjb2xsZWN0aW9uIHdhcyB1cGRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZEtleXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWRLZXlzID0gW107XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQobWVyZ2UodGhpcy50cmVlVmlldy5leHBhbmQucGlwZShtYXAoZSA9PiAoT2JqZWN0LmFzc2lnbih7IGV4cGFuZDogdHJ1ZSB9LCBlKSkpKSwgdGhpcy50cmVlVmlldy5jb2xsYXBzZS5waXBlKG1hcChlID0+IChPYmplY3QuYXNzaWduKHsgZXhwYW5kOiBmYWxzZSB9LCBlKSkpKSkuc3Vic2NyaWJlKHRoaXMudG9nZ2xlRXhwYW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc0V4cGFuZGVkID0gKGRhdGFJdGVtLCBpbmRleCkgPT4gdGhpcy5leHBhbmRlZEtleXMuaW5kZXhPZih0aGlzLml0ZW1LZXkoeyBkYXRhSXRlbSwgaW5kZXggfSkpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgaXNFeHBhbmRlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyZWVWaWV3LmlzRXhwYW5kZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgY29sbGVjdGlvbiB0aGF0IHdpbGwgc3RvcmUgdGhlIGV4cGFuZGVkIGtleXMuXG4gICAgICovXG4gICAgZ2V0IGV4cGFuZGVkS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZGVkS2V5cztcbiAgICB9XG4gICAgc2V0IGV4cGFuZGVkS2V5cyhrZXlzKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkS2V5cyA9IGtleXM7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaXRlbUtleShlKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZEtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV4cGFuZEtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmRhdGFJdGVtW3RoaXMuZXhwYW5kS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5leHBhbmRLZXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZEtleShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5pbmRleDtcbiAgICB9XG4gICAgdG9nZ2xlRXhwYW5kKHsgaW5kZXgsIGRhdGFJdGVtLCBleHBhbmQgfSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtS2V5KHsgaW5kZXgsIGRhdGFJdGVtIH0pO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmV4cGFuZGVkS2V5cy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBsZXQgbm90aWZ5ID0gZmFsc2U7XG4gICAgICAgIGlmIChpZHggPiAtMSAmJiAhZXhwYW5kKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkS2V5cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIG5vdGlmeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWR4ID09PSAtMSAmJiBleHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBub3RpZnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRLZXlzQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZEtleXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuRXhwYW5kRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdFeHBhbmRhYmxlXScgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5FeHBhbmREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlVmlld0NvbXBvbmVudCB9XG5dO1xuRXhwYW5kRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGlzRXhwYW5kZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGV4cGFuZEtleTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFtcImV4cGFuZEJ5XCIsXSB9XSxcbiAgICBleHBhbmRlZEtleXNDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBleHBhbmRlZEtleXM6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIGluLW1lbW9yeSBzZWxlY3Rpb24gc3RhdGUgb2YgdGhlIFRyZWVWaWV3IG5vZGVcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgc2VsZWN0aW9uX3RyZWV2aWV3ICV9KSkuXG4gKi9cbmNsYXNzIFNlbGVjdERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZVZpZXcpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldyA9IHRyZWVWaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgYHNlbGVjdGVkS2V5c2AgY29sbGVjdGlvbiB3YXMgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWN0aW9ucyA9IHtcbiAgICAgICAgICAgICdtdWx0aXBsZSc6IChlKSA9PiB0aGlzLnNlbGVjdE11bHRpcGxlKGUpLFxuICAgICAgICAgICAgJ3NpbmdsZSc6IChlKSA9PiB0aGlzLnNlbGVjdFNpbmdsZShlKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLnRyZWVWaWV3LnNlbGVjdGlvbkNoYW5nZS5zdWJzY3JpYmUodGhpcy5zZWxlY3QuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnRyZWVWaWV3LmlzU2VsZWN0ZWQgPSAoZGF0YUl0ZW0sIGluZGV4KSA9PiAodGhpcy5zZWxlY3RlZEtleXMuaW5kZXhPZih0aGlzLml0ZW1LZXkoeyBkYXRhSXRlbSwgaW5kZXggfSkpID4gLTEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IGlzU2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldy5pc1NlbGVjdGVkID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGNvbGxlY3Rpb24gdGhhdCB3aWxsIHN0b3JlIHRoZSBzZWxlY3RlZCBrZXlzXG4gICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZWxlY3Rpb25fdHJlZXZpZXcgJX0jdG9jLXNlbGVjdGlvbi1tb2RlcykpLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEtleXM7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZEtleXMoa2V5cykge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEtleXMgPSBrZXlzO1xuICAgIH1cbiAgICBnZXQgZ2V0QXJpYU11bHRpc2VsZWN0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tb2RlID09PSAnbXVsdGlwbGUnO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogJ3NpbmdsZSdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb24pIHx8IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Jvb2xlYW4gPSB0eXBlb2YgdGhpcy5zZWxlY3Rpb24gPT09ICdib29sZWFuJztcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU2V0dGluZ3MgPSBpc0Jvb2xlYW4gPyB7IGVuYWJsZWQ6IHRoaXMuc2VsZWN0aW9uIH0gOiB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIHNlbGVjdGlvblNldHRpbmdzKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpdGVtS2V5KGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmRhdGFJdGVtW3RoaXMuc2VsZWN0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2VsZWN0S2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RLZXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0KGUpIHtcbiAgICAgICAgY29uc3QgeyBlbmFibGVkLCBtb2RlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBlcmZvcm1TZWxlY3Rpb24gPSB0aGlzLnNlbGVjdEFjdGlvbnNbbW9kZV0gfHwgbm9vcDtcbiAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGVyZm9ybVNlbGVjdGlvbihlKTtcbiAgICB9XG4gICAgc2VsZWN0U2luZ2xlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEtleXNbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzID0gW2tleV07XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfVxuICAgIHNlbGVjdE11bHRpcGxlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5pdGVtS2V5KG5vZGUpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnNlbGVjdGVkS2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpZHggPiAtMTtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkS2V5cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlzQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZEtleXMuc2xpY2UoKSk7XG4gICAgfVxufVxuU2VsZWN0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdTZWxlY3RhYmxlXScgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5TZWxlY3REaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlVmlld0NvbXBvbmVudCB9XG5dO1xuU2VsZWN0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGlzU2VsZWN0ZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdEtleTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnc2VsZWN0QnknLF0gfV0sXG4gICAgc2VsZWN0aW9uOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydrZW5kb1RyZWVWaWV3U2VsZWN0YWJsZScsXSB9XSxcbiAgICBzZWxlY3RlZEtleXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkS2V5c0NoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGdldEFyaWFNdWx0aXNlbGVjdGFibGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGUnLF0gfV1cbn07XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBhdHRlbXB0ZWQgZHJvcCBhY3Rpb24gZHVyaW5nIGRyYWdnaW5nLlxuICogUGFzc2VkIGFzIGBhY3Rpb25gIHZhbHVlIHRvIHRoZSBbYGtlbmRvVHJlZVZpZXdEcmFnQ2x1ZVRlbXBsYXRlYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZHJhZ2NsdWV0ZW1wbGF0ZWRpcmVjdGl2ZSAlfSkgZGlyZWN0aXZlLlxuICogQnkgZGVmYXVsdCwgdGhpcyB2YWx1ZSBkZWZpbmVzIHRoZSByZW5kZXJlZCBpY29uIGluIHRoZSBkcmFnIGNsdWUuXG4gKi9cbnZhciBEcm9wQWN0aW9uO1xuKGZ1bmN0aW9uIChEcm9wQWN0aW9uKSB7XG4gICAgRHJvcEFjdGlvbltEcm9wQWN0aW9uW1wiQWRkXCJdID0gMF0gPSBcIkFkZFwiO1xuICAgIERyb3BBY3Rpb25bRHJvcEFjdGlvbltcIkluc2VydFRvcFwiXSA9IDFdID0gXCJJbnNlcnRUb3BcIjtcbiAgICBEcm9wQWN0aW9uW0Ryb3BBY3Rpb25bXCJJbnNlcnRCb3R0b21cIl0gPSAyXSA9IFwiSW5zZXJ0Qm90dG9tXCI7XG4gICAgRHJvcEFjdGlvbltEcm9wQWN0aW9uW1wiSW5zZXJ0TWlkZGxlXCJdID0gM10gPSBcIkluc2VydE1pZGRsZVwiO1xuICAgIERyb3BBY3Rpb25bRHJvcEFjdGlvbltcIkludmFsaWRcIl0gPSA0XSA9IFwiSW52YWxpZFwiO1xufSkoRHJvcEFjdGlvbiB8fCAoRHJvcEFjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogRGVzY3JpYmVzIHdoZXJlIHRoZSBkcmFnZ2VkIGl0ZW0gaXMgZHJvcHBlZCByZWxhdGl2ZSB0byB0aGUgZHJvcCB0YXJnZXQgaXRlbS5cbiAqL1xudmFyIERyb3BQb3NpdGlvbjtcbihmdW5jdGlvbiAoRHJvcFBvc2l0aW9uKSB7XG4gICAgRHJvcFBvc2l0aW9uW0Ryb3BQb3NpdGlvbltcIk92ZXJcIl0gPSAwXSA9IFwiT3ZlclwiO1xuICAgIERyb3BQb3NpdGlvbltEcm9wUG9zaXRpb25bXCJCZWZvcmVcIl0gPSAxXSA9IFwiQmVmb3JlXCI7XG4gICAgRHJvcFBvc2l0aW9uW0Ryb3BQb3NpdGlvbltcIkFmdGVyXCJdID0gMl0gPSBcIkFmdGVyXCI7XG59KShEcm9wUG9zaXRpb24gfHwgKERyb3BQb3NpdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3NlcyB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMsIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBkZWZhdWx0IGFjdGlvbiB3YXMgcHJldmVudGVkLiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgVHJlZVZpZXcgW2Bub2RlRHJvcGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJvcCkgZXZlbnQuXG4gKi9cbmNsYXNzIFRyZWVJdGVtRHJvcEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxpemVyLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmFsaWQgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWxpemVyKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBkcm9wIGFjdGlvbiBzaG91bGQgYmUgbWFya2VkIGFzIHZhbGlkLlxuICAgICAqIElmIHNldCB0byBgZmFsc2VgLCB0aGUgW2BhZGRJdGVtYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLWFkZGl0ZW0pIGFuZFxuICAgICAqIFtgcmVtb3ZlSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1yZW1vdmVpdGVtKSBldmVudHMgd2lsbCBub3QgYmUgZmlyZWQgYW5kIHRoZSBkcmFnIGNsdWVcbiAgICAgKiB3aWxsIGJlIGFuaW1hdGVkIGJhY2sgdG8gdGhlIHNvdXJjZSBpdGVtIHRvIGluZGljYXRlIHRoZSBhY3Rpb24gaXMgbWFya2VkIGFzIGludmFsaWQuXG4gICAgICovXG4gICAgc2V0VmFsaWQoaXNWYWxpZCkge1xuICAgICAgICB0aGlzLmlzVmFsaWQgPSBpc1ZhbGlkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBUcmVlVmlldyBbYG5vZGVEcmFnU3RhcnRgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWdzdGFydCkgZXZlbnQuXG4gKi9cbmNsYXNzIFRyZWVJdGVtRHJhZ1N0YXJ0RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsaXplcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIFRyZWVWaWV3IFtgbm9kZURyYWdgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWcpIGFuZFxuICogW2Bub2RlRHJhZ0VuZGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJhZ2VuZCkgZXZlbnRzLlxuICovXG5jbGFzcyBUcmVlSXRlbURyYWdFdmVudCB7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHJlbGF0aXZlIHN0YWNraW5nIGNvbnRleHQuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICovXG5jb25zdCBoYXNSZWxhdGl2ZVN0YWNraW5nQ29udGV4dCA9ICgpID0+IHtcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRvcCA9IDEwO1xuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcGFyZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwibWF0cml4KDEwLCAwLCAwLCAxMCwgMCwgMClcIjtcbiAgICBwYXJlbnQuaW5uZXJIVE1MID0gYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogJHt0b3B9cHg7XCI+Y2hpbGQ8L2Rpdj5gO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50KTtcbiAgICBjb25zdCBpc0RpZmZlcmVudCA9IHBhcmVudC5jaGlsZHJlblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xufTtcbmNvbnN0IEhBU19SRUxBVElWRV9TVEFDS0lOR19DT05URVhUID0gaGFzUmVsYXRpdmVTdGFja2luZ0NvbnRleHQoKTtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEdldHMgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50IGVsZW1lbnQgaWYgdGhlIGxhdHRlciBoYXMgdGhlIGB0cmFuc2Zvcm1gIENTUyBwcm9wIGFwcGxpZWQuXG4gKiBUcmFuc2Zvcm1lZCBwYXJlbnRzIGNyZWF0ZSBuZXcgc3RhY2tpbmcgY29udGV4dCBhbmQgdGhlIGBmaXhlZGAgY2hpbGRyZW4gbXVzdCBiZSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtZWQgcGFyZW50LlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgvVGhlX3N0YWNraW5nX2NvbnRleHRcbiAqXG4gKiBJZiBubyBwYXJlbnQgY29udGFpbmVyIGlzIGB0cmFuc2Zvcm1gLWVkIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBgeyBsZWZ0OiAwLCB0b3A6IDAgfWA7XG4gKi9cbmNvbnN0IGdldENvbnRhaW5lck9mZnNldCA9IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKCEoZWxlbWVudCAmJiBIQVNfUkVMQVRJVkVfU1RBQ0tJTkdfQ09OVEVYVCkpIHtcbiAgICAgICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgfVxuICAgIGxldCBvZmZzZXRQYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCkge1xuICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS50cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG9mZnNldFBhcmVudC5zY3JvbGxUb3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgdG9wOiAwIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERyb3BBY3Rpb24gPSAoZHJvcFBvc2l0aW9uLCBkcm9wVGFyZ2V0KSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KGRyb3BQb3NpdGlvbikgJiYgaXNQcmVzZW50KGRyb3BUYXJnZXQpKSkge1xuICAgICAgICByZXR1cm4gRHJvcEFjdGlvbi5JbnZhbGlkO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRyb3BQb3NpdGlvbikge1xuICAgICAgICBjYXNlIERyb3BQb3NpdGlvbi5PdmVyOlxuICAgICAgICAgICAgcmV0dXJuIERyb3BBY3Rpb24uQWRkO1xuICAgICAgICBjYXNlIERyb3BQb3NpdGlvbi5CZWZvcmU6XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNsb3Nlc3ROb2RlKGRyb3BUYXJnZXQpLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpID8gRHJvcEFjdGlvbi5JbnNlcnRNaWRkbGUgOiBEcm9wQWN0aW9uLkluc2VydFRvcDtcbiAgICAgICAgY2FzZSBEcm9wUG9zaXRpb24uQWZ0ZXI6XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNsb3Nlc3ROb2RlKGRyb3BUYXJnZXQpLm5leHRFbGVtZW50U2libGluZykgPyBEcm9wQWN0aW9uLkluc2VydE1pZGRsZSA6IERyb3BBY3Rpb24uSW5zZXJ0Qm90dG9tO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIERyb3BBY3Rpb24uSW52YWxpZDtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGdldERyb3BQb3NpdGlvbiA9IChkcmFnZ2VkSXRlbSwgdGFyZ2V0LCBjbGllbnRZLCB0YXJnZXRUcmVlVmlldywgY29udGFpbmVyT2Zmc2V0KSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KGRyYWdnZWRJdGVtKSAmJiBpc1ByZXNlbnQodGFyZ2V0KSAmJiBpc1ByZXNlbnQodGFyZ2V0VHJlZVZpZXcpICYmIGlzUHJlc2VudChjb250YWluZXJPZmZzZXQpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSAuay1taWQgZWxlbWVudCBzdGFydHMganVzdCBhZnRlciB0aGUgY2hlY2tib3gvZXhwYW5kIGFycm93IGFuZCBzdHJldGNoZXMgdGlsbCB0aGUgZW5kIG9mIHRoZSB0cmVldmlldyBvbiB0aGUgcmlnaHRcbiAgICBjb25zdCBpdGVtID0gY2xvc2VzdFdpdGhNYXRjaCh0YXJnZXQsICcuay1taWQnKTtcbiAgICBpZiAoIWlzUHJlc2VudChpdGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHRoZSAuay1pbiBlbGVtZW50IGhvbGRzIGp1c3QgdGhlIHRyZWV2aWV3IGl0ZW0gdGV4dCAodGhlIGFjdHVhbCBjb250ZW50KVxuICAgIGNvbnN0IGNvbnRlbnQgPSBpdGVtLnF1ZXJ5U2VsZWN0b3IoJy5rLWluJyk7XG4gICAgY29uc3QgdGFyZ2V0Q2hpbGRPZkRyYWdnZWRJdGVtID0gaGFzUGFyZW50KGl0ZW0sIGNsb3Nlc3ROb2RlKGRyYWdnZWRJdGVtKSk7XG4gICAgaWYgKCFpc1ByZXNlbnQoY29udGVudCkgfHwgKGNvbnRlbnQgPT09IGRyYWdnZWRJdGVtKSB8fCB0YXJnZXRDaGlsZE9mRHJhZ2dlZEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtVmlld1BvcnRDb29yZHMgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8qXG4gICAgICAgIGlmIHRoZSB1c2VyIGlzIGhvdmVyaW5nIGEgdHJlZXZpZXcgaXRlbSwgc3BsaXQgdGhlIGl0ZW0gaGVpZ2h0IGludG8gZm91ciBwYXJ0czpcbiAgICAgICAgICAgIC0gZHJvcHBpbmcgaW50byB0aGUgdG9wIHF1YXJ0ZXIgc2hvdWxkIGluc2VydCB0aGUgZHJhZ2dlZCBpdGVtIGJlZm9yZSB0aGUgZHJvcCB0YXJnZXRcbiAgICAgICAgICAgIC0gZHJvcHBpbmcgaW50byB0aGUgYm90dG9tIHF1YXJ0ZXIgc2hvdWxkIGluc2VydCB0aGUgZHJhZ2dlZCBpdGVtIGFmdGVyIHRoZSBkcm9wIHRhcmdldFxuICAgICAgICAgICAgLSBkcm9wcGluZyBpbnRvIHRoZSBzZWNvbmQgb3IgdGhpcmQgcXVhcnRlciBzaG91bGQgYWRkIHRoZSBpdGVtIGFzIGNoaWxkIG5vZGUgb2YgdGhlIGRyb3AgdGFyZ2V0XG5cbiAgICAgICAgaWYgdGhlIHVzZXIgaXMgTk9UIGhvdmVyaW5nIGEgdHJlZXZpZXcgaXRlbSAoaGUncyBkcmFnZ2luZyBzb21ld2hlcmUgaW4gdGhlIHJpZ2h0KSwgc3BsaXQgdGhlIGl0ZW0gaGVpZ2h0IHRvIGp1c3QgcGFydHM6XG4gICAgICAgICAgICAtIGRyb3BwaW5nIHNob3VsZCBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyXG4gICAgKi9cbiAgICBjb25zdCBpdGVtRGl2aXNpb25IZWlnaHQgPSBpdGVtVmlld1BvcnRDb29yZHMuaGVpZ2h0IC8gKGlzQ29udGVudCh0YXJnZXQpID8gNCA6IDIpO1xuICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGNsaWVudFkgLSBjb250YWluZXJPZmZzZXQudG9wO1xuICAgIGNvbnN0IGl0ZW1Ub3AgPSBpdGVtVmlld1BvcnRDb29yZHMudG9wIC0gY29udGFpbmVyT2Zmc2V0LnRvcDtcbiAgICBpZiAocG9pbnRlclBvc2l0aW9uIDwgaXRlbVRvcCArIGl0ZW1EaXZpc2lvbkhlaWdodCkge1xuICAgICAgICByZXR1cm4gRHJvcFBvc2l0aW9uLkJlZm9yZTtcbiAgICB9XG4gICAgaWYgKHBvaW50ZXJQb3NpdGlvbiA+PSBpdGVtVG9wICsgaXRlbVZpZXdQb3J0Q29vcmRzLmhlaWdodCAtIGl0ZW1EaXZpc2lvbkhlaWdodCkge1xuICAgICAgICByZXR1cm4gRHJvcFBvc2l0aW9uLkFmdGVyO1xuICAgIH1cbiAgICByZXR1cm4gRHJvcFBvc2l0aW9uLk92ZXI7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0ID0gKHRyZWVWaWV3LCBkcm9wVGFyZ2V0KSA9PiB7XG4gICAgaWYgKCEoaXNQcmVzZW50KHRyZWVWaWV3KSAmJiBpc1ByZXNlbnQoZHJvcFRhcmdldCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IGNsb3Nlc3ROb2RlKGRyb3BUYXJnZXQpO1xuICAgIGNvbnN0IGluZGV4ID0gbm9kZUlkKG5vZGUpO1xuICAgIHJldHVybiB0cmVlVmlldy5pdGVtTG9va3VwKGluZGV4KTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqXG4gKiBFbWl0cyBgY29sbGFwc2VgIG9uIHRoZSBzcGVjaWZpZWQgVHJlZVZpZXcgbm9kZSBpZiB0aGUgbGF0dGVyIGlzIGxlZnQgZW1wdHkgYWZ0ZXIgaXRzIGxhc3QgY2hpbGQgbm9kZSB3YXMgZHJhZ2dlZCBvdXQuXG4gKi9cbmNvbnN0IGNvbGxhcHNlRW1wdHlQYXJlbnQgPSAocGFyZW50LCBwYXJlbnROb2RlcywgdHJlZXZpZXcpID0+IHtcbiAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkgJiYgcGFyZW50Tm9kZXMubGVuZ3RoID09PSAwICYmIHRyZWV2aWV3LmlzRXhwYW5kZWQocGFyZW50Lml0ZW0uZGF0YUl0ZW0sIHBhcmVudC5pdGVtLmluZGV4KSkge1xuICAgICAgICB0cmVldmlldy5jb2xsYXBzZU5vZGUocGFyZW50Lml0ZW0uZGF0YUl0ZW0sIHBhcmVudC5pdGVtLmluZGV4KTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogRXhwYW5kcyB0aGUgbm9kZSBpZiBpdCdzIGRyb3BwZWQgaW50byBhbmQgaXQncyBub3QgeWV0IGV4cGFuZGVkLlxuICovXG5jb25zdCBleHBhbmREcm9wVGFyZ2V0ID0gKGRyb3BUYXJnZXQsIHRyZWVWaWV3KSA9PiB7XG4gICAgaWYgKCF0cmVlVmlldy5pc0V4cGFuZGVkKGRyb3BUYXJnZXQuaXRlbS5kYXRhSXRlbSwgZHJvcFRhcmdldC5pdGVtLmluZGV4KSkge1xuICAgICAgICB0cmVlVmlldy5leHBhbmROb2RlKGRyb3BUYXJnZXQuaXRlbS5kYXRhSXRlbSwgZHJvcFRhcmdldC5pdGVtLmluZGV4KTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogRXh0cmFjdHMgdGhlIGV2ZW50IHRhcmdldCBmcm9tIHRoZSB2aWV3cG9ydCBjb29yZHMuIFJlcXVpcmVkIGZvciB0b3VjaCBkZXZpY2VzXG4gKiB3aGVyZSB0aGUgYGV2ZW50LnRhcmdldGAgb2YgYSBgcG9pbnRlcm1vdmVgIGV2ZW50IGlzIGFsd2F5cyB0aGUgaW5pdGlhbGx5IGRyYWdnZWQgaXRlbS5cbiAqL1xuY29uc3QgZ2V0RHJvcFRhcmdldCA9IChldmVudCkgPT4ge1xuICAgIGlmICghKGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBpc1ByZXNlbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCkpKSB7XG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEhpZXJhcmNoeUVkaXRpbmdTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihoaWVyYXJjaHlCaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuaGllcmFyY2h5QmluZGluZyA9IGhpZXJhcmNoeUJpbmRpbmc7XG4gICAgfVxuICAgIGFkZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgZHJvcFBvc2l0aW9uLCBkZXN0aW5hdGlvblRyZWUgfSkge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkRhdGFJdGVtID0gZGVzdGluYXRpb25JdGVtLml0ZW0uZGF0YUl0ZW07XG4gICAgICAgIC8vIHNoYWxsb3cgY2xvbmUgdGhlIGl0ZW0gYXMgbm90IHRvIG1pc3Rha2UgaXQgZm9yIGl0cyAnb2xkZXInIHZlcnNpb24gd2hlbiB0aGUgcmVtb3ZlIGhhbmRsZXIga2lja3MgaW4gdG8gc3BsaWNlIHRoZSBpdGVtIGF0IGl0cyBvbGQgcG9zaXRpb25cbiAgICAgICAgY29uc3Qgc291cmNlRGF0YUl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VJdGVtLml0ZW0uZGF0YUl0ZW0pO1xuICAgICAgICBpZiAoZHJvcFBvc2l0aW9uID09PSBEcm9wUG9zaXRpb24uT3Zlcikge1xuICAgICAgICAgICAgLy8gZXhwYW5kIHRoZSBpdGVtIHRoYXQgd2FzIGRyb3BwZWQgaW50b1xuICAgICAgICAgICAgZXhwYW5kRHJvcFRhcmdldChkZXN0aW5hdGlvbkl0ZW0sIGRlc3RpbmF0aW9uVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkNoaWxkcmVuID0gZ2V0dGVyKHRoaXMuaGllcmFyY2h5QmluZGluZy5jaGlsZHJlbkZpZWxkKShkZXN0aW5hdGlvbkRhdGFJdGVtKSB8fCBbXTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQ2hpbGRyZW4ucHVzaChzb3VyY2VEYXRhSXRlbSk7XG4gICAgICAgICAgICBzZXR0ZXIodGhpcy5oaWVyYXJjaHlCaW5kaW5nLmNoaWxkcmVuRmllbGQpKGRlc3RpbmF0aW9uRGF0YUl0ZW0sIGRlc3RpbmF0aW9uQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25QYXJlbnROb2RlcyA9IHRoaXMuZ2V0UGFyZW50Tm9kZXMoZGVzdGluYXRpb25JdGVtLCBkZXN0aW5hdGlvblRyZWUpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRJbmRleCA9IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGRlc3RpbmF0aW9uUGFyZW50Tm9kZXMuaW5kZXhPZihkZXN0aW5hdGlvbkRhdGFJdGVtKSArIHNoaWZ0SW5kZXg7XG4gICAgICAgICAgICBkZXN0aW5hdGlvblBhcmVudE5vZGVzLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgc291cmNlRGF0YUl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSh7IHNvdXJjZUl0ZW0sIHNvdXJjZVRyZWUgfSkge1xuICAgICAgICBjb25zdCBzb3VyY2VQYXJlbnROb2RlcyA9IHRoaXMuZ2V0UGFyZW50Tm9kZXMoc291cmNlSXRlbSwgc291cmNlVHJlZSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ZW1JbmRleCA9IHNvdXJjZVBhcmVudE5vZGVzLmluZGV4T2Yoc291cmNlSXRlbS5pdGVtLmRhdGFJdGVtKTtcbiAgICAgICAgc291cmNlUGFyZW50Tm9kZXMuc3BsaWNlKHNvdXJjZUl0ZW1JbmRleCwgMSk7XG4gICAgICAgIC8vIGVtaXQgY29sbGFwc2UgZm9yIHRoZSBwYXJlbnQgbm9kZSBpZiBpdHMgbGFzdCBjaGlsZCBub2RlIHdhcyBzcGxpY2VkXG4gICAgICAgIGNvbGxhcHNlRW1wdHlQYXJlbnQoc291cmNlSXRlbS5wYXJlbnQsIHNvdXJjZVBhcmVudE5vZGVzLCBzb3VyY2VUcmVlKTtcbiAgICB9XG4gICAgZ2V0UGFyZW50Tm9kZXMobm9kZSwgdHJlZVZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50ID9cbiAgICAgICAgICAgIGdldHRlcih0aGlzLmhpZXJhcmNoeUJpbmRpbmcuY2hpbGRyZW5GaWVsZCkobm9kZS5wYXJlbnQuaXRlbS5kYXRhSXRlbSkgOlxuICAgICAgICAgICAgdHJlZVZpZXcubm9kZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGVuY2Fwc3VsYXRlcyB0aGUgcmV0cmlldmFsIG9mIGNoaWxkIG5vZGVzLlxuICovXG5jbGFzcyBIaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlVmlldykge1xuICAgICAgICB0aGlzLnRyZWVWaWV3ID0gdHJlZVZpZXc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBuYW1lIHdoaWNoIGhvbGRzIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0IGNoaWxkcmVuRmllbGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2NoaWxkcmVuRmllbGQnIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbkZpZWxkID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCBuYW1lIHdoaWNoIGhvbGRzIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICovXG4gICAgZ2V0IGNoaWxkcmVuRmllbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbkZpZWxkO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNoaWxkcmVuRmllbGQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3LmNoaWxkcmVuID0gaXRlbSA9PiBvZihnZXR0ZXIodGhpcy5jaGlsZHJlbkZpZWxkKShpdGVtKSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3Lmhhc0NoaWxkcmVuID0gaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXR0ZXIodGhpcy5jaGlsZHJlbkZpZWxkKShpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudHJlZVZpZXcuZWRpdFNlcnZpY2UgPSBuZXcgSGllcmFyY2h5RWRpdGluZ1NlcnZpY2UodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdIaWVyYXJjaHlCaW5kaW5nXScgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5IaWVyYXJjaHlCaW5kaW5nRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVHJlZVZpZXdDb21wb25lbnQgfVxuXTtcbkhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2hpbGRyZW5GaWVsZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMb2FkaW5nSW5kaWNhdG9yRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihleHBhbmRTZXJ2aWNlLCBsb2FkaW5nU2VydmljZSwgY2QpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2VydmljZSA9IGxvYWRpbmdTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGxvYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICAgIH1cbiAgICBzZXQgbG9hZGluZyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBjb25zdCBsb2FkaW5nTm90aWZpY2F0aW9ucyA9IHRoaXMubG9hZGluZ1NlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoaW5kZXggPT4gaW5kZXggPT09IHRoaXMuaW5kZXgpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmV4cGFuZFNlcnZpY2VcbiAgICAgICAgICAgIC5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKHsgaW5kZXggfSkgPT4gaW5kZXggPT09IHRoaXMuaW5kZXgpLCB0YXAoKHsgZXhwYW5kIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghZXhwYW5kICYmIHRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgZmlsdGVyKCh7IGV4cGFuZCB9KSA9PiBleHBhbmQpLCBzd2l0Y2hNYXAoeCA9PiBvZih4KS5waXBlKGRlbGF5KDEwMCksIHRha2VVbnRpbChsb2FkaW5nTm90aWZpY2F0aW9ucykpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5sb2FkaW5nID0gdHJ1ZSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChsb2FkaW5nTm90aWZpY2F0aW9ucy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5sb2FkaW5nID0gZmFsc2UpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkxvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0xvYWRpbmddJyB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkxvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFeHBhbmRTdGF0ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IExvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuTG9hZGluZ0luZGljYXRvckRpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBsb2FkaW5nOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogW1wiY2xhc3Muay1pLWxvYWRpbmdcIixdIH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogW1wia2VuZG9UcmVlVmlld0xvYWRpbmdcIixdIH1dXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqIFBlcmZvcm1zIHRoZSByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBGdW5jdGlvbnMgbXVzdCBoYXZlIGEgdW5hcnkuXG4gKi9cbmNvbnN0IGNvbXBvc2UgPSAoLi4uYXJncykgPT4gKGRhdGEpID0+IGFyZ3MucmVkdWNlUmlnaHQoKGFjYywgY3VycikgPT4gY3VycihhY2MpLCBkYXRhKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEZsYXRFZGl0aW5nU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZmxhdEJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy5mbGF0QmluZGluZyA9IGZsYXRCaW5kaW5nO1xuICAgIH1cbiAgICBhZGQoeyBzb3VyY2VJdGVtLCBkZXN0aW5hdGlvbkl0ZW0sIGRyb3BQb3NpdGlvbiwgc291cmNlVHJlZSwgZGVzdGluYXRpb25UcmVlIH0pIHtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25EYXRhSXRlbSA9IGRlc3RpbmF0aW9uSXRlbS5pdGVtLmRhdGFJdGVtO1xuICAgICAgICAvLyBzaGFsbG93IGNsb25lIHRoZSBpdGVtIGFzIG5vdCB0byBtaXN0YWtlIGl0IGZvciBpdHMgJ29sZGVyJyB2ZXJzaW9uIHdoZW4gdGhlIHJlbW92ZSBoYW5kbGVyIGtpY2tzIGluIHRvIHNwbGljZSB0aGUgaXRlbSBhdCBpdHMgb2xkIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHNvdXJjZURhdGFJdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlSXRlbS5pdGVtLmRhdGFJdGVtKTtcbiAgICAgICAgaWYgKGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLk92ZXIpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCB0aGUgaXRlbSB0aGF0IHdhcyBkcm9wcGVkIGludG9cbiAgICAgICAgICAgIGV4cGFuZERyb3BUYXJnZXQoZGVzdGluYXRpb25JdGVtLCBkZXN0aW5hdGlvblRyZWUpO1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25JdGVtSWQgPSBnZXR0ZXIodGhpcy5mbGF0QmluZGluZy5pZEZpZWxkKShkZXN0aW5hdGlvbkRhdGFJdGVtKTtcbiAgICAgICAgICAgIHNldHRlcih0aGlzLmZsYXRCaW5kaW5nLnBhcmVudElkRmllbGQpKHNvdXJjZURhdGFJdGVtLCBkZXN0aW5hdGlvbkl0ZW1JZCk7XG4gICAgICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5wdXNoKHNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0SW5kZXggPSBkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5BZnRlciA/IDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5pbmRleE9mKGRlc3RpbmF0aW9uRGF0YUl0ZW0pICsgc2hpZnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgc291cmNlRGF0YUl0ZW0pO1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25JdGVtUGFyZW50SWQgPSBnZXR0ZXIodGhpcy5mbGF0QmluZGluZy5wYXJlbnRJZEZpZWxkKShkZXN0aW5hdGlvbkRhdGFJdGVtKTtcbiAgICAgICAgICAgIHNldHRlcih0aGlzLmZsYXRCaW5kaW5nLnBhcmVudElkRmllbGQpKHNvdXJjZURhdGFJdGVtLCBkZXN0aW5hdGlvbkl0ZW1QYXJlbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVRyZWUgIT09IGRlc3RpbmF0aW9uVHJlZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZE5vZGVzKHNvdXJjZURhdGFJdGVtLCBzb3VyY2VUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsYXRCaW5kaW5nLm5vZGVzID0gdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGE7XG4gICAgfVxuICAgIHJlbW92ZSh7IHNvdXJjZUl0ZW0sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZURhdGFJdGVtID0gc291cmNlSXRlbS5pdGVtLmRhdGFJdGVtO1xuICAgICAgICBjb25zdCBzb3VyY2VJdGVtSW5kZXggPSB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5pbmRleE9mKHNvdXJjZURhdGFJdGVtKTtcbiAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEuc3BsaWNlKHNvdXJjZUl0ZW1JbmRleCwgMSk7XG4gICAgICAgIGlmIChzb3VyY2VUcmVlICE9PSBkZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGROb2Rlcyhzb3VyY2VEYXRhSXRlbSwgc291cmNlVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbGF0QmluZGluZy5ub2RlcyA9IHRoaXMuZmxhdEJpbmRpbmcub3JpZ2luYWxEYXRhO1xuICAgICAgICAvLyBlbWl0IGNvbGxhcHNlIGZvciB0aGUgcGFyZW50IG5vZGUgaWYgaXRzIGxhc3QgY2hpbGQgbm9kZSB3YXMgc3BsaWNlZFxuICAgICAgICBjb25zdCBwYXJlbnRDaGlsZHJlbiA9IHNvdXJjZUl0ZW0ucGFyZW50ID8gc291cmNlSXRlbS5wYXJlbnQuY2hpbGRyZW4gOiBbXTtcbiAgICAgICAgY29sbGFwc2VFbXB0eVBhcmVudChzb3VyY2VJdGVtLnBhcmVudCwgcGFyZW50Q2hpbGRyZW4sIHNvdXJjZVRyZWUpO1xuICAgIH1cbiAgICBhZGRDaGlsZE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgaXRlbUNoaWxkcmVuID0gdGhpcy5mZXRjaEFsbERlc2NlbmRhbnROb2RlcyhkYXRhSXRlbSwgc291cmNlKTtcbiAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEucHVzaCguLi5pdGVtQ2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgc291cmNlQ2hpbGRyZW4gPSB0aGlzLmZldGNoQWxsRGVzY2VuZGFudE5vZGVzKGRhdGFJdGVtLCBzb3VyY2UpO1xuICAgICAgICBzb3VyY2VDaGlsZHJlbi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZsYXRCaW5kaW5nLm9yaWdpbmFsRGF0YS5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5mbGF0QmluZGluZy5vcmlnaW5hbERhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQWxsRGVzY2VuZGFudE5vZGVzKG5vZGUsIHNvdXJjZVRyZWVWaWV3KSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBzb3VyY2VUcmVlVmlld1xuICAgICAgICAgICAgLmNoaWxkcmVuKG5vZGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuZmV0Y2hBbGxEZXNjZW5kYW50Tm9kZXMoY2hpbGQsIHNvdXJjZVRyZWVWaWV3KSB8fCBbXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbn1cblxuY29uc3QgZmluZENoaWxkcmVuID0gKHByb3AsIG5vZGVzLCB2YWx1ZSkgPT4gbm9kZXMuZmlsdGVyKHggPT4gcHJvcCh4KSA9PT0gdmFsdWUpO1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIHJldHJpZXZhbCBvZiB0aGUgY2hpbGQgbm9kZXMuXG4gKi9cbmNsYXNzIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodHJlZVZpZXcpIHtcbiAgICAgICAgdGhpcy50cmVlVmlldyA9IHRyZWVWaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW5hbERhdGEgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5vZGVzIHdoaWNoIHdpbGwgYmUgZGlzcGxheWVkIGJ5IHRoZSBUcmVlVmlldy5cbiAgICAgKi9cbiAgICBzZXQgbm9kZXModmFsdWVzKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEYXRhID0gdmFsdWVzIHx8IFtdO1xuICAgICAgICBpZiAoIWlzTnVsbE9yRW1wdHlTdHJpbmcodGhpcy5wYXJlbnRJZEZpZWxkKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IGdldHRlcih0aGlzLnBhcmVudElkRmllbGQpO1xuICAgICAgICAgICAgdGhpcy50cmVlVmlldy5ub2RlcyA9ICh0aGlzLm9yaWdpbmFsRGF0YSkuZmlsdGVyKGNvbXBvc2UoaXNCbGFuaywgcHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmVlVmlldy5ub2RlcyA9IHRoaXMub3JpZ2luYWxEYXRhLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudElkRmllbGQpICYmIGlzUHJlc2VudCh0aGlzLmlkRmllbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBmZXRjaENoaWxkcmVuID0gbm9kZSA9PiBmaW5kQ2hpbGRyZW4oZ2V0dGVyKHRoaXMucGFyZW50SWRGaWVsZCksIHRoaXMub3JpZ2luYWxEYXRhIHx8IFtdLCBnZXR0ZXIodGhpcy5pZEZpZWxkKShub2RlKSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3Lmhhc0NoaWxkcmVuID0gbm9kZSA9PiBmZXRjaENoaWxkcmVuKG5vZGUpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3LmNoaWxkcmVuID0gbm9kZSA9PiBvZihmZXRjaENoaWxkcmVuKG5vZGUpKTtcbiAgICAgICAgICAgIHRoaXMudHJlZVZpZXcuZWRpdFNlcnZpY2UgPSBuZXcgRmxhdEVkaXRpbmdTZXJ2aWNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoXCJwYXJlbnRJZEZpZWxkXCIsIGNoYW5nZXMsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMub3JpZ2luYWxEYXRhO1xuICAgICAgICB9XG4gICAgfVxufVxuRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmddJyB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRyZWVWaWV3Q29tcG9uZW50IH1cbl07XG5GbGF0RGF0YUJpbmRpbmdEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbm9kZXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhcmVudElkRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlkRmllbGQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jb25zdCBidWlsZEl0ZW0gPSAoaW5kZXgsIGRhdGFJdGVtKSA9PiAoeyBkYXRhSXRlbSwgaW5kZXggfSk7XG5sZXQgaWQgPSAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbWFuYWdlcyB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIFRyZWVWaWV3LlxuICovXG5jbGFzcyBUcmVlVmlld0l0ZW1EaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGV4cGFuZFNlcnZpY2UsIG5hdmlnYXRpb25TZXJ2aWNlLCBzZWxlY3Rpb25TZXJ2aWNlLCBsb29rdXBTZXJ2aWNlLCByZW5kZXJlciwgaWIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlID0gZXhwYW5kU2VydmljZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZSA9IG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvb2t1cFNlcnZpY2UgPSBsb29rdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaWIgPSBpYjtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXJpYUNoZWNrZWQgPSAnZmFsc2UnO1xuICAgICAgICB0aGlzLmlkID0gaWQrKztcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBzZXQgaXNDaGVja2VkKGNoZWNrZWQpIHtcbiAgICAgICAgaWYgKGNoZWNrZWQgPT09ICdjaGVja2VkJykge1xuICAgICAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9ICd0cnVlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGVja2VkID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuYXJpYUNoZWNrZWQgPSAnbWl4ZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcmlhQ2hlY2tlZCA9ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzRXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0V4cGFuZGVkIHx8IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgaXNFeHBhbmRlZChpc0V4cGFuZGVkKSB7XG4gICAgICAgIHRoaXMuX2lzRXhwYW5kZWQgPSBpc0V4cGFuZGVkO1xuICAgIH1cbiAgICBnZXQgaXNTZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2VsZWN0ZWQgfHwgZmFsc2U7XG4gICAgfVxuICAgIHNldCBpc1NlbGVjdGVkKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5faXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIGdldCB0cmVlSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkSXRlbSh0aGlzLmluZGV4LCB0aGlzLmRhdGFJdGVtKTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudFRyZWVJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnREYXRhSXRlbSA/IGJ1aWxkSXRlbSh0aGlzLnBhcmVudEluZGV4LCB0aGlzLnBhcmVudERhdGFJdGVtKSA6IG51bGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxvb2t1cFNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMudHJlZUl0ZW0sIHRoaXMucGFyZW50VHJlZUl0ZW0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTmF2aWdhdGlvbkl0ZW0oKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndHJlZWl0ZW0nKTtcbiAgICAgICAgdGhpcy5zZXRBcmlhQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLnNldERpc2FibGVkQ2xhc3MoKTtcbiAgICAgICAgdGhpcy51cGRhdGVUYWJJbmRleCgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXgsIGlzRGlzYWJsZWQgfSA9IGNoYW5nZXM7XG4gICAgICAgIGlmIChpbmRleCB8fCBjaGFuZ2VzLmlzQ2hlY2tlZCB8fCBjaGFuZ2VzLmlzRXhwYW5kZWQgfHwgY2hhbmdlcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFyaWFBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGlzYWJsZWRDbGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZUxvb2t1cEl0ZW0oY2hhbmdlcyk7XG4gICAgICAgIHRoaXMubW92ZU5hdmlnYXRpb25JdGVtKGluZGV4KTtcbiAgICAgICAgdGhpcy5kaXNhYmxlTmF2aWdhdGlvbkl0ZW0oaXNEaXNhYmxlZCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLmxvb2t1cFNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy5pbmRleCwgdGhpcy5kYXRhSXRlbSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5yZWR1Y2UoKGxpc3QsIGNhbGxiYWNrKSA9PiAoY2FsbGJhY2sudW5zdWJzY3JpYmUoKSwgbGlzdCksIFtdKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm1vdmVzXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUYWJJbmRleCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNJdGVtKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZXhwYW5kc1xuICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyBpbmRleCB9KSA9PiBpbmRleCA9PT0gdGhpcy5pbmRleCAmJiAhdGhpcy5pc0Rpc2FibGVkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGV4cGFuZCB9KSA9PiB0aGlzLmV4cGFuZChleHBhbmQpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZWdpc3Rlck5hdmlnYXRpb25JdGVtKCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLmlkLCB0aGlzLmluZGV4LCB0aGlzLmlzRGlzYWJsZWQpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlSXRlbSgpO1xuICAgIH1cbiAgICBhY3RpdmF0ZUl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uU2VydmljZSA9IHRoaXMubmF2aWdhdGlvblNlcnZpY2U7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblNlcnZpY2UgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgc2VsZWN0aW9uU2VydmljZS5zZXRGaXJzdFNlbGVjdGVkKGluZGV4LCB0aGlzLmlzU2VsZWN0ZWQpO1xuICAgICAgICBpZiAoIW5hdmlnYXRpb25TZXJ2aWNlLmlzQWN0aXZlKGluZGV4KSAmJiBzZWxlY3Rpb25TZXJ2aWNlLmlzRmlyc3RTZWxlY3RlZChpbmRleCkpIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb25TZXJ2aWNlLmFjdGl2YXRlSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cGFuZChzaG91bGRFeHBhbmQpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlW3Nob3VsZEV4cGFuZCA/ICdleHBhbmQnIDogJ2NvbGxhcHNlJ10odGhpcy5pbmRleCwgdGhpcy5kYXRhSXRlbSk7XG4gICAgfVxuICAgIGlzRm9jdXNhYmxlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEaXNhYmxlZCAmJiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmlzRm9jdXNhYmxlKHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBmb2N1c0l0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5pc0FjdGl2ZSh0aGlzLmluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlTG9va3VwSXRlbShjaGFuZ2VzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBkYXRhSXRlbSwgaW5kZXgsIHBhcmVudERhdGFJdGVtLCBwYXJlbnRJbmRleCB9ID0gY2hhbmdlcztcbiAgICAgICAgaWYgKChpbmRleCAmJiBpbmRleC5maXJzdENoYW5nZSkgfHwgLy9za2lwIGZpcnN0IGNoYW5nZVxuICAgICAgICAgICAgKCFkYXRhSXRlbSAmJiAhaW5kZXggJiYgIXBhcmVudERhdGFJdGVtICYmICFwYXJlbnRJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IChpbmRleCB8fCB7fSkucHJldmlvdXNWYWx1ZSB8fCB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmxvb2t1cFNlcnZpY2UucmVwbGFjZUl0ZW0ob2xkSW5kZXgsIHRoaXMudHJlZUl0ZW0sIHRoaXMucGFyZW50VHJlZUl0ZW0pO1xuICAgIH1cbiAgICBtb3ZlTmF2aWdhdGlvbkl0ZW0oaW5kZXhDaGFuZ2UgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRWYWx1ZSwgZmlyc3RDaGFuZ2UsIHByZXZpb3VzVmFsdWUgfSA9IGluZGV4Q2hhbmdlO1xuICAgICAgICBpZiAoIWZpcnN0Q2hhbmdlICYmIGlzUHJlc2VudChjdXJyZW50VmFsdWUpICYmIGlzUHJlc2VudChwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS51bnJlZ2lzdGVySXRlbSh0aGlzLmlkLCBwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMuaWQsIGN1cnJlbnRWYWx1ZSwgdGhpcy5pc0Rpc2FibGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhYmxlTmF2aWdhdGlvbkl0ZW0oZGlzYWJsZUNoYW5nZSkge1xuICAgICAgICBpZiAoIWRpc2FibGVDaGFuZ2UgfHwgZGlzYWJsZUNoYW5nZS5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlO1xuICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLmFjdGl2YXRlQ2xvc2VzdCh0aGlzLmluZGV4KTsgLy9hY3RpdmF0ZSBiZWZvcmUgdW5yZWdpc3RlciB0aGUgaXRlbVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VydmljZS5hY3RpdmF0ZUZvY3VzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMuaWQsIHRoaXMuaW5kZXgsIHRoaXMuaXNEaXNhYmxlZCk7XG4gICAgfVxuICAgIHNldEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1sZXZlbCcsIHRoaXMuaWIubGV2ZWwodGhpcy5pbmRleCkudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdGhpcy5pc0V4cGFuZGVkLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRoaXMuaXNTZWxlY3RlZC50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIHRoaXMuYXJpYUNoZWNrZWQpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZENsYXNzKCkge1xuICAgICAgICB0aGlzLnNldENsYXNzKCdrLXN0YXRlLWRpc2FibGVkJywgdGhpcy5pc0Rpc2FibGVkKTtcbiAgICB9XG4gICAgc2V0Q2xhc3MoY2xhc3NOYW1lLCB0b2dnbGUpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdG9nZ2xlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHRoaXMucmVuZGVyZXJbYWN0aW9uXSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgdXBkYXRlVGFiSW5kZXgoKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIHRoaXMuaXNGb2N1c2FibGUoKSA/ICcwJyA6ICctMScpO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGF0dHIsIHZhbHVlKTtcbiAgICB9XG59XG5UcmVlVmlld0l0ZW1EaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0l0ZW1dJyB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRyZWVWaWV3SXRlbURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IEV4cGFuZFN0YXRlU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFNlbGVjdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFRyZWVWaWV3TG9va3VwU2VydmljZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBJbmRleEJ1aWxkZXJTZXJ2aWNlIH1cbl07XG5UcmVlVmlld0l0ZW1EaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGF0YUl0ZW06IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYXJlbnREYXRhSXRlbTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGFyZW50SW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzQ2hlY2tlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNEaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNFeHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNTZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIG1hbmFnZXMgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSBUcmVlVmlldy5cbiAqL1xuY2xhc3MgVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmF2aWdhdGlvblNlcnZpY2UsIHNlbGVjdGlvblNlcnZpY2UsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UgPSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmluaXRpYWxTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubmF2aWdhdGlvblNlcnZpY2UubW92ZXNcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy51cGRhdGVJdGVtLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZCh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdHNcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoaW5kZXgpID0+IGluZGV4ID09PSB0aGlzLmluZGV4KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGluZGV4KSA9PiB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KGluZGV4LCB0aGlzLmRhdGFJdGVtKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMuc2VsZWN0aW9uU2VydmljZS5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKHRoaXMuaXNTZWxlY3RlZCh0aGlzLmRhdGFJdGVtLCB0aGlzLmluZGV4KSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5pbml0aWFsU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih0aGlzLmluaXRpYWxTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbih0aGlzLmluaXRpYWxTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW0oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMubmF2aWdhdGlvblNlcnZpY2UuaXNBY3RpdmUodGhpcy5pbmRleCksICdrLXN0YXRlLWZvY3VzZWQnKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0aW9uKHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKHNlbGVjdGVkLCAnay1zdGF0ZS1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICByZW5kZXIoYWRkQ2xhc3MsIGNsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBhZGRDbGFzcyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuICAgICAgICB0aGlzLnJlbmRlcmVyW2FjdGlvbl0odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxufVxuVHJlZVZpZXdJdGVtQ29udGVudERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1trZW5kb1RyZWVWaWV3SXRlbUNvbnRlbnRdJyB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblRyZWVWaWV3SXRlbUNvbnRlbnREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOYXZpZ2F0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogU2VsZWN0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH1cbl07XG5UcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRhdGFJdGVtOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW5pdGlhbFNlbGVjdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaXNTZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGhpZGRlblxuICpcbiAqIFJlcHJlc2VudHMgdGhlIENoZWNrQm94IGNvbXBvbmVudCBvZiB0aGUgS2VuZG8gVUkgVHJlZVZpZXcgZm9yIEFuZ3VsYXIuXG4gKlxuICovXG5jbGFzcyBDaGVja0JveENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgcmVuZGVyZXIsIGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBbYGlkYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy9pZCkgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgXyR7Z3VpZCgpfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIFtgdGFiaW5kZXhgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4KSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGNoZWNrIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2hlY2tTdGF0ZSA9ICdub25lJztcbiAgICB9XG4gICAgLy9YWFg6IGltcGxlbWVudCBDb21wb25lbnRWYWx1ZUFjY2Vzc29yXG4gICAgLy9YWFg6IGZvY3VzL2JsdXIgbWV0aG9kc1xuICAgIGdldCBjbGFzc1dyYXBwZXIoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrU3RhdGUgPT09ICdpbmRldGVybWluYXRlJztcbiAgICB9XG4gICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrU3RhdGUgPT09ICdjaGVja2VkJztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBcInRhYmluZGV4XCIpO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTdGF0ZSA9IHRoaXMuaXNDaGVja2VkKHRoaXMubm9kZSwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZS50YXJnZXQuY2hlY2tlZCA/ICdjaGVja2VkJyA6ICdub25lJztcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBWaWV3IFN0YXRlIHNvIHRoYXQgQW5ndWxhciB1cGRhdGVzIHRoZSBpbnB1dCBpZiB0aGUgaXNDaGVja2VkIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgIHRoaXMuY2hlY2tTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5jaGVja1N0YXRlQ2hhbmdlLmVtaXQoc3RhdGUpO1xuICAgIH1cbn1cbkNoZWNrQm94Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGVja2JveCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICBjbGFzcz1cImstY2hlY2tib3hcIlxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgIFtpZF09XCJpZFwiXG4gICAgICAgICAgICBbY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYmluZGV4XCJcbiAgICAgICAgICAgIChjaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAvPlxuICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgIGNsYXNzPVwiay1jaGVja2JveC1sYWJlbFwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIFtmb3JdPVwiaWRcIlxuICAgICAgICA+e3tsYWJlbFRleHR9fTwvbGFiZWw+XG4gICAgYFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DaGVja0JveENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbkNoZWNrQm94Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNsYXNzV3JhcHBlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1jaGVja2JveC13cmFwcGVyJyxdIH1dLFxuICAgIGlkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc0NoZWNrZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG5vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsYWJlbFRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjaGVja1N0YXRlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbmNvbnN0IENPTVBPTkVOVF9ESVJFQ1RJVkVTID0gW1xuICAgIENoZWNrQm94Q29tcG9uZW50XG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KSBkZWZpbml0aW9uIGZvciB0aGUgQ2hlY2tCb3ggY29tcG9uZW50LlxuICovXG5jbGFzcyBDaGVja0JveE1vZHVsZSB7XG59XG5DaGVja0JveE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NUE9ORU5UX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU11cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYWdDbHVlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZHIpIHtcbiAgICAgICAgdGhpcy5jZHIgPSBjZHI7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnBvc2lzdGlvblN0eWxlID0gJ2ZpeGVkJztcbiAgICB9XG4gICAgZ2V0IHN0YXR1c0ljb25DbGFzcygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBEcm9wQWN0aW9uLkFkZDogcmV0dXJuICdrLWktcGx1cyc7XG4gICAgICAgICAgICBjYXNlIERyb3BBY3Rpb24uSW5zZXJ0VG9wOiByZXR1cm4gJ2staS1pbnNlcnQtdXAnO1xuICAgICAgICAgICAgY2FzZSBEcm9wQWN0aW9uLkluc2VydEJvdHRvbTogcmV0dXJuICdrLWktaW5zZXJ0LWRvd24nO1xuICAgICAgICAgICAgY2FzZSBEcm9wQWN0aW9uLkluc2VydE1pZGRsZTogcmV0dXJuICdrLWktaW5zZXJ0LW1pZGRsZSc7XG4gICAgICAgICAgICBjYXNlIERyb3BBY3Rpb24uSW52YWxpZDpcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiAnay1pLWNhbmNlbCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXhwb3NlZCBhcyBhIHB1YmxpYyBtZXRob2QgdGhhdCBjYW4gYmUgY2FsbGVkIGZyb20gb3V0c2lkZSBhcyB0aGUgY29tcG9uZW50IHVzZXMgYE9uUHVzaGAgc3RyYXRlZ3lcbiAgICBkZXRlY3RDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxufVxuRHJhZ0NsdWVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXRyZWV2aWV3LWRyYWctY2x1ZScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF0ZW1wbGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJrLWljb24ge3tzdGF0dXNJY29uQ2xhc3N9fSBrLWRyYWctc3RhdHVzXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4+e3t0ZXh0fX08L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgKm5nSWY9XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie1xuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSXRlbTogc291cmNlSXRlbSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkl0ZW06IGRlc3RpbmF0aW9uSXRlbVxuICAgICAgICAgICAgfVwiXG4gICAgICAgID5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRyYWdDbHVlQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbkRyYWdDbHVlQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5rLWhlYWRlcicsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmstZHJhZy1jbHVlJyxdIH1dLFxuICAgIHBvc2lzdGlvblN0eWxlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5wb3NpdGlvbicsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlIHtcbiAgICBnZXQgY29tcG9uZW50UmVmKCkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLl9jb21wb25lbnRSZWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgaW5pdGFsaXplYCBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgb3RoZXIgc2VydmljZSBtZXRob2RzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRSZWY7XG4gICAgfVxuICAgIHNldCBjb21wb25lbnRSZWYoY29tcG9uZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZiA9IGNvbXBvbmVudFJlZjtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5fY29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSBudWxsO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgbW92ZShsZWZ0LCB0b3AsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0ICsgb2Zmc2V0fXB4YDtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIG9mZnNldH1weGA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0xVRV9PRkZTRVQgPSAxMDtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBSRVRVUk5fQU5JTUFUSU9OX0RVUkFUSU9OID0gMjAwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyYWdDbHVlU2VydmljZSBleHRlbmRzIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfVxuICAgIGluaXRpYWxpemUoY29udGFpbmVyLCB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2NvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHRoaXMubmdPbkRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbHVlQ29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERyYWdDbHVlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSBjb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGNsdWVDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsUmV0dXJuQW5pbWF0aW9uKCk7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgfVxuICAgIG1vdmUobGVmdCwgdG9wKSB7XG4gICAgICAgIHN1cGVyLm1vdmUobGVmdCwgdG9wLCBDTFVFX09GRlNFVCk7XG4gICAgfVxuICAgIGFuaW1hdGVEcmFnQ2x1ZVRvRWxlbWVudFBvc2l0aW9uKHRhcmdldCkge1xuICAgICAgICBpZiAoIShpc1ByZXNlbnQodGFyZ2V0KSAmJiBpc1ByZXNlbnQodGhpcy5lbGVtZW50LmFuaW1hdGUpKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudFZpZXdQb3J0Q29vcmRzID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBjbHVlRWxlbWVudFZpZXdQb3J0Q29vcmRzID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnJldHVybkFuaW1hdGlvbiA9IHRoaXMuZWxlbWVudC5hbmltYXRlKFtcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIDApJyB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt0YXJnZXRFbGVtZW50Vmlld1BvcnRDb29yZHMubGVmdCAtIGNsdWVFbGVtZW50Vmlld1BvcnRDb29yZHMubGVmdH1weCwgJHt0YXJnZXRFbGVtZW50Vmlld1BvcnRDb29yZHMudG9wIC0gY2x1ZUVsZW1lbnRWaWV3UG9ydENvb3Jkcy50b3B9cHgpYCB9XG4gICAgICAgIF0sIFJFVFVSTl9BTklNQVRJT05fRFVSQVRJT04pO1xuICAgICAgICB0aGlzLnJldHVybkFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgICBjYW5jZWxSZXR1cm5BbmltYXRpb24oKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucmV0dXJuQW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0dXJuQW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLnJldHVybkFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZURyYWdDbHVlRGF0YShhY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSkge1xuICAgICAgICBjb25zdCBkcmFnQ2x1ZSA9IHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlO1xuICAgICAgICBpZiAoYWN0aW9uID09PSBkcmFnQ2x1ZS5hY3Rpb24gJiYgZGF0YUl0ZW1zRXF1YWwoc291cmNlSXRlbSwgZHJhZ0NsdWUuc291cmNlSXRlbSkgJiYgZGF0YUl0ZW1zRXF1YWwoZGVzdGluYXRpb25JdGVtLCBkcmFnQ2x1ZS5kZXN0aW5hdGlvbkl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZHJhZ0NsdWUuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICBkcmFnQ2x1ZS5zb3VyY2VJdGVtID0gc291cmNlSXRlbTtcbiAgICAgICAgZHJhZ0NsdWUuZGVzdGluYXRpb25JdGVtID0gZGVzdGluYXRpb25JdGVtO1xuICAgICAgICBkcmFnQ2x1ZS5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZVRleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PT0gdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2UudGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZS5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxufVxuRHJhZ0NsdWVTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmFnQ2x1ZVNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgfVxuXTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyb3BIaW50Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgdGhpcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIH1cbn1cbkRyb3BIaW50Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdrZW5kby10cmVldmlldy1kcm9wLWhpbnQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICAqbmdJZj1cIiF0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBjbGFzcz1cImstaWNvbiBrLWktZHJhZy1hbmQtZHJvcFwiXG4gICAgICAgID5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgKm5nSWY9XCJ0ZW1wbGF0ZVwiXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVwiXG4gICAgICAgID5cbiAgICAgICAgPG5nLXRlbXBsYXRlPlxuICAgIGBcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbkRyb3BIaW50Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGhvc3RDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muay1kcm9wLWhpbnQtY29udGFpbmVyJyxdIH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5wb3NpdGlvbicsXSB9XSxcbiAgICBwb2ludGVyRXZlbnRzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5wb2ludGVyLWV2ZW50cycsXSB9XVxufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERyb3BIaW50U2VydmljZSBleHRlbmRzIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfVxuICAgIGluaXRpYWxpemUoY29udGFpbmVyLCB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2NvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHRoaXMubmdPbkRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaW50Q29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERyb3BIaW50Q29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSBjb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGhpbnRDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmluc3RhbmNlLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG59XG5Ecm9wSGludFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkRyb3BIaW50U2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgVHJlZVZpZXcgZHJhZyBjbHVlIHdoZW4gYW4gaXRlbSBpcyBkcmFnZ2VkLiBUbyBkZWZpbmUgdGhlIGNsdWUgdGVtcGxhdGUsXG4gKiBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZVZpZXdEcmFnQ2x1ZVRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby10cmVldmlldz5gIHRhZ1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtdGVtcGxhdGVzKSkuXG4gKlxuICpcbiAqIFRoZSB0ZXh0LCBhdHRlbXB0ZWQgZHJvcCBhY3Rpb24sIHNvdXJjZSBpdGVtIGFuZCBkZXN0aW5hdGlvbiBpdGVtIGFyZSBhdmFpbGFibGUgYXMgY29udGV4dCB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlOlxuICpcbiAqXG4gKiAtIGBsZXQtdGV4dD1cInRleHRcImAgKGBzdHJpbmdgKVxuICogLSBgbGV0LWFjdGlvbj1cImFjdGlvblwiYCAoW2BEcm9wQWN0aW9uYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfZHJvcGFjdGlvbiAlfSkpXG4gKiAtIGBsZXQtc291cmNlSXRlbT1cInNvdXJjZUl0ZW1cImAgKFtgVHJlZUl0ZW1Mb29rdXBgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVlaXRlbWxvb2t1cCAlfSkpXG4gKiAtIGBsZXQtZGVzdGluYXRpb25JdGVtPVwiZGVzdGluYXRpb25JdGVtXCJgIChbYFRyZWVJdGVtTG9va3VwYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZWl0ZW1sb29rdXAgJX0pKVxuICovXG5jbGFzcyBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufVxuRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdEcmFnQ2x1ZVRlbXBsYXRlXSdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuRHJhZ0NsdWVUZW1wbGF0ZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9XG5dO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlbXBsYXRlIGZvciB0aGUgVHJlZVZpZXcgZHJvcCBoaW50IHdoZW4gYW4gaXRlbSBpcyBkcmFnZ2VkLiBUbyBkZWZpbmUgdGhlIGhpbnQgdGVtcGxhdGUsXG4gKiBuZXN0IGFuIGA8bmctdGVtcGxhdGU+YCB0YWcgd2l0aCB0aGUgYGtlbmRvVHJlZVZpZXdEcm9wSGludFRlbXBsYXRlYCBkaXJlY3RpdmUgaW5zaWRlIGEgYDxrZW5kby10cmVldmlldz5gIHRhZ1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtdGVtcGxhdGVzKSkuXG4gKi9cbmNsYXNzIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59XG5Ecm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0Ryb3BIaW50VGVtcGxhdGVdJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Ecm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVGVtcGxhdGVSZWYsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH1cbl07XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggZW5hYmxlcyB0aGUgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIGl0ZW1zIGluc2lkZSB0aGUgY3VycmVudCBUcmVlVmlldyBvciBiZXR3ZWVuIG11bHRpcGxlIGxpbmtlZCBUcmVlVmlldyBjb21wb25lbnQgaW5zdGFuY2VzLlxuICogVHJpZ2dlcnMgdGhlIFtgbm9kZURyYWdTdGFydGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJhZ3N0YXJ0KSxcbiAqIFtgbm9kZURyYWdgXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2Mtbm9kZWRyYWcpLFxuICogW2Bub2RlRHJvcGBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1ub2RlZHJvcCksXG4gKiBbYG5vZGVEcmFnRW5kYF0oeyUgc2x1ZyBhcGlfdHJlZXZpZXdfdHJlZXZpZXdjb21wb25lbnQgJX0jdG9jLW5vZGVkcmFnZW5kKSxcbiAqIFtgYWRkSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1hZGRpdGVtKSBhbmRcbiAqIFtgcmVtb3ZlSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1yZW1vdmVpdGVtKVxuICogZXZlbnRzIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgYWN0aW9ucyBvY2N1ciBvbiB0aGUgcmVzcGVjdGl2ZSBUcmVlVmlldyBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgRHJhZ0FuZERyb3BEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHpvbmUsIHRyZWV2aWV3LCBkcmFnQ2x1ZVNlcnZpY2UsIGRyb3BIaW50U2VydmljZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnRyZWV2aWV3ID0gdHJlZXZpZXc7XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlID0gZHJhZ0NsdWVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZSA9IGRyb3BIaW50U2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBgcmVtb3ZlSXRlbWAgZXZlbnQgd2lsbCBiZSBmaXJlZCBhZnRlciBhbiBpdGVtIGlzIGRyb3BwZWQgd2hlbiB0aGUgYGN0cmxgIGtleSBpcyBwcmVzc2VkLlxuICAgICAgICAgKiBJZiBlbmFibGVkLCB0aGUgYHJlbW92ZUl0ZW1gIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIG9uIHRoZSBzb3VyY2UgVHJlZVZpZXdcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBkcmFnYW5kZHJvcF90cmVldmlldyAlfSN0b2MtbXVsdGlwbGUtdHJlZXZpZXdzKSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93Q29weSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmZXMgdGhlIFRyZWVWaWV3Q29tcG9uZW50IGluc3RhbmNlcyBpbnRvIHdoaWNoIGRyYWdnZWQgaXRlbXMgZnJvbSB0aGUgY3VycmVudCBUcmVlVmlld0NvbXBvbmVudCBjYW4gYmUgZHJvcHBlZFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGRyYWdhbmRkcm9wX3RyZWV2aWV3ICV9I3RvYy1tdWx0aXBsZS10cmVldmlld3MpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJvcFpvbmVUcmVlVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlclNlbGVjdFN0eWxlID0gJ25vbmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY3JpYmVzIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCBlbGVtZW50IGlmIHRoZSBsYXR0ZXIgaGFzIHRoZSBgdHJhbnNmb3JtYCBDU1MgcHJvcCBhcHBsaWVkLlxuICAgICAgICAgKiBUcmFuc2Zvcm1lZCBwYXJlbnRzIGNyZWF0ZSBuZXcgc3RhY2tpbmcgY29udGV4dCBhbmQgdGhlIGZpeGVkIGNoaWxkcmVuIG11c3QgYmUgcG9zaXRpb24gYmFzZWQgb24gdGhlIHRyYW5zZm9ybWVkIHBhcmVudC5cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgvVGhlX3N0YWNraW5nX2NvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyT2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgdGhpcy50cmVldmlldy50b3VjaEFjdGlvbnMgPSBmYWxzZTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLmluaXRhbGl6ZURyYWdnYWJsZSgpO1xuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5pbml0aWFsaXplKHRoaXMudHJlZXZpZXcuYXNzZXRzQ29udGFpbmVyLCB0aGlzLmRyYWdDbHVlVGVtcGxhdGUgJiYgdGhpcy5kcmFnQ2x1ZVRlbXBsYXRlLnRlbXBsYXRlUmVmKTtcbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UuaW5pdGlhbGl6ZSh0aGlzLnRyZWV2aWV3LmFzc2V0c0NvbnRhaW5lciwgdGhpcy5kcm9wSGludFRlbXBsYXRlICYmIHRoaXMuZHJvcEhpbnRUZW1wbGF0ZS50ZW1wbGF0ZVJlZik7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBoYW5kbGVQcmVzcyh7IG9yaWdpbmFsRXZlbnQgfSkge1xuICAgICAgICBpZiAoIWlzQ29udGVudChvcmlnaW5hbEV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gZ2V0RHJvcFRhcmdldChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnRyZWV2aWV3Lm5vZGVEcmFnU3RhcnQpKSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlEcmFnU3RhcnQob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkpO1xuICAgICAgICAgICAgaWYgKGRyYWdTdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRoZSBkcmFnIHRhcmdldCBvbiBwcmVzcywgc2hvdyBpdCBvbmx5IHdoZW4gaXQncyBhY3R1YWxseSBkcmFnZ2VkXG4gICAgICAgIHRoaXMuZHJhZ2dlZEl0ZW0gPSBjbG9zZXN0V2l0aE1hdGNoKG9yaWdpbmFsRXZlbnQudGFyZ2V0LCAnLmstaW4nKTtcbiAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UuY2FuY2VsUmV0dXJuQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLnVwZGF0ZVRleHQodGhpcy5kcmFnZ2VkSXRlbS5pbm5lclRleHQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lck9mZnNldCA9IGdldENvbnRhaW5lck9mZnNldCh0aGlzLmRyYWdnZWRJdGVtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGhhbmRsZURyYWcoeyBvcmlnaW5hbEV2ZW50LCBjbGllbnRYLCBjbGllbnRZIH0pIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5kcmFnZ2VkSXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gZ2V0RHJvcFRhcmdldChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnRyZWV2aWV3Lm5vZGVEcmFnKSkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB0aGlzLm5vdGlmeURyYWcob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRyZWVWaWV3ID0gdGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZHJvcFBvc2l0aW9uID0gZ2V0RHJvcFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0sIGRyb3BUYXJnZXQsIGNsaWVudFksIHRhcmdldFRyZWVWaWV3LCB0aGlzLmNvbnRhaW5lck9mZnNldCk7XG4gICAgICAgIGNvbnN0IGRyb3BIaW50QW5jaG9yID0gY2xvc2VzdFdpdGhNYXRjaChkcm9wVGFyZ2V0LCAnLmstbWlkJyk7XG4gICAgICAgIHRoaXMudXBkYXRlRHJvcEhpbnRTdGF0ZShkcm9wUG9zaXRpb24sIGRyb3BIaW50QW5jaG9yKTtcbiAgICAgICAgY29uc3QgZHJvcEFjdGlvbiA9IGdldERyb3BBY3Rpb24oZHJvcFBvc2l0aW9uLCBkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHRoaXMudHJlZXZpZXcsIHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW0gPSB0cmVlSXRlbUZyb21FdmVudFRhcmdldCh0YXJnZXRUcmVlVmlldywgZHJvcFRhcmdldCk7XG4gICAgICAgIHRoaXMudXBkYXRlRHJhZ0NsdWVTdGF0ZShkcm9wQWN0aW9uLCBjbGllbnRYLCBjbGllbnRZLCBzb3VyY2VJdGVtLCBkZXN0aW5hdGlvbkl0ZW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaGFuZGxlUmVsZWFzZSh7IG9yaWdpbmFsRXZlbnQsIGNsaWVudFkgfSkge1xuICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLmRyYWdnZWRJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyb3BUYXJnZXQgPSBnZXREcm9wVGFyZ2V0KG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICBjb25zdCBzb3VyY2VUcmVlID0gdGhpcy50cmVldmlldztcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25UcmVlID0gdGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KTtcbiAgICAgICAgY29uc3QgZHJvcFBvc2l0aW9uID0gZ2V0RHJvcFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0sIGRyb3BUYXJnZXQsIGNsaWVudFksIHRoaXMuZ2V0VGFyZ2V0VHJlZVZpZXcoZHJvcFRhcmdldCksIHRoaXMuY29udGFpbmVyT2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHNvdXJjZVRyZWUsIHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkl0ZW0gPSB0cmVlSXRlbUZyb21FdmVudFRhcmdldChkZXN0aW5hdGlvblRyZWUsIGRyb3BUYXJnZXQpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGRlc3RpbmF0aW9uSXRlbSkgJiYgaXNQcmVzZW50KGRyb3BQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4gdGhpcy5ub3RpZnlEcm9wKHsgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtLCBkcm9wUG9zaXRpb24sIHNvdXJjZVRyZWUsIGRlc3RpbmF0aW9uVHJlZSB9LCBvcmlnaW5hbEV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5hbmltYXRlRHJhZ0NsdWVUb0VsZW1lbnRQb3NpdGlvbih0aGlzLmRyYWdnZWRJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT2JzZXJ2ZXJzKHRoaXMudHJlZXZpZXcubm9kZURyYWdFbmQpKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHRoaXMubm90aWZ5RHJhZ0VuZCh7IHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSwgb3JpZ2luYWxFdmVudCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UuaGlkZSgpO1xuICAgICAgICB0aGlzLmRyYWdnZWRJdGVtID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlRHJvcEhpbnRTdGF0ZShkcm9wUG9zaXRpb24sIGRyb3BIaW50QW5jaG9yKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KGRyb3BIaW50QW5jaG9yKSB8fCBkcm9wUG9zaXRpb24gPT09IERyb3BQb3NpdGlvbi5PdmVyIHx8ICFpc1ByZXNlbnQoZHJvcFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5kcm9wSGludFNlcnZpY2UuaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvclZpZXdQb3J0Q29vcmRzID0gZHJvcEhpbnRBbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGluc2VydEJlZm9yZSA9IGRyb3BQb3NpdGlvbiA9PT0gRHJvcFBvc2l0aW9uLkJlZm9yZTtcbiAgICAgICAgY29uc3QgdG9wID0gaW5zZXJ0QmVmb3JlID8gYW5jaG9yVmlld1BvcnRDb29yZHMudG9wIDogKGFuY2hvclZpZXdQb3J0Q29vcmRzLnRvcCArIGFuY2hvclZpZXdQb3J0Q29vcmRzLmhlaWdodCk7XG4gICAgICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5tb3ZlKGFuY2hvclZpZXdQb3J0Q29vcmRzLmxlZnQgLSB0aGlzLmNvbnRhaW5lck9mZnNldC5sZWZ0LCB0b3AgLSB0aGlzLmNvbnRhaW5lck9mZnNldC50b3ApO1xuICAgICAgICB0aGlzLmRyb3BIaW50U2VydmljZS5zaG93KCk7XG4gICAgfVxuICAgIHVwZGF0ZURyYWdDbHVlU3RhdGUoZHJvcEFjdGlvbiwgY2xpZW50WCwgY2xpZW50WSwgc291cmNlSXRlbSwgZGVzdGluYXRpb25JdGVtKSB7XG4gICAgICAgIC8vIGNsZWFyIGFueSBwb3NzaWJsZSBjb250YWluZXIgb2Zmc2V0IGNyZWF0ZWQgYnkgcGFyZW50IGVsZW1lbnRzIHdpdGggYHRyYW5zZm9ybWAgY3NzIHByb3BlcnR5IHNldFxuICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5tb3ZlKGNsaWVudFggLSB0aGlzLmNvbnRhaW5lck9mZnNldC5sZWZ0LCBjbGllbnRZIC0gdGhpcy5jb250YWluZXJPZmZzZXQudG9wKTtcbiAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UudXBkYXRlRHJhZ0NsdWVEYXRhKGRyb3BBY3Rpb24sIHNvdXJjZUl0ZW0sIGRlc3RpbmF0aW9uSXRlbSk7XG4gICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLnNob3coKTtcbiAgICB9XG4gICAgaW5pdGFsaXplRHJhZ2dhYmxlKCkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoe1xuICAgICAgICAgICAgcHJlc3M6IHRoaXMuaGFuZGxlUHJlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRyYWc6IHRoaXMuaGFuZGxlRHJhZy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVsZWFzZTogdGhpcy5oYW5kbGVSZWxlYXNlLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLmRyYWdnYWJsZS5iaW5kVG8odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpKTtcbiAgICB9XG4gICAgbm90aWZ5RHJhZ1N0YXJ0KG9yaWdpbmFsRXZlbnQsIGRyb3BUYXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSXRlbSA9IHRyZWVJdGVtRnJvbUV2ZW50VGFyZ2V0KHRoaXMudHJlZXZpZXcsIGRyb3BUYXJnZXQpO1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBUcmVlSXRlbURyYWdTdGFydEV2ZW50KHsgc291cmNlSXRlbSwgb3JpZ2luYWxFdmVudCB9KTtcbiAgICAgICAgdGhpcy50cmVldmlldy5ub2RlRHJhZ1N0YXJ0LmVtaXQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIG5vdGlmeURyYWcob3JpZ2luYWxFdmVudCwgZHJvcFRhcmdldCkge1xuICAgICAgICBjb25zdCBkcmFnRXZlbnQgPSB7XG4gICAgICAgICAgICBzb3VyY2VJdGVtOiB0cmVlSXRlbUZyb21FdmVudFRhcmdldCh0aGlzLnRyZWV2aWV3LCB0aGlzLmRyYWdnZWRJdGVtKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uSXRlbTogdHJlZUl0ZW1Gcm9tRXZlbnRUYXJnZXQodGhpcy5nZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KSwgZHJvcFRhcmdldCksXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJlZXZpZXcubm9kZURyYWcuZW1pdChkcmFnRXZlbnQpO1xuICAgIH1cbiAgICBub3RpZnlEcm9wKGFyZ3MsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgVHJlZUl0ZW1Ecm9wRXZlbnQoYXJncywgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgIGFyZ3MuZGVzdGluYXRpb25UcmVlLm5vZGVEcm9wLmVtaXQoZXZlbnQpO1xuICAgICAgICAvLyBkaXNhYmxlIHRoZSBhbmltYXRpb25zIG9uIGRyb3AgYW5kIHJlc3RvcmUgdGhlbSBhZnRlcndhcmRzIChpZiB0aGV5IHdlcmUgaW5pdGlhbGx5IHR1cm5lZCBvbilcbiAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9uc0Zvck5leHRUaWNrKGFyZ3MuZGVzdGluYXRpb25UcmVlKTtcbiAgICAgICAgaWYgKGFyZ3Muc291cmNlVHJlZSAhPT0gYXJncy5kZXN0aW5hdGlvblRyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUFuaW1hdGlvbnNGb3JOZXh0VGljayhhcmdzLnNvdXJjZVRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQ2x1ZVNlcnZpY2UuaGlkZSgpO1xuICAgICAgICAgICAgLy8gb3JkZXIgbWF0dGVycyBpbiBhIGZsYXQgZGF0YSBiaW5kaW5nIHNjZW5hcmlvIChmaXJzdCBhZGQsIHRoZW4gcmVtb3ZlKVxuICAgICAgICAgICAgYXJncy5kZXN0aW5hdGlvblRyZWUuYWRkSXRlbS5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFdmVudC5jdHJsS2V5ICYmIHRoaXMuYWxsb3dDb3B5KSkge1xuICAgICAgICAgICAgICAgIGFyZ3Muc291cmNlVHJlZS5yZW1vdmVJdGVtLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGx5IGhpZGUgdGhlIGNsdWUgaWYgdGhlIGRlZmF1bHQgaXMgcHJldmVudGVkXG4gICAgICAgICAgICB0aGlzLmRyYWdDbHVlU2VydmljZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmlzVmFsaWQpIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGUgdGhlIGNsdWUgYmFjayB0byB0aGUgc291cmNlIGl0ZW0gcG9zaXRpb24gaWYgbWFya2VkIGFzIGludmFsaWRcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NsdWVTZXJ2aWNlLmFuaW1hdGVEcmFnQ2x1ZVRvRWxlbWVudFBvc2l0aW9uKHRoaXMuZHJhZ2dlZEl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeURyYWdFbmQoZHJhZ0VuZEV2ZW50KSB7XG4gICAgICAgIHRoaXMudHJlZXZpZXcubm9kZURyYWdFbmQuZW1pdChkcmFnRW5kRXZlbnQpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRUcmVlVmlldyhkcm9wVGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRyZWVWaWV3VGFnTmFtZSA9IHRoaXMudHJlZXZpZXcuZWxlbWVudC5uYXRpdmVFbGVtZW50LnRhZ05hbWU7XG4gICAgICAgIGNvbnN0IHRhcmdldFRyZWVWaWV3ID0gY2xvc2VzdFdpdGhNYXRjaChkcm9wVGFyZ2V0LCB0cmVlVmlld1RhZ05hbWUpO1xuICAgICAgICByZXR1cm4gW3RoaXMudHJlZXZpZXcsIC4uLnRoaXMuZHJvcFpvbmVUcmVlVmlld3NdLmZpbmQodHJlZVZpZXcgPT4gaXNQcmVzZW50KHRyZWVWaWV3KSAmJiB0cmVlVmlldy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgPT09IHRhcmdldFRyZWVWaWV3KTtcbiAgICB9XG4gICAgZGlzYWJsZUFuaW1hdGlvbnNGb3JOZXh0VGljayh0cmVlVmlldykge1xuICAgICAgICAvLyB0aGUgdHJlZVZpZXcuYW5pbWF0ZSBnZXR0ZXIgcmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgdHVybmVkIG9mZlxuICAgICAgICAvLyBjb25mdXNpbmcsIGJ1dCBzZWVtcyBvbiBwdXJwb3NlICh0aGUgYGFuaW1hdGVgIHByb3Agc2V0cyB0aGUgdmFsdWUgb2YgdGhlIEAuZGlzYWJsZWQgaG9zdC1ib3VuZCBhdHRyaWJ1dGUpXG4gICAgICAgIGlmICh0cmVlVmlldy5hbmltYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJlZVZpZXcuYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc2V0VGltZW91dCgoKSA9PiB0cmVlVmlldy5hbmltYXRlID0gdHJ1ZSkpO1xuICAgIH1cbn1cbkRyYWdBbmREcm9wRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9UcmVlVmlld0RyYWdBbmREcm9wXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIERyYWdDbHVlU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgRHJvcEhpbnRTZXJ2aWNlXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmFnQW5kRHJvcERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogVHJlZVZpZXdDb21wb25lbnQgfSxcbiAgICB7IHR5cGU6IERyYWdDbHVlU2VydmljZSB9LFxuICAgIHsgdHlwZTogRHJvcEhpbnRTZXJ2aWNlIH1cbl07XG5EcmFnQW5kRHJvcERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBhbGxvd0NvcHk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRyb3Bab25lVHJlZVZpZXdzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkcmFnQ2x1ZVRlbXBsYXRlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlLF0gfV0sXG4gICAgZHJvcEhpbnRUZW1wbGF0ZTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbRHJvcEhpbnRUZW1wbGF0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIHVzZXJTZWxlY3RTdHlsZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUudXNlci1zZWxlY3QnLF0gfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS4tbXMtdXNlci1zZWxlY3QnLF0gfV1cbn07XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggZW5hYmxlcyB0aGUgdXBkYXRlIG9mIHRoZSBpbml0aWFsbHkgcHJvdmlkZWQgZGF0YSBhcnJheSBkdXJpbmcgZHJhZy1hbmQtZHJvcC5cbiAqXG4gKiBFaXRoZXIgdXNlIHRoaXMgZGlyZWN0aXZlIGluIGNvbWJpbmF0aW9uIHdpdGggb25lIG9mIHRoZSBkYXRhIGJpbmRpbmcgZGlyZWN0aXZlcyAoW2BrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ2BdKHslIHNsdWcgYXBpX3RyZWV2aWV3X2hpZXJhcmNoeWJpbmRpbmdkaXJlY3RpdmUgJX0pXG4gKiBvciBbYGtlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmdgXSh7JSBzbHVnIGFwaV90cmVldmlld19mbGF0ZGF0YWJpbmRpbmdkaXJlY3RpdmUgJX0pKSB3aGljaCBzZXQgdGhlaXIgb3duIGVkaXQgaGFuZGxlcnMsIG9yIHByb3ZpZGVcbiAqIHlvdXIgb3duIFtgZWRpdFNlcnZpY2VgXSh7JSBzbHVnIGFwaV90cmVldmlld19lZGl0c2VydmljZSAlfSkgdG8gdGhpcyBkaXJlY3RpdmUuIFRoZSBsYXR0ZXIgc3Vic2NyaWJlcyB0byBhbmQgY2FsbHMgdGhlXG4gKiBbYGFkZEl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtYWRkaXRlbSkgYW5kIFtgcmVtb3ZlSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1yZW1vdmVpdGVtKVxuICogaGFuZGxlcnMgd2hlbiB0aGUgY29ycmVzcG9uZGluZyBldmVudHMgYXJlIHRyaWdnZXJlZCBieSB0aGUgVHJlZVZpZXcgY29tcG9uZW50LlxuICovXG5jbGFzcyBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRyZWV2aWV3KSB7XG4gICAgICAgIHRoaXMudHJlZXZpZXcgPSB0cmVldmlldztcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZXZpZXcuYWRkSXRlbS5zdWJzY3JpYmUodGhpcy5oYW5kbGVBZGQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMudHJlZXZpZXcucmVtb3ZlSXRlbS5zdWJzY3JpYmUodGhpcy5oYW5kbGVSZW1vdmUuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGhhbmRsZXJzIGNhbGxlZCBvbiBkcmFnLWFuZC1kcm9wIFtgYWRkSXRlbWBdKHslIHNsdWcgYXBpX3RyZWV2aWV3X3RyZWV2aWV3Y29tcG9uZW50ICV9I3RvYy1hZGRpdGVtKVxuICAgICAqIGFuZCBbYHJlbW92ZUl0ZW1gXSh7JSBzbHVnIGFwaV90cmVldmlld190cmVldmlld2NvbXBvbmVudCAlfSN0b2MtcmVtb3ZlaXRlbSkgZXZlbnRzLlxuICAgICAqL1xuICAgIHNldCBlZGl0U2VydmljZShzZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMudHJlZXZpZXcuZWRpdFNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGhhbmRsZUFkZChhcmdzKSB7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMudHJlZXZpZXcuZWRpdFNlcnZpY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGBlZGl0U2VydmljZWAgcHJvdmlkZWQuIEVpdGhlciBwcm92aWRlIHlvdXIgb3duIGltcGxlbWVudGF0aW9uIG9yIHVzZSB0aGlzIGRpcmVjdGl2ZSBpbiBjb21iaW5hdGlvbiB3aXRoIG9uZSBvZiB0aGUgZGF0YSBiaW5kaW5nIGRpcmVjdGl2ZXMgKGBrZW5kb1RyZWVWaWV3SGllcmFyY2h5QmluZGluZ2Agb3IgYGtlbmRvVHJlZVZpZXdGbGF0RGF0YUJpbmRpbmdgKS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyZWV2aWV3LmVkaXRTZXJ2aWNlLmFkZChhcmdzKTtcbiAgICB9XG4gICAgaGFuZGxlUmVtb3ZlKGFyZ3MpIHtcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy50cmVldmlldy5lZGl0U2VydmljZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYGVkaXRTZXJ2aWNlYCBwcm92aWRlZC4gRWl0aGVyIHByb3ZpZGUgeW91ciBvd24gaW1wbGVtZW50YXRpb24gb3IgdXNlIHRoaXMgZGlyZWN0aXZlIGluIGNvbWJpbmF0aW9uIHdpdGggb25lIG9mIHRoZSBkYXRhIGJpbmRpbmcgZGlyZWN0aXZlcyAoYGtlbmRvVHJlZVZpZXdIaWVyYXJjaHlCaW5kaW5nYCBvciBga2VuZG9UcmVlVmlld0ZsYXREYXRhQmluZGluZ2ApLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJlZXZpZXcuZWRpdFNlcnZpY2UucmVtb3ZlKGFyZ3MpO1xuICAgIH1cbn1cbkRyYWdBbmREcm9wRWRpdGluZ0RpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvVHJlZVZpZXdEcmFnQW5kRHJvcEVkaXRpbmddJ1xuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5EcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUcmVlVmlld0NvbXBvbmVudCB9XG5dO1xuRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGVkaXRTZXJ2aWNlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMkMSA9IFtcbiAgICBUcmVlVmlld0NvbXBvbmVudCxcbiAgICBUcmVlVmlld0dyb3VwQ29tcG9uZW50LFxuICAgIFRyZWVWaWV3SXRlbURpcmVjdGl2ZSxcbiAgICBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlLFxuICAgIE5vZGVUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDaGVja0RpcmVjdGl2ZSxcbiAgICBEaXNhYmxlRGlyZWN0aXZlLFxuICAgIEV4cGFuZERpcmVjdGl2ZSxcbiAgICBTZWxlY3REaXJlY3RpdmUsXG4gICAgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSxcbiAgICBMb2FkaW5nSW5kaWNhdG9yRGlyZWN0aXZlLFxuICAgIEZsYXREYXRhQmluZGluZ0RpcmVjdGl2ZSxcbiAgICBEcmFnQW5kRHJvcERpcmVjdGl2ZSxcbiAgICBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIERyYWdDbHVlQ29tcG9uZW50LFxuICAgIERyb3BIaW50VGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJvcEhpbnRDb21wb25lbnQsXG4gICAgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlXG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNoYXJlZE1vZHVsZSB7XG59XG5TaGFyZWRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0NPTVBPTkVOVF9ESVJFQ1RJVkVTJDFdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFUyQxXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDaGVja0JveE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIERyYWdDbHVlQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBEcm9wSGludENvbXBvbmVudFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXSB9LFxuXTtcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBUcmVlVmlld0NvbXBvbmVudCxcbiAgICBOb2RlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQ2hlY2tEaXJlY3RpdmUsXG4gICAgRGlzYWJsZURpcmVjdGl2ZSxcbiAgICBFeHBhbmREaXJlY3RpdmUsXG4gICAgU2VsZWN0RGlyZWN0aXZlLFxuICAgIEhpZXJhcmNoeUJpbmRpbmdEaXJlY3RpdmUsXG4gICAgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLFxuICAgIERyYWdBbmREcm9wRGlyZWN0aXZlLFxuICAgIERyYWdDbHVlVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRHJvcEhpbnRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEcmFnQW5kRHJvcEVkaXRpbmdEaXJlY3RpdmVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgZGVmaW5pdGlvbiBmb3IgdGhlIFRyZWVWaWV3IGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgVHJlZVZpZXdNb2R1bGUge1xufVxuVHJlZVZpZXdNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtFWFBPUlRTXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbU2hhcmVkTW9kdWxlXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IENoZWNrQm94Q29tcG9uZW50LCBDaGVja0JveE1vZHVsZSwgRGF0YUNoYW5nZU5vdGlmaWNhdGlvblNlcnZpY2UsIERyYWdDbHVlQ29tcG9uZW50LCBEcmFnQ2x1ZVNlcnZpY2UsIERyb3BIaW50Q29tcG9uZW50LCBEcm9wSGludFNlcnZpY2UsIERyYWdBbmREcm9wQXNzZXRTZXJ2aWNlLCBQcmV2ZW50YWJsZUV2ZW50LCBFeHBhbmRTdGF0ZVNlcnZpY2UsIEluZGV4QnVpbGRlclNlcnZpY2UsIExvYWRpbmdJbmRpY2F0b3JEaXJlY3RpdmUsIExvYWRpbmdOb3RpZmljYXRpb25TZXJ2aWNlLCBOYXZpZ2F0aW9uU2VydmljZSwgTm9kZUNoaWxkcmVuU2VydmljZSwgU2VsZWN0aW9uU2VydmljZSwgU2hhcmVkTW9kdWxlLCBUcmVlVmlld0dyb3VwQ29tcG9uZW50LCBUcmVlVmlld0l0ZW1Db250ZW50RGlyZWN0aXZlLCBUcmVlVmlld0l0ZW1EaXJlY3RpdmUsIFRyZWVWaWV3TG9va3VwU2VydmljZSwgVHJlZVZpZXdDb21wb25lbnQsIFRyZWVWaWV3TW9kdWxlLCBOb2RlVGVtcGxhdGVEaXJlY3RpdmUsIENoZWNrRGlyZWN0aXZlLCBEaXNhYmxlRGlyZWN0aXZlLCBFeHBhbmREaXJlY3RpdmUsIFNlbGVjdERpcmVjdGl2ZSwgSGllcmFyY2h5QmluZGluZ0RpcmVjdGl2ZSwgRmxhdERhdGFCaW5kaW5nRGlyZWN0aXZlLCBEcmFnQW5kRHJvcERpcmVjdGl2ZSwgRHJhZ0FuZERyb3BFZGl0aW5nRGlyZWN0aXZlLCBEcm9wSGludFRlbXBsYXRlRGlyZWN0aXZlLCBEcmFnQ2x1ZVRlbXBsYXRlRGlyZWN0aXZlLCBEcm9wQWN0aW9uLCBEcm9wUG9zaXRpb24sIFRyZWVJdGVtRHJvcEV2ZW50LCBUcmVlSXRlbURyYWdTdGFydEV2ZW50LCBUcmVlSXRlbURyYWdFdmVudCB9O1xuIl19